

## 🎯핵심 키워드

---

<aside>
💡 주요 내용들에 대해 조사해보고, 자신만의 생각을 통해 정리해보세요!
레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 됩니다.
조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**

</aside>

- **지연로딩과 즉시로딩의 차이**
    
    
    즉시 로딩은 **연관된 엔티티를 즉시**(즉, 현재 쿼리 실행 시) **함께 가져오는 방식**입니다. `@ManyToOne`, `@OneToOne` 관계에서 기본값으로 사용되는 로딩 방식입니다.
    
    즉시로딩(eager 로딩) 
    Manytoone의 경우 기본적으로 Eager로딩(즉시로딩)방식으로 동작한다 
    join을 하게되면 여러테이블이 엮여있을 수 있다 ⇒ 성능 저하
    모든 데이터베이스가 단일 쿼리에서 검색다음 캐시되어 애플리케이션 성능 향상 가능 하지만 모든 데이터를 단일 쿼리에서 로드하기 때문에 메모리 사용량이 증가하고 그만큼 리스크가 증가함
    
    지연로딩(Lazy로딩)
    
    내가 필요하지 않으면 조회하지 않는 것이다 즉 필요한 내용의 테이블만 사용해서 엮여있는 테이블은 제외하고 조회한다  ⇒ 성능 향상
    
    지연로딩에서는 초기 데이터와 관련된 추가 데이터가 필요할 때 단일 쿼리에서 필요한 양의 데이터만 검색한다. ⇒ 애플리케이션 서버와 데이터베이스 서버 간에 여러번의 왕복이 있음을 의미한다 대부분의 애플리케이션에서 주요 성능 병목 현상이다. 왕복이 적을 수록 성능이 좋아진다
    
- **Fetch Join**
    
    **지연 로딩(Lazy Loading)의 N+1** 문제를 해결하기 위한 **JPQL (Java Persistence Query Language)** 기능으로 데이터베이스의 **연관된 엔티티를 한 번의 쿼리로 함께 가져오도록** 만드는 방법
    즉 jpql에서  성능최적화를위해 제공하는 기능으로 패치조인을 사용하면 연관된 엔티티나 컬렉션을 한번에 조회할 수 있어서 글로벌 로딩전략을 지연로딩으로 설정했을때 패치조인도 같이 설정하면 성능을 향상 수 있기에 패치조인을 사용하는 이유이다.
    N+1문제 해결 방안 : 
     Fetch Join ⇒ 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능으로 JPQL에서 연관 엔티티를 즉시 로딩
    
- **@EntityGraph**
    
    
    JPA에서 **지연 로딩(LAZY)** 문제를 해결하거나, **복잡한 쿼리 없이 연관된 엔티티를 한 번에 로딩**하고 싶을 때 사용하는 기능으로 개발자가 연관 엔티티들을 함께 로딩 할 것인지 어노테이션으로 명시하고 해당하는 엔티티는 eager 로딩 방식으로 진행된다.
    N+1문제 해결 방안 :  미리 설정한 테이블을 가져오게 설정함으로 JPA에게 미리 알려주는 것이다. 그렇기에 나중에 LAZY 때문에 추가 쿼리를 날리는 걸 방지할 수 있다.
    
- **JPQL**
    
    JPQL은 **JPA 전용 쿼리 언어**로 객체를 중심으로 작성한다. 거의 sql문법과 비슷하지만 중요한 차이점은 JPQL은 엔티티와 필드가 기준으로 작성된다. 그외 문법자체는 sql과 동일하다
    
- **QueryDSL**
    
    QueryDSL은 정적 타입(=IDE 자동완성) 기반의 JPQL 빌더로 기존 JPQL은 오타나 필드 변경시 런타임 오류이기에 디버깅하기 번거롭고 복잡한 조건문 처리에 어려움이 있기에 QueryDSL은 유지보수 측면에서 이점이 있다. 자바코드로 쿼리를 작성하기에 가독성 향상이 되고, 타입 안정성 확보 (컴파일 타임 오류 탐지), DTO 매핑 등 여러 기능을 지원한다.
    N+1문제 해결 방안 : **연관된 엔티티를 한 번의 쿼리로 가져오는 방식**을 사용해서 해결가능
    

## 📢 학습 후기

---

- 이번 주차 워크북을 해결해보면서 어땠는지 회고해봅시다.
- 핵심 키워드에 대해 완벽하게 이해했는지? 혹시 이해가 안 되는 부분은 뭐였는지?

<aside>
💡

</aside>

## ⚠️ 스터디 진행 방법

---

1. 스터디를 진행하기 전, 워크북 내용들을 모두 채우고 스터디에서는 서로 모르는 내용들을 공유해주세요.
2. 미션은 워크북 내용들을 모두 완료하고 나서 스터디 전/후로 진행해보세요.
3. 다음주 스터디를 진행하기 전, 지난주 미션을 서로 공유해서 상호 피드백을 진행하시면 됩니다.

## ✅ 실습 체크리스트

---

## ☑️ 실습 인증

---

`feature/week6` 브랜치를 판 후 실습 코드를 전부 첨부하여 진행해주세요. 

## 🔥 미션

---

1. N+1 문제를 해결할 수 있는 여러 가지 다른 방법들에 대해 조사한 후, [ 핵심 키워드 ] 에 정리
2. 2주차 미션 때 했던 해당 화면들에 대해 작성했던 쿼리를 QueryDSL로 작성하여 리팩토링하기

![내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)](Untitled.png)

내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)

2주차 쿼리문

SELECT ump.mission_name, ump.status FROM user_mission_pointcounter ump
JOIN member m ON m.phone_number = ump.phone_number
JOIN mission miss ON miss.mission_name = ump.mission_name WHERE ump.created_at <- (SELECT created_at FROM user_mission_pointcounter WHERE ____←(이부분에 화면에서 이미 나와있는 가장 늦은 created_at을 넣는다 )) ORDER BY ump.created_at DESC LIMIT 20;

---

쿼리dsl

```java
@Repository
@RequiredArgsConstructor
public class UmpRepositoryImpl implements UmpRepositoryCustom {
    private final JPAQueryFactory jpaQueryFactory;
    private final QUserMissionPointcounter ump  = QUserMissionPointcounter.userMissionPointcounter;
    QMember member = QMember.member;
    QMission mission = QMission.mission;

    //@Override
    public List<UmpFirstDTO> firstpictureWithCursor(LocalDateTime cursorCreatedAt) {
        BooleanBuilder predicate = new BooleanBuilder();

        if (cursorCreatedAt != null) {
            predicate.and(ump.createdAt.lt(cursorCreatedAt)); // 커서 조건
        }

        return jpaQueryFactory
                .select(Projections.constructor(UmpFirstDTO.class, ump.phonenumberMissionid, ump.status))
                .from(ump)
                .join(ump.member, member).on(member.phoneNumber.eq(ump.member.phoneNumber))
                .join(ump.mission, mission).on(mission.missionid.eq(ump.mission.missionid))
                .where(predicate)
                .orderBy(ump.createdAt.desc())
                .limit(20)
                .fetch();
    }
}
```

![리뷰 작성하는 쿼리,
* 사진의 경우는 일단 배제](Untitled%201.png)

리뷰 작성하는 쿼리,
* 사진의 경우는 일단 배제

2주차 쿼리문

SELECT rv.title, rv.score, rv.description, rv.reply FROM review rv
JOIN member m ON rv.phone_number = m.phone_number
GROUP BY rv.phone_number

---

쿼리dsl

```java
package umc.study.repository.ReviewRepository;

import com.querydsl.core.types.Projections;
import com.querydsl.jpa.impl.JPAQueryFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;
import umc.study.domain.QMember;
import umc.study.domain.mapping.QReview;
import umc.study.dto.ReviewDTO;

import java.util.List;

@Repository
@RequiredArgsConstructor
public class ReviewRepositoryImpl implements ReviewRepositoryCustom {
    private final JPAQueryFactory jpaQueryFactory;
    private final QReview rv  = QReview.review;
    QMember member = QMember.member;

    //@Override
    public List<ReviewDTO> secondpicture(String title, int score,
                                                          String reply, String description) {

        return jpaQueryFactory
                .select(Projections.bean(ReviewDTO.class,
                        rv.title, rv.score, rv.description, rv.reply))
                .from(rv)
                .join(member).on(member.phoneNumber.eq(rv.member.phoneNumber))
                .orderBy(rv.member.phoneNumber.asc())
                .fetch();
    }
}
```

![홈 화면 쿼리
(현재 선택 된 지역에서 도전이 가능한 미션 목록, 페이징 포함)](Untitled%202.png)

홈 화면 쿼리
(현재 선택 된 지역에서 도전이 가능한 미션 목록, 페이징 포함)

2주차 쿼리문

SELECT ump.completed_mission, miss.store_name, miss.created_at
FROM user_mission_pointcounter ump
JOIN mission miss ON miss.store_name=ump.store_name
WHERE miss.created_at < (SELECT created_at FROM mission WHERE ____←(이부분에 화면에서 이미 나와있는 가장 늦은 created_at을 넣는다 ))
ORDER BY miss.created_at DESC LIMIT 20;

---

쿼리dsl

```java
package umc.study.repository.UserMemberPointcounterRepository;

import com.querydsl.core.BooleanBuilder;
import com.querydsl.core.types.Projections;
import com.querydsl.jpa.impl.JPAQueryFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;
import umc.study.domain.QMember;
import umc.study.domain.QMission;
import umc.study.domain.mapping.QUserMissionPointcounter;
import umc.study.dto.UmpFirstDTO;
import umc.study.dto.UmpThirdDTO;

import java.time.LocalDateTime;
import java.util.List;

@Repository
@RequiredArgsConstructor
public class UmpRepositoryImpl implements UmpRepositoryCustom {
    private final JPAQueryFactory jpaQueryFactory;
    private final QUserMissionPointcounter ump  = QUserMissionPointcounter.userMissionPointcounter;
    QMember member = QMember.member;
    QMission mission = QMission.mission;

  
    //@override
    public List<UmpThirdDTO> thirdpictureWithCursor(int phoneNumber, LocalDateTime cursorCreatedAt) {

        BooleanBuilder predicate = new BooleanBuilder();

        if (phoneNumber != 0) {
            predicate.and(member.phoneNumber.eq(phoneNumber));
        }
        //ph 가oneNumber와 같은 값을진 Member와 연관된 UserMissionPointcounter(ump) 레코드만 조회됩니다.
        if (cursorCreatedAt != null) {
            predicate.and(ump.createdAt.lt(cursorCreatedAt)); // 커서 조건 : "현재 커서 시점보다 더 과거의 데이터만 가져온다."
        }

        return jpaQueryFactory
                .select(Projections.constructor(UmpThirdDTO.class, ump.completedMission, mission.missionid, mission.createdAt))
                .from(ump)
                .join(ump.mission, mission).on(mission.missionid.eq(ump.mission.missionid))
                .where(predicate)
                .orderBy(ump.createdAt.desc())
                .limit(20)
                .fetch();
    }
}
```

![마이 페이지 화면 쿼리](Untitled%203.png)

마이 페이지 화면 쿼리

2주차 쿼리문

SELECT m.nickname, m.phone_number, m.email, ump.total_point, rv.review_name, cm.title FROM member m
JOIN user_mission_pointcounter ump ON m.phone_number=ump.phone_number
JOIN review rv ON m.phone_number=rv.phone_number
JOIN cmr cm ON m.phone_number=cm.phone_number;

---

쿼리dsl

```java
package umc.study.repository.MemberRepository;

import com.querydsl.core.types.Projections;
import com.querydsl.jpa.impl.JPAQueryFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;
import umc.study.domain.QMember;
import umc.study.domain.mapping.QReview;
import umc.study.domain.mapping.QUserMissionPointcounter;
import umc.study.domain.QCrm;
import umc.study.dto.MemberDetailDTO;

import java.util.List;

@Repository
@RequiredArgsConstructor
public class MemberRepositoryImpl implements MemberRepositoryCustom{
    QUserMissionPointcounter ump = QUserMissionPointcounter.userMissionPointcounter;
    QReview rv = QReview.review;
    QCrm cm = QCrm.crm;

    private final JPAQueryFactory jpaQueryFactory;
    private final QMember member  = QMember.member;

    public List<MemberDetailDTO> fourthpicture(String nickname, int phonenumber,
                                               String email, int totalpoint, String reviewName, String crmTitle){

        return jpaQueryFactory.select(Projections.bean(MemberDetailDTO.class,
                        member.nickname,
                        member.phoneNumber,
                        member.email,
                        ump.totalPoint,
                        rv.reviewId,
                        cm.title  // DTO의 필드명과 다르면 as()로 맞춰야 함
                ))
                .from(member, cm, rv, ump)
                .join(ump).on(member.phoneNumber.eq(ump.member.phoneNumber))
                .join(rv).on(member.phoneNumber.eq(rv.member.phoneNumber))  // review 테이블과 JOIN
                .join(cm).on(member.phoneNumber.eq(cm.member.phoneNumber))  // cmr 테이블과 JOIN
                .fetch();

    }
}

```

# 💪 미션 기록

---

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

- **미션 기록**
    
    막히는 부분들만 따로 정리
    
    큐클래스 : 엔티티 클래스 속성과 구조를 설명해주는 **메타데이터**로 Type-safe 하게 퀴리 조건 설정 가능
    **기본적으로** Spring Boot JPA에서 Querydsl을 사용하여 쿼리문을 만들 때는 **해당 엔티티에 대해 생성된 Q 클래스에 정의된 메소드와 필드값만 사용하는 것이 원칙**이다.
    
    BooleanBuilder : 동적쿼리를 만들기 위한 라이브러리
    
    JPA 레포지토리 선언 -> JPA쿼리팩토리 빈 등록 -> 커스텀 레포지토리 인터페이스 생성(여기서 쿼리 dsl로 수행할 메소드들을 선언해줘야한다) -> 전 단계에서 커스텀 레포지토리에 + Impl 을 붙여서 커스텀 레포지토리임플 클래스를 구현해야한다 이 클래스는 커스텀 레포지토리를 인터페이스로 갖는다. -> 사용할 JPA 레포지터리 수정
    
    처음 만든 JPA 레포지토리에
    package umc.study.repository.StoreRepository; import com.querydsl.core.BooleanBuilder; import com.querydsl.jpa.impl.JPAQueryFactory; import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Repository; import umc.study.domain.QStore; import umc.study.domain.Store; import java.util.List;
    @Repository
    @RequiredArgsConstructor
    public class StoreRepositoryImpl implements StoreRepositoryCustom{
    private final JPAQueryFactory jpaQueryFactory; private final QStore store = QStore.store;
    
    @Override public List<Store> dynamicQueryWithBooleanBuilder(String name, Float score) { BooleanBuilder predicate = new BooleanBuilder();
    if (name != null) { predicate.and(store.name.eq(name)); }
    if (score != null) { predicate.and(store.score.goe(4.0f)); }
    return jpaQueryFactory
    .selectFrom(store)
    .where(predicate)
    .fetch();
    
    }
    }
    를 작성함으로 쿼리문을 사용할 수 있다.
    
    BooleanBuilder를 통해서 if문에 있는 JPA화된 내용들을 SQL문으로 번역해주는 역할이다. 즉 BooleanBuilder를 통해서 where을 구현할 수있다
    
    select 절은 큐클래스에 들고 있는 필드를 넣어주고 이것을 어디에 조회를 할 것인지에 대한 큐클래스를 넣어주면 된다.
    
    where조건에는 큐클래스에서 만든 메소드들과 필드들을 사용할 수 있다.
    
    결과 조회 메소드
    .fetchOne() : return Store => 하나의 결과 값을 가져오고 싶을때
    .fetch() : return List<Store>  => 예를 들어 리스트와 같은 형태의 데이터를 가져오고 싶을때
    .fetchFirst() : limit(1).fetchOne() => fetchOne()과 동일 하지만 맨 앞단에 리밋을 붙여준 것과 동일하다
    
    여기서 조인도 가능한데
    연관관계가 없는 테이블간 조인은 카테시안 곱이 발생하기에 주의해야한다
    inner조인의 경우 on이나 where이나 같은 동작을 한다.
    
    if (name != null) {
    predicate.and(store.name.eq(name));
    }
    
    if (score != null) {
    predicate.and(store.score.goe(score));
    }
    
    if (city != null) {
    predicate.and(store.city.eq(city));
    }
    
    if (isOpen != null) {
    predicate.and(store.isOpen.eq(isOpen));
    }
    => sql문으로 바뀌면
    
    WHERE name = 'xxx'
    AND score >= 4.0
    AND city = 'Seoul'
    AND is_open = true
    이런 형식이다.
    N+1 문제 해결할려고 JPQL을 사용하는 이유다
    쿼리dsl은 fetchJoin()이라는 메소드를 제공하기에 이를 통해서 N+1문제를 해결 할 수있다.
    
    2개 사의 OnetoMany 관계에서는 연속된 fetchjoin()이 불가능하다.
    
    JPAQuery
    일반적으로 사용하는 쿼리문 생성 사용범위가 넓다
    
    서브쿼리 작성법
    JPAExpressions 유틸성 클래스, 다양한 select 메서드 지원, 사용 범위가 서브 쿼리에 더 맞춰져 있음
    
    dynamicQueryWithBooleanBuilder의 파라미터는 해당 테이블의 컬럼 값이다 여기서 조인된 테이블의 컬럼을 추가하기 위해서
    큐클래스.컬럼명 = 컬럼명; 형식으로 작성하여
    dynamicQueryWithBooleanBuilder의 파라미터에 넣어야한다.
    
    `@NoArgsConstructor` 어노테이션은 **Lombok** 라이브러리에서 제공하는 어노테이션 중 하나로, **매개변수가 없는 기본 생성자(default constructor)**를 자동으로 생성해줍니다.
    
    쿼리를 QueryDSL로 작성하여 리팩토링한다면 어떻게해
    
    - 가독성 향상
    - 타입 안정성 확보 (컴파일 타임 오류 탐지)
    - DTO 매핑
    - 유지보수성 향상
    // dsl 작성시 DTO의 필드명과 다르면 as()로 맞춰야 함
    
    DTO에서 `enum` 타입은 **그대로 `Enum` 타입으로 선언**하면 되고, QueryDSL에서도 **직접 매핑이 가능합니다.**
    
    하나의 DTO에 모든 필드를 포함 (비추천)
    
    모든 필드를 하나의 DTO에 넣는 방식도 가능은 하지만,
    
    **불필요한 필드가 null로 채워지고 유지보수가 어려워져서 비효율적**입니다
    DTO는 select 대상에 맞게 개별 설계하는 것이 최선입니다.
    
    같은 테이블 레포지토리에서 메소드를 따로 설정함으로 여러 쿼리dsl 구현이 가능하다.
    
    DTO에서
    @Data
    
    @AllArgsConstructor
    
    @NoArgsConstructor
    해당 어노테이션을 사용함으로 생성자를 스프링부트에서 만들어줌으로 사용가능하다 여기서 주의할 점은 DTO클래스를 쿼리dsl에서 사용시 Projections.bean()을 사용해서 구현하는데 ()안에 들어가는 파라미터의 순서랑 DTO클래스에서 작성한 필드 순서가 같아야한다.
    
    predicate.and([ump.createdAt.lt](http://ump.createdat.lt/)(cursorCreatedAt));
    해석 :
    
    - `predicate`: `BooleanBuilder` 객체입니다. `where` 절에 들어갈 조건들을 누적해서 쌓는 데 사용됩니다.
    - `ump.createdAt`: `UserMissionPointcounter` 엔티티의 `createdAt` 필드 (생성 시각).
    - `lt(...)`: "less than" (작다)를 의미하는 메서드입니다.
    - `cursorCreatedAt`: 파라미터로 전달된 기준 시간입니다 (예: 페이지네이션의 커서 역할).
    
    [시니어 미션](https://www.notion.so/1e7b57f4596b812d944afe17d10b427d?pvs=21)
    

## ⚡ 트러블 슈팅

---

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

</aside>

<aside>
💡 스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널에 질문**해보세요!

</aside>

- ⚡이슈 작성 예시 (이슈가 생기면 아래를 복사해서 No.1, No.2, No3 … 으로 작성해서 트러블 슈팅을 꼭 해보세요!)
    
    **`이슈`**
    
    👉 앱 실행 중에 노래 다음 버튼을 누르니까 앱이 종료되었다.
    
    **`문제`**
    
    👉 노래클래스의 데이터리스트의 Size를 넘어서 NullPointException이 발생하여 앱이 종료된 것이었다. 
    
    **`해결`**
    
    👉  노래 다음 버튼을 눌렀을 때 데이터리스트의 Size를 검사해 Size보다 넘어가려고 하면 다음으로 넘어가는 메서드를 실행시키지 않고, 첫 노래로 돌아가게끔 해결
    
    **`참고레퍼런스`**
    
    - 링크
- ⚡이슈 No.1
    
    **`이슈`**
    
    👉 [트러블이 생긴 상태 작성]
    
    **`문제`**
    
    👉 [어떤 이유로 해당 이슈가 일어났는지 작성]
    
    **`해결`**
    
    👉  [해결 방법 작성]
    
    **`참고레퍼런스`**
    
    - [문제 해결 시 참고한 링크]

## 🤔 참고 자료

---

Copyright © 2025 신수정(베뉴) All rights reserved.