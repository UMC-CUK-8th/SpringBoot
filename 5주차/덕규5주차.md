# 시니어 미션

- **JPA의 깊은 개념을 이해하고 실제 서비스에서 발생하는 문제를 해결**한다.
- **복잡한 연관관계 매핑 & 성능 최적화**를 고려한 엔티티 설계를 적용한다.

---

### 📌 **미션 상세 내용**

### **1️⃣ 성능을 고려한 연관관계 매핑 & 최적화 적용**

- **`@OneToMany` 컬렉션을 조회할 때 `List<MemberPrefer>`를 `Set<MemberPrefer>`로 변경 후 차이점 분석**
- **데이터 정합성을 고려하여 `orphanRemoval = true`가 필요한 곳 확인 후 적용**

|   | List<MemberPrefer>  | Set<MemebrPrefer> |
| --- | --- | --- |
| 저장 순서 | 보장 | 보장 X |
| 중복 허용 | 허용 | 허용 X |
| 조회 순서 | 인덱스 기반 | 해쉬 기반 |
| Hibernate | `List`는 인덱스 기반으로 관리
→ 추가, 삭제, 수정 쿼리가 과도하게 나갈 수 있음 | `Set`은 단순 추가/삭제 
→ **불필요한 UPDATE 쿼리 없이 깔끔하게 관리** 가능 |

- List
    - 인덱스 기반으로 관리
    - 읽기 순서가 중요
    - OneToMany
        - 리스트는 인덱스 기반으로 관리 → 모든 컬럼 기억 필요
        - 각 요소 순서 기억 → 인덱스 추가 → 모든 인덱스 밀고 당기는 작업 발생
        - 그렇기 때문에 불필요한 작업량 증가

- Set
    - 해쉬 기반으로 관리
    - 중복 X, 성능 최적화가 중요
    - OneToMany
        - 중복 없는 집합 → 객체 여부만 관리
        - 추가, 삭제만 반영

- orphanRemoval = true
    - 부모 객체 컬렉션에서 자식 개체 삭제 → 자식 객체 자동 삭제
    - List
        - 정확히 어떤 객체 삭제인지 알기 힘듦
        - List.remove(1)의 의미가 모호
    - Set
        - Set.remove(Object o)를 통해 정확히 삭제 가능
        - 객체 자체를 기준으로 삭제하기 때문

---

### **2️⃣ 트랜잭션 & 동시성 이슈 처리**

- **하나의 트랜잭션에서 여러 엔티티를 처리하는 비즈니스 로직 작성**
    - 예) `Member`가 탈퇴할 경우 **관련된 모든 데이터를 삭제하는 API** 구현
    - `@Transactional`을 적용하고, `@Modifying`을 활용하여 **Batch Delete 쿼리 최적화**
- **동시성 문제가 발생할 수 있는 시나리오**를 고민하고 해결책 적용
    - 예) 같은 회원이 동시에 같은 `Store`를 찜하려고 할 때 중복이 발생하지 않도록 `@Lock` 사용
    - 다양한 락킹 전략에 대해 공부해보고, 이를 정리하기

- 하나의 트랜잭션 서비스에서 선호, 주문, 회원 삭제
    
    ```java
    @Service
    @RequiredArgsConstructor
    public class MemberService {
    
        private final MemberRepository memberRepository;
        private final OrderRepository orderRepository;
        private final MemberPreferRepository memberPreferRepository;
    
        @Transactional
        public void withdrawMember(Long memberId) {
            // 1. 선호 삭제
            memberPreferRepository.deleteByMemberId(memberId);
    
            // 2. 주문 삭제
            orderRepository.deleteByMemberId(memberId);
    
            // 3. 회원 삭제
            memberRepository.deleteById(memberId);
        }
    }
    
    ```
    
    - @Modifying 레포지토리 단에 구현
        
        ```java
        public interface MemberPreferRepository extends JpaRepository<MemberPrefer, Long> {
        
            @Modifying(clearAutomatically = true)
            @Query("DELETE FROM MemberPrefer mp WHERE mp.member.id = :memberId")
            void deleteByMemberId(@Param("memberId") Long memberId);
        }
        
        ```
        
        - BatchDelete 최적화 : JPQL 통한 삭제 처리
        - @Modifying + JPQL → 곧바로 DELETE FROM ~ 실행
            1. clearAutomatically = true → 1차 캐시 갱신 → flush 이후 데이터 일관성 보장

- 동시성 문제 발생 가능
    - 같은 memberId에 대해 삭제요청이 몰리는 경우
        
        : 삭제 요청을 광클하는 경우
        
    
    ```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT m FROM Member m WHERE m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") Long id);
    ```
    
    - 비관적 락
        - 동시에 같은 리소스를 수정하려는 트랜잭션 간 충돌 차단
        - 하나의 트랜잭션만 자원 점유
            
            A→ Thread 획득 → 점유 해제
            
            B→ 대기 → Thread 비면 점유
            
        - 일종의 세마포어
            
            : 그러나 1개 자원에 1개 트랜잭션만 접근 허용