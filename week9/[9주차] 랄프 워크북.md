# 시니어 미션

---

Page 테스트 코드

```java
@Test
public class TestEntityTest {

    @Autowired
    private TestEntityRepository testEntityRepository;

    @BeforeEach
    void setUp() {
        for (int i = 0; i < 1000; i++) {
            testEntityRepository.save(new TestEntity(String.valueOf(i)));
        }
    }

    @Test
    void findPage() {
        PageRequest pageRequest = PageRequest.of(3, 10); // 4번째 페이지, 사이즈 10
        Page<TestEntity> result = testEntityRepository.findPageBy(pageRequest);

        System.out.println(result);
    }
}

```

실제 쿼리 값

```java
select t1_0.id, t1_0.name 
from test_entity t1_0 
limit 10 offset 30
```

Slice 테스트코드 값

```java
@Test
public class TestEntitySliceTest {

    @Autowired
    private TestEntityRepository testEntityRepository;

    @BeforeEach
    void setUp() {
        for (int i = 0; i < 1000; i++) {
            testEntityRepository.save(new TestEntity(String.valueOf(i)));
        }
    }

    @Test
    void findSlice() {
        PageRequest pageRequest = PageRequest.of(3, 10); // 4번째 페이지
        Slice<TestEntity> result = testEntityRepository.findSliceBy(pageRequest);

        System.out.println("isFirst: " + result.isFirst());
        System.out.println("isLast: " + result.isLast());
        System.out.println("hasNext: " + result.hasNext());
        System.out.println("content: " + result.getContent());
    }
}

```

실제 쿼리 값

```java
select t1_0.id, t1_0.name 
from test_entity t1_0 
limit 11 offset 30
```

장단점

- 페이지
    - 장점 : 전체 개수를 제공해 UI에서 총 페이지수 출력 가능
    - 단점 : 쿼리로 성능 저하 발생 , 대용량일 수록 비효율
- 슬라이스
    - 성능 우수- 간단한 기반 페이징 - 무한 스크롤 등 UX에 적합
    - 총 페이지 수나 전체 개수 정보를 제공하지 않음. 전체 페이지 기반 UI에는 부적합

성능을 봐서는 Slice를 사용하는 것이 좋다. 그렇다면 무조건 Slice를 쓰는 것이 옳은것일까? 그건 아니다. 우리는 다양한 서비스를 만들게 될테고 우리가 표현하고자 하는 내용은 각자 다를 것이다. 그때마다 적절하게 선택하면 된다.

무조건 Slice를 선택하는 것이 능사는 아니라는 것이다. 페이지를 사용하고자 하는 부분에서는 어느정도의 성능 저하를 감수하더라도 사용자의 편의를 위해 페이지를 사용하는 것이 좋을것 같다.

참고 자료 https://sigridjin.medium.com/java-stream-api%EB%8A%94-%EC%99%9C-for-loop%EB%B3%B4%EB%8B%A4-%EB%8A%90%EB%A6%B4%EA%B9%8C-50dec4b9974b

```java
// for-loop
int[] a = ints;
int e = ints.length;
int m = Integer.MIN_VALUE;
for (int i = 0; i < e; i++) {
    if (a[i] > m) {
        m = a[i];
    }
}
// sequential stream
int m = Arrays.stream(ints).reduce(Integer.MIN_VALUE, Math::max);
```

[결과]

for-loop : 0.36 ms

stream : 5.35 ms

### **1. Stream API의 등장 배경**

- Java 8에서 도입된 **Stream API**는 코드의 가독성과 유지보수를 향상시키기 위해 등장.
- 내부 반복자(Internal Iterator) 방식으로, 개발자는 연산만 정의하면 내부에서 순회가 자동으로 이루어짐.
- 대표적으로 filter, map, reduce 등의 함수형 연산을 메서드 체이닝 방식으로 수행함 (Fluent API).

---

### 2. **왜 Stream은 느릴까?**

- **JIT Compiler**는 수십 년간 for-loop을 최적화해왔음.
- Stream은 비교적 최근(2015년 이후)에 도입되어 컴파일러의 최적화 수준이 낮음.

### 실험 결과 (기기: Intel E8500, Java 8 기준):

- int[] 배열에서 최대값 찾기:
    - for-loop: **0.36ms**
    - Stream: **5.35ms** → 약 **15배** 느림

---

### 3. **Primitive vs Wrapper**

- int[] (primitive)보다 Integer (wrapper)의 경우, Stream과 for-loop 간 성능 차이가 **거의 없음**.
    - 이유: wrapper는 heap 메모리에 저장되어 참조 비용이 더 큼 → 순회 비용 자체가 큼 → 최적화 효과 상쇄

---

### 4. **계산 비용이 높은 함수면 Stream도 경쟁력 있음**

- slowSin() 같은 고비용 함수 연산에서는 Stream이 오히려 빠르거나 동등한 성능을 보임.
    - 순회 비용 < 계산 비용인 상황에서는 Stream의 장점이 살아남.

---

### 5. **Parallel Stream (병렬 스트림)의 특성**

- parallelStream()은 **Fork-Join Framework** 기반으로 멀티스레드로 실행.
- 병렬 스트림이 항상 빠른 것은 아님:
    - 오히려 **작은 데이터**, **split이 어려운 구조 (예: LinkedList)**, **계산 비용이 적은 연산**에는 **오버헤드 때문에 느릴 수 있음**
    - **ArrayList + 고비용 연산** 조합이 병렬 스트림의 이상적인 케이스

---

### 6. **Stateful 연산의 성능 저하**

- 병렬 스트림에서 shared state에 접근하면 **동기화 비용** 발생
- 순서를 보장해야 하는 경우엔 병렬화가 오히려 독이 됨

### 최종 정리

**가독성(유지보수) 측면**

| 항목 | Stream API | for-loop |
| --- | --- | --- |
| **가독성** | 가독성 높음: 연산의 목적이 명확하고 선언적으로 표현 가능 . 메서드 체이닝으로 간결한 코드 | 반복 로직이 장황해질 수 있음. 중첩되면 가독성 급감 |
| **유지보수** | 로직 변경이 쉬움 (필터 추가, 매핑 등) 함수형 스타일로 테스트 및 분리 용이 |  중복 코드 발생 가능성 높음 .변경 시 반복문 범위 등 실수 위험 |
| **적합한 상황** | - 필터링, 매핑, 집계 등 데이터 변환 시 - 간결하게 표현하고 싶은 반복 로직 - 협업 시 가독성이 중요한 경우 | - 복잡한 흐름 제어가 필요한 경우 (break, continue, label) - 반복 중 값 변경/탈출 조건이 많은 경우 |

---

성능 측면

| 항목 | Stream API | for-loop |
| --- | --- | --- |
| **성능** |  기본적으로 for-loop보다 느림 . 특히 primitive type 순회는 성능 차이 큼 |  JIT 최적화가 잘 되어 있어 빠름  primitive 배열 순회 시 매우 빠름 |
| **병렬 처리** | parallelStream()으로 병렬 처리 가능 연산 비용이 큰 경우 유리 |  기본적으로 순차 처리 .단, 멀티스레드 직접 구현 가능 |
| **적합한 상황** | - 데이터 크기가 **10000개 이상** - 연산 비용이 **높은 경우** (e.g. 복잡한 수학함수) - 다중 CPU 코어를 활용하고 싶은 경우 | - 연산이 가볍고, 데이터 수가 적은 경우 (e.g. <1000) - 성능이 중요한 시스템 (e.g. 실시간 처리) |