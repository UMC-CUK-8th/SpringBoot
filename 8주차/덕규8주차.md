# 시니어 미션

**미션 목표:**

- **@DynamicInsert, @DynamicUpdate** 어떻게 작동되는 지 파악하고 장단점을 파악 후에 언제 **적용**하면 좋을 지 파악해보기
- **Rest Docs**가 무엇인지 알아보고 **Swagger**와 장단점 파악하기

**미션 상세 내용:**

### 1️⃣ @DynamicInsert와 @DynamicUpdate가 어떻게 작동되는 지 파악하기

- 기존 JPA 쿼리문
    - **INSERT**: JPA는 매핑된 모든 컬럼(속성)의 값을 SQL에 나열
    - **UPDATE**: 변경 여부와 관계없이 엔티티의 모든 컬럼을 다시 갱신

- @DynamicInsert
    - **INSERT** 시점에 실제 `null`이 아닌(또는 영속화된) 속성만 골라 SQL에 포함
        - A컬럼을 비워놓는다면 A컬럼은 빠지고, DB의 DEFAULT 값이 적용됨

- @DynamicUpdate
    - **Update** 시점에 실제로 변경된 속성만 골라 적용
        - A컬럼만 변경했다면 A컬럼만 갱신
        - 최소 컬럼만 갱신 → 과부하 감소
    

### 2️⃣ 기존과 @DynamicInsert, @DynamicUpdate 적용 시 장단점 파악하기

|            구분 |                        장점 |                      단점 |
| --- | --- | --- |
| 기본 INSERT/UPDATE | - SQL 생성이 단순해 오버헤드 적음- 배치(Batch) 처리 용이 | - 모든 컬럼을 무조건 갱신→불필요한 쓰기 발생- DB DEFAULT 활용 불가 |
| @DynamicInsert | - INSERT 시점에 실제 데이터만 저장
→ NULL 컬럼은 DB DEFAULT 활용
- 네트워크 I/O 절감 | - SQL 생성 로직이 런타임에 동적으로 실행돼 약간의 오버헤드
- SQL 로그 분석 시 컬럼 가변 |
| @DynamicUpdate  | - 변경된 컬럼만 갱신
→락 범위·트래픽 축소
- 동시성 충돌 위험 완화 가능 | - Dirty 체크 비용 증가(속성별 변경 추적)
- 배치 업데이트 시 SQL 캡처 어려움 |

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- **@DynamicInsert**
    - **DB DEFAULT**(예: `created_at`, `status` 등) 를 적극 활용하고 싶을 때
    - 엔티티에 **NULL** 허용 컬럼이 많아 INSERT 시점에 불필요한 값을 건너뛰고 싶을 때
    
- **@DynamicUpdate**
    - 대규모 엔티티(컬럼 수 많음) 를 부분 변경할 때 쓰기 부하를 최소화하고 싶을 때
    - 동시성 환경에서 **락 범위**를 좁혀 업데이트 충돌을 줄이고 싶을 때

### 1️⃣ Rest Docs가 무엇인지 알아보기

- 참고문서
    - https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/
    - https://techblog.woowahan.com/2597/

- Spring Rest Docs
    - Spring에서 제공하는 API 문서화 도구
        - 테스트 실행 결과에서 추출한 예시 기반 → 문서 스니펫 생성
        - 코드와 문서 간 불일치 해소
    - 스니펫
        - 생성된 스니펫은 요청 파라미터, 응답 필드, 헤더 설명 등 독립적 관리
        - 모듈화된 문서 자유롭게 조합 → 일관성 있는 레퍼런스 형식
    

### 2️⃣ Swagger와 Rest Docs의 장단점 비교하기

- Swagger
    - 장점
        - API 동작 테스트에 특화
        - API 테스트 가능한 화면 제공
        - 적용이 쉽다
    - 단점
        - 제품 코드에 어노테이션을 추가해야한다
        - 제품 코드와 동기화가 안될 수 있다
- Spring Rest Docs
    - 장점
        - 깔끔 명료한 문서 작성에 특화
        - 제품에 영향을 미치지 않는다
        - 테스트가 성공해야 문서에 영향을 미치지 않는다
    - 단점
        - 실제로 적용하기가 어렵다

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- Swagger 사용 시점
    - API 동작하는 기능 테스트
        - Interactive한 UI를 통해 테스트하기 적합
    - API 설계 초기, 클라이언트와 백엔드 간의 Contract 정의 시점
        - 개발자 or 파트너에게 테스트 가능한 샌드박스 제공

- Rest Docs 사용 시점
    - 기본적인 개발 종료 후 Front 단과의 API 연동 시점
        - 테스트 기반 정적 레퍼런스 문서
        - 코드 - 문서의 일치 보장
    - 구현된 API의 정확한 동작 예시 문서화가 필요로할 때