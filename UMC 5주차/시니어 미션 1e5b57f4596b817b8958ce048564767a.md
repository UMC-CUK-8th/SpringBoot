# 시니어 미션

- **JPA의 깊은 개념을 이해하고 실제 서비스에서 발생하는 문제를 해결**한다.
- **복잡한 연관관계 매핑 & 성능 최적화**를 고려한 엔티티 설계를 적용한다.

---

### 📌 **미션 상세 내용**

### **1️⃣ 성능을 고려한 연관관계 매핑 & 최적화 적용**

- **`@OneToMany` 컬렉션을 조회할 때 `List<MemberPrefer>`를 `Set<MemberPrefer>`로 변경 후 차이점 분석**
- **데이터 정합성을 고려하여 `orphanRemoval = true`가 필요한 곳 확인 후 적용**

---

set은 개념적으로 중복 방지가 된다는 장점이 있지만, jpa의 지연 로딩 기능과 결합되면 성능 이슈를 유발할 수 있다.

```java
@Entity
@Getter
@Builder
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
public class Member extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String address;

    @OneToMany(mappedBy = "member", cascade = CascadeType.ALL)
    private List<MemberPrefer> memberPreferList = new ArrayList<>();
}

```

현재 member 과 memberPrefer는 1:N 양방향 관계.

이때 member를 조회하면 연관관계에 있는 memberpreferlist는 지연로딩으로 프록시 객체로 초기화된 상태.

-list 사용?

이때 위 코드처럼 list를 사용한다면 중복 체크를 하지 않기에 list에 값을 추가해도 기존 값과 비교를 진행하지 않음. 따라서 객체가 프록시 상태더라도 안전하게 접근해 추가가 가능. 

컬렉션이 초기화되지 않아도 괜찮고, 성능에도 영향을 주지 않기에 list에 새로운 객체 추가가 가능.

-set을 사용한다면?

내부적으로 equals와 hashCode를 사용해 중복을 판단. 

중복 판단을 위해 기존 요소와 비교해야하므로, hibernate는 강제로 프록시를 초기화 해버림 (즉 DB에서 데이터 전부 조회해버리기에 n+1문제 유발이 가능해 성능 저하 우려, 지연로딩의 이점이 무효화된다. )

 

**JPA의 지연 로딩 특성상 `Set`을 사용할 경우 중복 체크 때문에 컬렉션 전체를 불러오는 문제가 생길 수 있다.**

반면 list는 중복 확인을 하지 않기 때문에 프록시 상태에서도 안전하게 사용할 수 있어, **실무에서는 안정성과 성능 면에서 `List`가 더 적합**

---

## 고아객체

**부모 엔티티와 연관관계가 끊어진 자식 엔티티**를 가리킴.

부모가 제거될때, 부모와 연관되어있는 모든 자식 엔티티들은 고아객체가 됩니다.

`orphanRemoval = true`는 **부모 엔티티와의 연관관계가 끊어진 자식 엔티티를 자동으로 삭제**하고 싶을 때 사용하는 설정

설정하지 않으면 부모가 삭제돼도 db에 고아 데이터가 남아 있음.

```java
member.getMemberPreferList().remove(0); // 리스트에서 제거
```

list에서 자식 엔티티를 제거하더라도 db에는 삭제되지 않고 남아있음.

```java
@OneToMany(mappedBy = "member", cascade = CascadeType.ALL, orphanRemoval = true)
private List<MemberPrefer> memberPreferList = new ArrayList<>();

```

옵션 사용시 jpa에서 자동으로 DB에서 DELETE 처리.

-언제 사용?

- 자식이 오직 해당 부모에만 속해있고, 다른 엔티티와 공유x인 경우
- 자식이 더 이상 부모에 속하지 않게될 떄

부모-자식 연관이 제거되면 (부모가 삭제되면) 자식도 자동 삭제된다.

-vs CascadeType.REMOVE?

Cascade.ALL은 PERSIST, MERGE, REMOVE, REFRESH, DETACH와 같은 상태 변환를 관리한다. 즉, 수정, 삭제, 추가의 작업이 일어날 때 연쇄적으로 관계를 갖는 엔티티에 영향을 주는 것

CascadeType.REMOVE에서는 고아 객체가 발생하더라도 실제 DB에서 제거되지는 않는다.
→ 단순히 `List.remove(child)`만 한다고 DB에서 자식이 삭제되지 않음

부모, 자식을 가질 때 부모와의 관계가 끊어졌을 때 자식을 삭제하는 것. 

가장 대표적인 것이 부모가 삭제 되었을 떄이다. 그러나 Cascade.ALL과 다른 점은 자식의 외래키에 변경이 있을 때 부모와의 관계가 끊어진 것이라서 그 경우에도 자식을 삭제한다. 

삭제만 일어나는 상황에서는 둘이 같은 결과를 나타낸다.

CascadeType.ALL, orphanRemoval = true

조합은 **부모-자식 관계를 강하게 묶고**, **자식의 생명주기를 부모에 완전히 위임**

하기위해 함께 사용됨.

---

### **2️⃣ 트랜잭션 & 동시성 이슈 처리**

- **하나의 트랜잭션에서 여러 엔티티를 처리하는 비즈니스 로직 작성**
    - 예) `Member`가 탈퇴할 경우 **관련된 모든 데이터를 삭제하는 API** 구현
    - `@Transactional`을 적용하고, `@Modifying`을 활용하여 **Batch Delete 쿼리 최적화**

**-Batch Delete**란? 

**여러 개의 데이터를 한 번의 쿼리로 삭제하는 방식**

member 삭제시 관련 정보인 MemberPrefer, review, memberMission 등 함께 삭제

```java
@Transactional
public void deleteMember(Long memberId) {
    //관련 데이터 삭제 (Batch Delete로 최적화 가능)
    memberPreferRepository.deleteByMemberId(memberId);
    orderRepository.deleteByMemberId(memberId);

		//member 삭제 
    memberRepository.deleteById(memberId);
}
```

`@Modifying`에는 반드시 `@Transactional`이 필요.

변경 작업은 트랜잭션 내에서 실행되어야 하며, 완료x 변경 작업이 여러 작업에 영향을 줄 수 있기 때문.

엔티티 객체가 아닌, **직접 JPQL 또는 SQL을 사용해 삭제**하기 때문에, 삭제 대상 객체에 대한 **영속성 컨텍스트 동기화는 안됨**

```java
@Modifying
@Query("delete from MemberPrefer mp where mp.member.id = :memberId")
void deleteByMemberId(@Param("memberId") Long memberId);

```

- **동시성 문제가 발생할 수 있는 시나리오**를 고민하고 해결책 적용
    - 예) 같은 회원이 동시에 같은 `Store`를 찜하려고 할 때 중복이 발생하지 않도록 `@Lock` 사용
    - 다양한 락킹 전략에 대해 공부해보고, 이를 정리하기

-Lock이란 ?

공유 자원에 대한 동시 액세스를 제어하는 가장 기본적인 방법으로 

단일 스레드 또는 단일 프로세스에서만 동작하여, 한 번에 하나의 스레드만 공유 자원에 액세스 할 수 있다.

안전하지만 교착상태나 경쟁 조건같은 문제 발생 가능.

**교착상태 (deadlock)**

- 모든 transaction이 대기 상태에 들어가 아무런 진행이 일어나지 않는 상태를 교착상태라고 한다. 교착상태에 빠지면 외부에서 강제로 트랜잭션을 중단하거나 잠금을 해제하지 않는 이상 무한정 대기 상태로 남게 된다.

-Lock 활용한 동시성 제어 기법

1. 낙관적 락

충돌이 발생할 가능성이 낮은 경우 사용됨. 

- 데이터를 읽을 때 lock을 사용하지 않고, 업데이트 시 **내가 읽은 version이 맞는지 충돌 여부를 확인**하여 처리한다.
- **즉, 자원에 lock을 직접 걸어서 선점하지 않고, 동시성 문제가 실제로 발생하면 그때가서 처리하는 방식**

실제 락을 활용하지 않아 성능면에서 좋지만, 동시성 문제가 빈번하게 일어나면 계속 rollback 처리를 해줘야하는 단점

1. 비관적 락
- 충돌이 발생할 가능성이 높은 경우 사용됨.
- 데이터를 읽거나 수정하기 전에 lock을 획득하여 다른 사용자의 액세스를 차단하고, lock을 가진 스레드만 접근하도록 제어

모든 트랜잭션에 무조건 lock을 사용하기에 읽기 작업이 많은 경우 부적합. 대규모 트래픽 상황에서 여러 테이블에 lock을 걸며 서로 자원이 필요하면 비관적 락으로 해결할 수 없는 데드락이 발생 가능.

1. 분산 락

여러 컴퓨터 또는 프로세스 간에 공유된 자원에 대한 동시 액세스를 제어하기 위해 사용

대표적으로 Redis가 있는데 
 

- 오직 한 순간에 하나의 작업자만이 락(lock) 을 걸 수 있다.
- 락 이후, 어떠한 문제로 인해 락을 풀지 못하고, 종료된 경우라도 다른 작업자가 락을 획득할 수 있어야한다.
- Redis 노드가 작동하는 한 모든 작업자가 락을 걸고 해체할 수 있다.

분산 락을 구현하기 위해 lock의 정보를 Redis에 저장해둠.

분산환경에서 여러 서버들을 Redis를 바라보며 자신이 공유 자원에 접근 가능한지 확인.

-redis에 접근할 수 있는 클라이언트로  jedis, lettuce, redisson 등이 있음.

각각에도 차이가 있는데

- Lettuce:  ‘스핀락’이라는 폴링 기법을 활용해 Lock 재시도 (획득할 떄 까지 계속 요청)
- Redisson: Redis의 Pub/suc 기능으로 특정 채널을 구독하고, Lock 획득 실패 시, 다시 획득할 수 있는 상태가 됐다고 이벤트를 받으면 다시 Lock 시도

1. 스핀 락

**자원에 대한 접근이 필요할 때 무한루프를 돌면서 반복적으로 확인**하며, 다른 스레드가 lock을 해제할 때까지 대기

경쟁 상태 (2개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황)가 짧고 자원 점유 시간이 길지 않은 경우에 효과적

[프록시(Proxy)와 지연로딩(Lazy Loading)](https://velog.io/@bagt/%ED%94%84%EB%A1%9D%EC%8B%9CProxy%EC%99%80-%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9Lazy-Loading)