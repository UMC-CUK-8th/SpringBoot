## 🎯 핵심 키워드

<aside>
💡 주요 내용들을 정리하고, 여러분만의 생각을 통해 정리해보세요!

- 레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 괜찮습니다.
- 조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**
</aside>

- **Spring Security**
    
    Spring 프레임워크 기반 애플리케이션에서 인증(Authentication)과 인가(Authorization)를 처리하기 위한 강력한 **보안 프레임워크**
    
    주요 기능
    
    - **AuthenticationManager**
        - **인증(Authentication)** 과정을 관리하는 중심 컴포넌트
        - 사용자가 로그인을 시도할 때, **`AuthenticationManager`**가 사용자의 자격 증명(예: 이메일/비밀번호)을 받아 이를 인증할 수 있는 프로세스를 호출
        
    - **AuthenticationProvider**
        - 실제로 인증 로직을 처리하는 역할을 담당
        - 여러 **`AuthenticationProvider`**가 존재할 수 있으며, 각각은 특정 인증 방식을 처리
        
    - **SecurityContextHolder**
        - `SecurityContextHolder`는 현재 보안 컨텍스트에 대한 세부 정보를 보관
        - 기본적으로 **ThreadLocal**을 사용하여 동일한 스레드 내에서는 각 사용자의 인증 정보를 개별적으로 유지
        - 즉, 요청마다 인증된 사용자의 정보를 보존하고, 다른 요청에서는 다른 사용자의 정보를 처리
        - **SecurityContextHolder의 주요 역할**
            - 인증된 사용자 정보를 **SecurityContext**에 저장 및 관리.
            - 이후의 요청에서 **SecurityContext**를 통해 인증된 정보를 참조하여 사용자의 권한이나 인증 상태를 확인.
            - 애플리케이션의 어디서나 **`SecurityContextHolder.getContext()`** 메서드를 사용해 인증 정보를 접근할 수 있음.
        
    - **SecurityContext**
        - **인증이 완료된 사용자 정보를 저장하는 컨텍스트**
        - 이 정보는 애플리케이션 전반에서 공유되며, **`SecurityContextHolder`**를 통해 접근할 수 있음
        
    - **Security Filter Chain**
        - 정의: Filter Chain은 Spring Security에서 HTTP 요청을 처리할 때 사용하는 일련의 필터들. 각 필터는 특정 보안 기능을 담당하며, 요청이 애플리케이션에 도달하기 전에 이 필터들을 순차적으로 통과
        - 주요 필터 정리
            - **SecurityContextPersistenceFilter**
                - 요청 간 SecurityContext를 유지함
                - 새 요청이 들어올 때 이전에 인증된 사용자의 정보를 복원
            - **UsernamePasswordAuthenticationFilter**
                - 폼 기반 로그인 처리
                - 사용자가 제출 한 id와pwd를 확인하여 인증시도
            - **AnonymousAuthenticationFilter**
                - 이전 필터에서 인증되지 않은 요청에 대해 익명 사용자 인증 제공
            - **ExceptionTranslationFilter**
                - Spring Security 예외를 HTTP응답으로 반환
                - 인증 실패 시 로그인 페이지로 리다이렉트, 또는 인가 실패시 오류 **403** 반환
                    - **여기서 403 오류란?**
                        - 웹 서버가 사용자의 요청을 이해하지만, 해당 요청을 수행할 권한이 없다는 것을 나타내는 HTTP 상태 코드
                - **FilterSecurityInterceptor**
                    - 접근 제어 결정을 내리는 마지막 필터
                    - 현재 인증된 사용자가 요청한 리소스에 접근할 권한이 있는지 확인
    
    Filter Chain의 동작 방식
    
    1. 클라이언트로부터 요청이 들어오면, 요청은 Filter Chain의 첫 번째 필터부터 순차적으로 통과
    2. 각 필터는 요청을 검사하고 필요한 작업을 수행
    3. 필터는 요청을 다음 필터로 전달하거나, 특정 조건에 따라 요청 처리를 중단
    4. 모든 필터를 통과한 요청만이 실제 애플리케이션 로직에 도달
    
    - **UserDetailsService**
        - 사용자 정보를 불러오고 검증하는 서비스
        - 이 서비스는 데이터베이스 또는 다른 저장소에서 사용자 정보를 가져오고, 이를 **`UserDetails`** 객체로 반환
            - **`UserDetails`** 객체: 사용자의 아이디, 비밀번호, 권한(Role) 등 다양한 정보를 포함
    
    - **PasswordEncoder**
        - 비밀번호 암호화 및 검증 담당
        - `BCryptPasswordEncoder`를 많이 사용
    
    **Spring Security를 사용하는 이유?**
    
    - 로그인 / 회원가입 기능이 필요할 때
    - REST API에 토큰 기반 인증(JWT)을 붙일 때
    - 관리자 페이지처럼 권한이 필요한 리소스를 보호할 때

- **인증(Authentication)과 인가(Authorization)**
    
    
    | 구분 | 인증 (Authentication) | 인가 (Authorization) |
    | --- | --- | --- |
    | **의미하는 바** | "당신이 누구인지 증명하세요"라고 묻는 과정 |  "이 리소스에 접근할 권한이 있나요?"를 확인하는 과정 |
    | **목적** | 사용자가 주장하는 신원이 진짜인지 확인하는 것 | 인증된 사용자가 어떤 리소스에 접근 가능한지 확인 |
    | **언제 실행?** | 먼저 수행됨 (로그인 시) | 인증 후에 수행됨 |
    | **기술 예시** | 아이디/비밀번호, 지문, OTP, 소셜 로그인 등 | ROLE 기반 권한 체크 (`hasRole`, `hasAuthority`) |
    | **Spring Security 예** | 로그인 처리 (`formLogin`, `JWT 로그인`) | URL 접근 제한 (`.requestMatchers().hasRole()`) |
    - **인증**:
        - UMC PM데이에 가서 "저 정렬이에요!" 하면서 학생증 보여줌.
        - 루카스 회장님이 "아~ 맞네, 원렬이 맞군요!" → **인증**
    - **인가**:
        - “정렬씨는 VIP 등급이니까 제일 어울리는 저기 맨 구석 외진 곳만 좌석 이용 가능합니다”
        - 일반 맴버는 못 가는 곳을 갈 수 있게 해주는 권한 체크 → **인가**
        
    - **인증 단계**
        - 로그인 form, OAuth, JWT 등을 통해 사용자 인증 시도
        - `AuthenticationManager` → `UserDetailsService` → `UserDetails`
    - **인가 단계**
        - 인증 성공한 사용자의 권한 확인
        - `SecurityFilterChain` 내 `authorizeHttpRequests`로 URL 별 접근 제어
    
    ---
    
    **인증의 흐름**
    
    1. 사용자 로그인 요청
        1. 사용자가 로그인폼에 credentials입력 후 제출
    2. AuthenticationFilter
        1. `UsernamePasswordAuthenticationFilter` 가 요청을 가`로챔`
        2. `Authentication` 객체 생성
    3. AUthenticationManager
        1. `AuthenticationManager`는 적절한 `AuthenticationProvier`를 선택하여 인증을 위임
    4. AuthenticationProvider
        1. 선택된 `AuthenticationProvider`는 `UserDetailsService`를 사용하여 사용자 정보 `Load`
    5. UderDetailsService
        1. 데이터 베이스나 다른 저장소에서 사용자 정보 조회
    6. SecurityContext
        1. 인증 성공시, `Authentication` 객체가 `SecurityContext`에 저장됨
    
    **인가의 흐름**
    
    1. 리소스 접근 요청
        1. 인증된 사용자가 보호된 리소스에 접근 시도
    2. FilterSecurityInterceptor
        1. `FilterSecurityInterceptor`가 요청을 가로채고 권한 검사 시행
    3. AccessDecisionManager
        1. `AccessDecisionManager`는 현재 사용자의 권한과 요청된 리소스의 필요 권한 비교
    4. 권한 확인
        1. `SecurityContext`에서 현재 인증된 사용자의 권한 정보 조회
    5. 접근 결정
        1. 사용자의 권한이 충분하면 리소스 접근 허용
        2. 권한이 부족하면 `AccesDeniedException`이 발생하고 접근 거부
    
- **세션과 토큰**
    
    
    | 구분 | **세션(Session)** | **토큰(Token)** (ex. JWT) |
    | --- | --- | --- |
    | **저장 위치** | 서버 측 메모리 또는 DB (서버가 상태를 기억함 = Stateful) | 클라이언트가 직접 토큰을 저장하고 서버는 상태를 기억하지 않음 = Stateless |
    | **확인 방식** | 서버가 사용자 ID와 매칭된 세션 ID를 내부에서 관리 | 서버는 클라이언트가 보낸 토큰의 서명(Signature)을 검증함 |
    | **확장성** | 세션이 많아질수록 서버에 부하 (분산 서버에서는 세션 동기화가 필요) | 서버 확장에 유리, 토큰만 검증하면 되므로 서버 부하 적음 |
    | **보안 측면** | 세션 탈취 공격에 취약 (세션 ID 노출 시 위험) | 토큰 자체가 모든 정보를 담고 있어 탈취되면 곧바로 위험 |
    | **사용 예시** | 전통적인 웹 로그인, 관리자 페이지 등 | 모바일 앱, SPA(싱글 페이지 앱), API 서버 인증 등 |
- **액세스 토큰(Access Token)과 리프레시 토큰(Refresh Token)**
    
    
    | 항목 | 내용 |
    | --- | --- |
    | **정의** | 사용자가 로그인 후 서버로부터 발급받는 **인증용 토큰**. 서버는 이 토큰을 통해 요청 사용자를 인증함. |
    | **역할** | 사용자가 API 요청을 할 때, 이 토큰을 `Authorization` 헤더에 실어 보냄. |
    | **유효기간** | 보안 상 일반적으로 **짧은 시간 (예: 10분~30분)**으로 설정 |
    | **특징** | 노출 시 즉시 위험. 따라서 만료 시간을 짧게 설정하는 것이 보안상 유리함. |
    | **사용 방식** | API 요청 시 `Authorization: Bearer {AccessToken}` |

## 📢 학습 후기

<aside>
💡 이번 주차 워크북을 해결해보면서 어땠는지 회고해봅시다.

- Spring Security의 로그인 과정에 대해 완전히 이해했나요?
- 혹시 이해가 안 되는 부분이 있었나요?
- 이번 실습에서 어려웠던 부분은 무엇이었나요?
</aside>

## ⚠️ 스터디 진행 방법

1. 스터디를 진행하기 전, 워크북 내용들을 모두 채우고 스터디에서는 서로 모르는 내용들을 공유해주세요.
2. 미션은 워크북 내용들을 모두 완료하고 나서 스터디 전/후로 진행해보세요.
3. 다음주 스터디를 진행하기 전, 지난주 미션을 서로 공유해서 상호 피드백을 진행하시면 됩니다.

## 🔥 미션

<aside>
📍 **주의 사항**

결과물만 올리면 안되고, 중간 과정 또한 기록을 남겨주셔야 합니다.
(DB 연결, 테이블 생성 등)

**결과물과 중간 과정 모두 기록하여 제출**하라는 뜻입니다.

</aside>

### 필수 미션

<aside>

**⚠️ 모든 미션 과정은 깃허브에 업로드해주세요.**

</aside>

1. **실습 1: Spring Security를 활용한 로그인 및 회원가입 구현 = Session 방식**
    - 회원가입, 로그인, 로그아웃 기능을 구현하고 **DB에 저장**되는 과정을 캡처하고 설명하세요.
    - 
    
    ## **Spring Security 기반 회원가입 및 로그인 과정 설명 (Session 방식)**
    
    ### 1. 회원가입 (Sign-Up)
    
    사용자가 브라우저에서 이름, 이메일, 비밀번호, 성별 등 정보를 입력하고 "회원가입" 버튼을 누르면, 해당 정보는 서버로 전송된다. 이 과정은 HTML 폼(form)을 통해 POST 방식으로 전달되며, 서버는 이 요청을 컨트롤러에서 받아 DTO(데이터 전송 객체)에 자동으로 매핑한다.
    
    서버는 전달받은 회원 정보를 검증한 뒤, 다음과 같은 순서로 처리한다:
    
    - 사용자가 입력한 비밀번호는 보안을 위해 평문으로 저장되지 않고, BCrypt와 같은 암호화 알고리즘을 통해 암호화된다.
    - 이후 DB에 저장할 수 있는 형태의 사용자 객체로 변환된 뒤, 데이터베이스에 저장된다.
    - 이 과정은 Spring의 ORM 프레임워크인 JPA를 통해 자동으로 SQL 쿼리가 생성되며, 최종적으로 사용자 정보가 DB에 저장된다.
    
    즉, 사용자가 회원가입을 완료하면 서버는 해당 정보를 안전하게 DB에 저장하며, 이후 로그인을 위한 준비가 완료된 것이다.
    
    ---
    
    ### 2. 로그인 (Sign-In)
    
    로그인 과정에서는 사용자가 이메일과 비밀번호를 입력한다. 이 요청 역시 서버의 컨트롤러가 받아서 처리하게 되며, 다음 절차로 진행된다:
    
    - 서버는 DB에서 해당 이메일을 가진 사용자가 존재하는지 확인한다.
    - 존재할 경우, 사용자가 입력한 비밀번호와 DB에 저장된 암호화된 비밀번호를 비교하여 일치 여부를 판단한다.
    - 비밀번호가 일치하면 Spring Security가 내부적으로 사용자 정보를 세션(Session)에 저장한다. 이 세션은 이후 인증된 사용자라는 증거가 되어, 보호된 페이지나 기능을 이용할 수 있게 한다.
    
    ---
    
    ### 3. DB에 저장되는 흐름 (회원가입 기준)
    
    회원가입 버튼 클릭부터 DB에 저장되기까지의 내부적인 흐름은 다음과 같다:
    
    > 사용자 입력 → 컨트롤러 처리 → 서비스 로직 → 암호화 및 연관 데이터 처리 → JPA save 호출 → DB 저장
    > 
    
    이러한 절차를 통해 사용자의 정보가 안전하게 데이터베이스에 영속되며, JPA는 복잡한 SQL 작성 없이도 객체를 기반으로 데이터를 저장하고 조회할 수 있게 해준다.
    
    ---
    
    ### 4. 요약
    
    - Spring Security는 로그인 성공 시 사용자 정보를 세션에 저장해 인증 상태를 유지한다.
    - 회원가입 시 서버는 전달받은 데이터를 검증하고, 비밀번호 암호화 후 DB에 저장한다.
    - 모든 저장 로직은 Service 계층에서 처리되며, JPA가 SQL을 자동 생성해 DB에 반영한다.
    - 이러한 구조는 보안과 유지보수 측면 모두에서 안정적인 설계를 가능하게 해준다.
    
    ![image.png](image%2033.png)
    
    ![image.png](image%2034.png)
    
    ![image.png](image%2035.png)
    
    ![image.png](image%2036.png)
    
2. **실습 2: Spring Security를 활용한 로그인 및 회원가입 구현 = JWT 방식**
    - 회원가입, 로그인을 구현하고 **Swagger에서 테스트 및 DB에 저장**되는 과정을 캡처하고 설명하세요.

## **실습 2: Spring Security + JWT 방식 로그인/회원가입 구현 설명**

---

### **JWT 방식 개요**

JWT(Json Web Token)는 세션 방식과 달리 서버에 상태 정보를 저장하지 않고,

로그인 시 발급된 토큰을 클라이언트가 직접 들고 다니며 인증하는 **Stateless 인증 방식**이다.

- 서버는 로그인 성공 시 JWT를 발급한다.
- 클라이언트는 이 토큰을 HTTP Header에 담아 요청을 보낸다.
- 서버는 매 요청마다 토큰을 검증하고, 유효할 경우 사용자 정보를 추출해 인가한다.1. 회원가입 과정 (Sign-Up)

---

### 절차 요약

Swagger에서 JSON 입력 → 서버 Controller 수신 → Service에서 DB 저장  응답Swagger 테스트 예시

```json
POST /members/
{
  "name": "정원렬",
  "gender": 1,
  "birthYear": 2002,
  "birthMonth": 9,
  "birthDay": 30,
  "address": "서울시 마포구",
  "specAddress": "101동 302호",
  "preferCategory": [1, 2],
  "email": "test@naver.com",
  "password": "1234",
  "role": "ADMIN"
}
```

### 처리 흐름 설명

1. 사용자가 Swagger를 통해 JSON 형태로 회원 정보를 입력하고 요청을 보낸다.
2. 서버는 DTO 객체로 해당 요청을 수신하고, 내부적으로 유효성 검증을 수행한다.
3. 비밀번호는 `PasswordEncoder`를 통해 암호화되며, 사용자가 선택한 선호 카테고리 등도 함께 처리된다.
4. 모든 처리가 완료된 후, 사용자 정보가 DB에 저장된다.

> 🔍 DB에서는 member 테이블에 사용자의 정보가 INSERT 되고, 관련된 선호 카테고리는 member_prefer 테이블에 매핑되어 저장된다.
> 

---

## 2. 로그인 과정 (Sign-In)절차 요약

 Swagger에서 로그인 정보 입력 →  서버에서 사용자 검증 → JWT 토큰 발급 → 응답

### Swagger 로그인 요청 예시

```json
POST /members/login
{
  "email": "test@naver.com",
  "password": "1234"
}
```

### 처리 흐름 설명

1. 사용자가 이메일과 비밀번호를 Swagger에서 입력해 로그인 요청을 보낸다.
2. 서버는 해당 이메일로 등록된 사용자가 있는지 확인한 후,
3. 비밀번호가 일치하면 JWT 토큰을 발급하여 응답으로 돌려준다.
4. 발급된 토큰은 이후 모든 API 요청 시 `Authorization: Bearer {토큰}` 형식으로 포함시켜야 한다.

---

## 4. 결론 요약

| 구분 | 내용 |
| --- | --- |
| 인증 방식 | JWT (토큰 기반 무상태 Stateless 인증) |
| 회원가입 흐름 | Swagger → Controller → Service → JPA → DB 저장 |
| 로그인 흐름 | Swagger → 이메일/비밀번호 검증 → JWT 발급 → 클라이언트 반환 |
| DB 저장 확인 | Workbench 등으로 `member` 테이블 직접 조회 |

![image.png](image%2037.png)

![image.png](image%2038.png)

![image.png](image%2039.png)

![image.png](image%2040.png)

![image.png](image%2041.png)

![image.png](image%2042.png)

- 아래는 실습 참고 코드입니다.
    
    [GitHub - chock-cho/UMC-8th-spring-workbook at feature-week10-workbook-2](https://github.com/chock-cho/UMC-8th-spring-workbook/tree/feature-week10-workbook-2)
    

### 시니어 미션

- **카카오, 구글 또는 네이버 소셜 로그인 추가 구현**
    - 결과물과 중간 과정을 기록하여 제출하세요.
- **리프레시 토큰 방식 로그인 추가 구현**
    - 결과물과 중간 과정, 액세스 토큰만 이용했을 때의 인증방식과의 장단점을 비교해서 제출하세요.

## 💪 미션 기록

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

- **미션 기록**

> **GitHub 저장소 주소**
> 
> 
> https://github.com/…
> 

## ⚡ 트러블 슈팅

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널**에 질문해보세요!

</aside>

- ⚡이슈 작성 예시 (이슈가 생기면 아래를 복사해서 No. 1, No. 2, No. 3, … 으로 작성해서 트러블 슈팅을 꼭 해보세요!)
    
    **`이슈`**
    
    👉 앱 실행 중에 노래 다음 버튼을 누르니까 앱이 종료되었다.
    
    **`문제`**
    
    👉 노래클래스의 데이터리스트의 Size를 넘어서 NullPointException이 발생하여 앱이 종료된 것이었다. 
    
    **`해결`**
    
    👉  노래 다음 버튼을 눌렀을 때 데이터리스트의 Size를 검사해 Size보다 넘어가려고 하면 다음으로 넘어가는 메서드를 실행시키지 않고, 첫 노래로 돌아가게끔 해결
    
    **`참고 레퍼런스`**
    
    - 링크
- ⚡이슈 No. 1
    
    **`이슈`**
    
    👉 [트러블이 생긴 상태 작성]
    
    **`문제`**
    
    👉 [어떤 이유로 해당 이슈가 일어났는지 작성]
    
    **`해결`**
    
    👉  [해결 방법 작성]
    
    **`참고 레퍼런스`**
    
    - [문제 해결 시 참고한 링크]

Copyright © 2025 신수정(베뉴) All rights reserved.

Copyright © 2024 김준석(벡스) All rights reserved.

`System.*out*.println`