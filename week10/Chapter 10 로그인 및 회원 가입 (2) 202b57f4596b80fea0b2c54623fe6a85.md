

## 🎯 핵심 키워드

<aside>
💡 주요 내용들을 정리하고, 여러분만의 생각을 통해 정리해보세요!

- 레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 괜찮습니다.
- 조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**
</aside>

- **Spring Security**
    
    **Spring Security**
    
    Spring Security는 인증, 권한 관리 그리고 데이터 보호 기능을 포함하여 웹 개발 과정에서 필수적인 사용자 관리 기능을 구현하는데 도움을 주는 Spring의 강력한 프레임워크이다.
    
    **Spring Security 아키텍처**
    
    ![image.png](image%2033.png)
    
    동작 과정
    
    1. 사용자의 요청이 서버로 들어온다.
    
    2. Authotication Filter가 요청을 가로채고 Authotication Manger로 요청을 위임한다.
    
    3. Authotication Manager는 등록된 Authotication Provider를 조회하며 인증을 요구한다.
    
    4. Authotication Provider가 실제 데이터를 조회하여 UserDetails 결과를 반환한다.
    
    5. 결과는 SecurityContextHolder에 저장이 되어 저장된 유저정보를 Spring Controller에서 사용할 수 있게 된다.
    
    **내부구조**
    
    ![image.png](image%2034.png)
    
    동작과정
    
    1. 사용자가 자격 증명 정보를 제출하면, AbstractAuthenticationProcessingFilter가 Authentication 객체를 생성한다.
    
    2. Authentication 객체가 AuthenticationManager에게 전달된다.
    
    3. 인증에 실패하면, 로그인 된 유저정보가 저장된 SecurityContextHolder의 값이 지워지고 RememberMeService.joinFail()이 실행된다. 그리고 AuthenticationFailureHandler가 실행된다.
    
    4. 인증에 성공하면, SessionAuthenticationStrategy가 새로운 로그인이 되었음을 알리고, Authentication 이 SecurityContextHolder에 저장된다. 이후에 SecurityContextPersistenceFilter가 SecurityContext를 HttpSession에 저장하면서 로그인 세션 정보가 저장된다.
    
    그 뒤로 RememberMeServices.loginSuccess()가 실행된다. ApplicationEventPublisher가 InteractiveAuthenticationSuccessEvent를 발생시키고 AuthenticationSuccessHandler 가 실행된다.
    
- **인증(Authentication)과 인가(Authorization)**
    
    **Spring Security 인증 흐름**
    
    ![image.png](image%2035.png)
    
    1. 어플리케이션으로 http요청이 들어오면 AuthenticationFilter가 이 요청을 기반으로 인증되지 않은 UsernamePasswordAuthenticationToken(Authentication객체)을 만든다(isAuthenticated = false).
    2. AuthenticationFilter에서 AuthenticationManager를 호출하여 Authentication객체에 대한 인증을 요청한다.
    3. AuthenticationManager는 전달받은 Authentication객체를 인증할 수 있는 Provider를 찾아 인증을 요청한다.
    4. 선택된 AuthenticationProvider는 Authentication객체에서 principal(username)을 추출하고 UserDetailsService에게 해당하는 사용자를 찾아달라고 요청한다.
    5. UserDetailsService는 전달받은 principal(username)과 일치하는 사용자를 DB에서 찾고, UserDetails객체로 포장하여 AuthenticationProvider에게 돌려준다.
    6. AuthenticationProvider는 UserDetails를 받아 인증을 수행하고, 인증에 성공하면 새로운 Authentication객체를 생성하여 AuthenticationManager에게 돌려준다(isAuthenticated = true).
    7. AuthenticationManager는 인증된 Authentication객체를 가공하여 AuthenticationFilter로 돌려준다.
    8. AuthenticationFilter는 인증된 Authentication객체를 SecurityContext로 감싸고 SecurityContextHolder에 저장한다.

**Spring Security 인가 흐름**

![image.png](image%2036.png)

1. 요청이 FilterSecuritiyInterceptor에 도달하면 FilterSecurityInterceptor는 AccessDecisionManager에게 인가 처리를 위임한다.
2. AccessDecisionManager는 decide(authentication, filterInvocation, configAttributes) 를 통해 Authentication, FilterInvocation, ConfigAttributes를 AccessDecisionVoter들에게 넘겨주고 접근에 대한 판단을 요청한다.
3. 각 Voter들은 인가 여부를 판단하고 그 결과를 반환한다.
4. AccessDecisionManager의 구현체에 따라 인가 여부를 판단한다.
    - 인가가 허용되면 FilterSecurityInterceptor의 흐름으로 돌아간다.
    - 인가가 거부되면 AccessDeniedException 예외를 발생시키며 ExceptionTranslationFilter로 예외를 던진다.
- **세션과 토큰**
    
    세션은 클라이언트의 Request에 자동으로 서버에 전달되는 쿠키에 `세션 Id`가 담겨 전달되는 방식으로 사용되지만 브라우저에 저장되는 쿠키와는 달리 서버에서 관리된다. 인증된 사용자의 정보를 서버의 세션 저장소에서 관리하고 클라이언트에겐 해당 사용자를 구분할`세션 Id`만 전달하는 것이다.
    
    세션의 특징
    
    - 인증된 사용자의 정보를 서버의 세션 저장소에서 관리한다.
    - 서버로부터 생성된 세션ID는 고유한 값을 가지며, 클라이언트의 쿠키에 저장되어 있다가 resquest시 쿠키가 전송되는 시점에 함께 전송되며 인증된 사용자임을 증명하는 수단으로 사용된다.
    - 세션ID만 클라이언트 쪽에서 사용하므로 상대적으로 적은 네트워크 트래픽을 사용한다.
    - 서버에서 세션 정보를 관리하므로 보안성 측면에서 조금 더 유리하다.
    - 서버의 확장성 면에서는 세션 불일치 문제가 발생할 가능성이 높다.
    
    **토큰**
    
    비용을 지불하면 받을 수 있는 토큰은 이미 비용을 지불했기 때문에 사용에 대한 권한을 가진 것이다.
    
    토큰은 사용자의 자격 증명 정보가 포함되어 있다.
    
    서버에 세션 정보(사용자 증명 정보)를 저장해놓고, 클라이언트의 요청을 할 때마다 `세션 ID`를 서버에 보내 사용자의 상태를 유지하는 세션 기반 자격 증명 방식과는 달리 토큰 기반 자격 증명 방식은 클라이언트의 요청 시마다 사용자의 자격 증명 정보를 보내는 것이다.
    
    토큰의 징
    
    - 토큰에 인증된 사용자 정보를 저장하기 때문에 서버에서 별도의 관리를 하지 않는다.
    - 생성된 토큰은 클라이언트의 Request를 보낼 때, header에 포함되어 사용자를 증명하는 수단으로 사용된다.
    - Request마다 사용자 정보가 저장된 토큰을 보내야하므로 세션에 비해 더 많은 네트워크 트래픽을 사용한다.
    - 서버에서 토큰을 관리하지 않기 때문에 보안성 측면에서 조금 더 불리하다.
    - 사용자의 인증된 정보를 서버에서 관리하지 않기 때문에 서버의 확상성 면에서 유리하고 세션 불일치와 같은 문제가 발생하지 않는다.
    - 기본적으로 토큰이 만료되기 전까지는 토큰을 무효화 시킬 수 없다.
    - CSR 방식의 애플리케이션에 적합한 방식이다.
- **액세스 토큰(Access Token)과 리프레시 토큰(Refresh Token)**
    
    토큰은 서버의 리소스에 접근할 때 사용자를 인증할 수 있는 Access Token 으로 동작한다. 하지만 JWT 는 Stateless 하기 때문에 서버는 토큰을 가진 클라이언트가 진짜 본인이 맞는지 알 수 없다.
    
    만약 이를 해결하기 위해 Access Token 의 유효 기간을 짧게 설정한다면 로그인을 자주 해야 하기 때문에 불편하다. 반대로 유효 기간을 길게 할 경우, 서버는 한 번 발급한 토큰에 대한 제어권이 없기 때문에 보안에 문제가 발생한다.
    
    이런 문제를 해결하기 위해 등장한 것이 바로 Refresh Token 이다.
    
    Access Token 의 보안을 강화하기 위해 토큰의 유효 시간을 짧게 설정하여 자주 재발급하되, 사용자가 자주 로그인 해야하는 불편함을 없애기 위해 사용한다. 즉, 클라이언트가 가진 Access Token 이 만료 되었을 때 Access Token 을 새로 발급받기 위해 사용한다.
    

## 📢 학습 후기

<aside>
💡 이번 주차 워크북을 해결해보면서 어땠는지 회고해봅시다.

- Spring Security의 로그인 과정에 대해 완전히 이해했나요?
- 혹시 이해가 안 되는 부분이 있었나요?
- 이번 실습에서 어려웠던 부분은 무엇이었나요?
</aside>

## ⚠️ 스터디 진행 방법

1. 스터디를 진행하기 전, 워크북 내용들을 모두 채우고 스터디에서는 서로 모르는 내용들을 공유해주세요.
2. 미션은 워크북 내용들을 모두 완료하고 나서 스터디 전/후로 진행해보세요.
3. 다음주 스터디를 진행하기 전, 지난주 미션을 서로 공유해서 상호 피드백을 진행하시면 됩니다.

## 🔥 미션

<aside>
📍 **주의 사항**

결과물만 올리면 안되고, 중간 과정 또한 기록을 남겨주셔야 합니다.
(DB 연결, 테이블 생성 등)

**결과물과 중간 과정 모두 기록하여 제출**하라는 뜻입니다.

</aside>

### 필수 미션

<aside>

**⚠️ 모든 미션 과정은 깃허브에 업로드해주세요.**

</aside>

1. **실습 1: Spring Security를 활용한 로그인 및 회원가입 구현 = Session 방식**
    - 회원가입, 로그인, 로그아웃 기능을 구현하고 **DB에 저장**되는 과정을 캡처하고 설명하세요.
2. **실습 2: Spring Security를 활용한 로그인 및 회원가입 구현 = JWT 방식**
    - 회원가입, 로그인을 구현하고 **Swagger에서 테스트 및 DB에 저장**되는 과정을 캡처하고 설명하세요.

- 아래는 실습 참고 코드입니다.
    
    [GitHub - chock-cho/UMC-8th-spring-workbook at feature-week10-workbook-2](https://github.com/chock-cho/UMC-8th-spring-workbook/tree/feature-week10-workbook-2)
    

### 시니어 미션

- **카카오, 구글 또는 네이버 소셜 로그인 추가 구현**
    - 결과물과 중간 과정을 기록하여 제출하세요.
- **리프레시 토큰 방식 로그인 추가 구현**
    - 결과물과 중간 과정, 액세스 토큰만 이용했을 때의 인증방식과의 장단점을 비교해서 제출하세요.

## 💪 미션 기록

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

- **미션 기록**

> **GitHub 저장소 주소**
> 
> 
> https://github.com/…
> 

## ⚡ 트러블 슈팅

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널**에 질문해보세요!

</aside>

- ⚡이슈 작성 예시 (이슈가 생기면 아래를 복사해서 No. 1, No. 2, No. 3, … 으로 작성해서 트러블 슈팅을 꼭 해보세요!)
    
    **`이슈`**
    
    👉 앱 실행 중에 노래 다음 버튼을 누르니까 앱이 종료되었다.
    
    **`문제`**
    
    👉 노래클래스의 데이터리스트의 Size를 넘어서 NullPointException이 발생하여 앱이 종료된 것이었다. 
    
    **`해결`**
    
    👉  노래 다음 버튼을 눌렀을 때 데이터리스트의 Size를 검사해 Size보다 넘어가려고 하면 다음으로 넘어가는 메서드를 실행시키지 않고, 첫 노래로 돌아가게끔 해결
    
    **`참고 레퍼런스`**
    
    - 링크
- ⚡이슈 No. 1
    
    **`이슈`**
    
    👉 [트러블이 생긴 상태 작성]
    
    @Setter를 빼먹었다.
    
    **`문제`**
    
    👉 [어떤 이유로 해당 이슈가 일어났는지 작성]
    
    **`해결`**
    
    👉  [해결 방법 작성]
    
    SPring에서 @ModelAttribute의 동작과정을 찾아보고 나서 @Setter가 필요함을 알아냈다.
    
    **`참고 레퍼런스`**
    
    - [문제 해결 시 참고한 링크]

Copyright © 2025 신수정(베뉴) All rights reserved.

Copyright © 2024 김준석(벡스) All rights reserved.