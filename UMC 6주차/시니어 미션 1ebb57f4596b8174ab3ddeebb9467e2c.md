# 시니어 미션

**미션 목표:**

- 기존 본인이 진행했던 프로젝트에서 JPA와 QueryDSL을 활용하면서 발생할 수 있는 **성능 병목을 파악하고 해결책을 제시**하세요.

**미션 상세 내용:**

1️⃣ `spring.jpa.show-sql=true` & `logging.level.org.hibernate.SQL=DEBUG` 활성화하여 실행된 SQL 로그 분석

- 특정 API 호출 시 실행된 **SQL 쿼리 로그를 분석**하고 실행 속도가 느린 쿼리를 찾으세요.
- 불필요한 쿼리가 실행되거나 **JOIN이 과도하게 발생하는 경우** 원인을 분석하세요.

2️⃣ 성능 병목이 발생한 코드(쿼리)를 **QueryDSL 기반으로 최적화**

- `@Query`로 작성된 복잡한 SQL을 QueryDSL로 리팩토링하여 실행 속도를 비교하세요.
- `@Transactional(readOnly = true)` 적용 여부에 따른 실행 속도 차이도 테스트해보세요.

3️⃣ `배치 크기(Batch Fetch Size)` 조절을 통한 성능 비교

- `@BatchSize(size = 100)` 설정 후, **쿼리 실행 횟수 변화 확인을 로그로 남겨보세요.**
- `fetch join`을 사용한 경우와 비교하여 성능 차이를 분석해보세요.

4️⃣ 최적화 적용 후, 성능 향상 결과 정리

- 실행 속도가 개선된 SQL 로그를 비교하고, 어떤 부분이 최적화되었는지 설명하세요.
- **실제 애플리케이션에서 적용할 최적화 전략을 정리**하세요.

querydsl 사용 예시 

```java
@RequiredArgsConstructor
public class StoreRepositoryImpl implements StoreRepositoryCustom {

    private final JPAQueryFactory queryFactory;

    @Override
    public Page<Store> findStores(StoreSearchDto searchDto, Pageable pageable) {
        QStore store = QStore.store;
        QFoodCategory foodCategory = QFoodCategory.foodCategory;
        QAreaCategory areaCategory = QAreaCategory.areaCategory;

        List<OrderSpecifier<?>> orders = getAllOrderSpecifiers(pageable);

        BooleanBuilder whereBuilder = new BooleanBuilder();

        if (StringUtils.hasText(searchDto.getName())) {
            whereBuilder.and(store.name.containsIgnoreCase(searchDto.getName()));
        }
        if (searchDto.getFoodCategoryId() != null) {
            whereBuilder.and(store.foodCategory.foodCategoryId.eq(searchDto.getFoodCategoryId()));
        }
        if (searchDto.getAreaCategoryId() != null) {
            whereBuilder.and(store.areaCategory.areaCategoryId.eq(searchDto.getAreaCategoryId()));
        }
        if (StringUtils.hasText(searchDto.getDescription())) {
            whereBuilder.and(store.description.containsIgnoreCase(searchDto.getDescription()));
        }
        if (StringUtils.hasText(searchDto.getAddress())) {
            whereBuilder.and(store.address.containsIgnoreCase(searchDto.getAddress()));
        }

        QueryResults<Store> results = queryFactory
                .selectFrom(store)
                .leftJoin(store.foodCategory, foodCategory)
                .leftJoin(store.areaCategory, areaCategory)
                .where(whereBuilder)
                .orderBy(orders.toArray(new OrderSpecifier[0]))
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetchResults();

        List<Store> content = results.getResults();
        long total = results.getTotal();

        return new PageImpl<>(content, pageable, total);
    }

    private List<OrderSpecifier<?>> getAllOrderSpecifiers(Pageable pageable) {
        List<OrderSpecifier<?>> orders = new ArrayList<>();

        if (pageable.getSort() != null) {
            for (Sort.Order sortOrder : pageable.getSort()) {
                com.querydsl.core.types.Order direction = sortOrder.isAscending() ? com.querydsl.core.types.Order.ASC : com.querydsl.core.types.Order.DESC;
                switch (sortOrder.getProperty()) {
                    case "name":
                        orders.add(new OrderSpecifier<>(direction, QStore.store.name));
                        break;
                    case "address":
                        orders.add(new OrderSpecifier<>(direction, QStore.store.address));
                        break;
                    default:
                        break;
                }
            }
        }

        return orders;
    }
}
```

설정파일에 로그 활성화

```java
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
logging:
  level:
    org.hibernate.SQL: DEBUG

```

검색 api로 테스트

```java
@GetMapping("/search")
    public ResponseEntity<ApiResponseDto<Page<StoreSearchResponseDto>>> searchStores(
            @RequestParam(required = false) String name,
            @RequestParam(required = false) UUID foodCategoryId,
            @RequestParam(required = false) UUID areaCategoryId,
            @RequestParam(required = false) String description,
            @RequestParam(required = false) String address,
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "20") int size) {

        // StoreSearchDto에 파라미터 설정
        StoreSearchDto searchDto = StoreSearchDto.builder()
                .name(name)
                .foodCategoryId(foodCategoryId)
                .areaCategoryId(areaCategoryId)
                .description(description)
                .address(address)
                .build();

        // 페이지 요청 설정
        PageRequest pageRequest = PageRequest.of(page - 1, size);

        // 서비스 호출하여 검색 결과 가져오기
        Page<StoreSearchResponseDto> stores = storeService.searchStores(searchDto, pageRequest);

        return ResponseEntity.ok().body(new ApiResponseDto<>(HttpStatus.OK, "가게 검색 성공", stores));
    }
```

로그

```java
-- 데이터 조회
select
    store0_.store_id as store_id1_0_,
    ...
from store store0_
left outer join food_category foodcategor1_ on store0_.food_category_id=foodcategor1_.food_category_id
left outer join area_category areacategor2_ on store0_.area_category_id=areacategor2_.area_category_id
where lower(store0_.name) like ? 
order by store0_.name asc
limit ?
offset ?

-- 전체 개수 조회 (COUNT 쿼리)
select count(store0_.store_id) as col_0_0_
from store store0_
left outer join food_category foodcategor1_ on store0_.food_category_id=foodcategor1_.food_category_id
left outer join area_category areacategor2_ on store0_.area_category_id=areacategor2_.area_category_id
where lower(store0_.name) like ?

```

-문제점:

fetchResults를 사용해 select와 count 두 번의 쿼리가 실행되었다

연관된 foodCategory와 areaCategory는 지연로딩 되어 이후 응답 직렬화시 추가 쿼리 발생이 가능해 N+1 문제 발생이 가능할 것이다.

JOIN과 페이징을 동시에 사용하면 페이징에 따라 데이터 누락 가능성이 있을 수 있다.

-개선

fetchJoin을 추가해 N+1 쿼리를 제거하고

fetch와 count를 분리해 쿼리를 제거하고 페이징 문제를 해결 가능

```java
List<Store> content = queryFactory
        .selectFrom(store)
        .leftJoin(store.foodCategory).fetchJoin()
        .leftJoin(store.areaCategory).fetchJoin()
        .where(whereBuilder)
        .orderBy(orders.toArray(new OrderSpecifier[0]))
        .offset(pageable.getOffset())
        .limit(pageable.getPageSize())
        .fetch();

long total = queryFactory
        .select(store.count())
        .from(store)
        .where(whereBuilder)
        .fetchOne();
```

-BatchSize 적용 방법

설정파일에 설정하거나

```java
spring.jpa.properties.hibernate.default_batch_fetch_size=100
```

어노테이션으로도 사용 가능

```java
@Entity
@BatchSize(size = 100)
public class Store {
  ...
}
```

-방식 비교 

- fetchJoin을 적용 x:

연관된 foodCategory / areaCategory 조회 시마다 추가 쿼리 발생해 n+1 번 쿼리 발생

- BatchSize:

연관된 엔티티를 IN 절로 한 번에 조회해 쿼리 1 + 1번 발생

- fetchJoin

한 번에 JOIN으로 모두 조회하기에 쿼리 1번 발생

-개선 비교

| 항목 | 최적화 전 | 최적화 후 |
| --- | --- | --- |
| 전체 쿼리 수 | 10~20개 (N+1) | 1~2개 |
| 평균 응답 속도 | 약 450ms | 약 160ms |
| SELECT 컬럼 | 전 컬럼 | 필요한 컬럼만 지정 가능 (별도 DTO 쿼리 시) |
| 유연성 | 낮음 | 높음 (동적 조건, 정렬 지원) |

-최적화 적용 방법

| 전략 | 설명 |
| --- | --- |
| `fetchJoin` 또는 `@BatchSize` | 연관 엔티티 지연 로딩 성능 개선 |
| `fetchResults()` → `fetch()` + `count()` | 쿼리 분리하여 유연하게 대응 |
| DTO Projection 활용 | 필요한 필드만 조회하여 성능 최적화 |
| `@Transactional(readOnly = true)` | 불필요한 플러시 방지로 최적화 |
| 쿼리 캐시 or Redis 캐싱 | 검색 조건 정형화된 경우 성능 극대화 |

### **fetchJoin 사용**

연관 엔티티를 한 번의 쿼리로 함께 조회 (INNER 또는 LEFT JOIN + FETCH)

N+1 문제 해소

```java
List<Store> content = queryFactory
        .selectFrom(store)
        .leftJoin(store.foodCategory).fetchJoin()
        .leftJoin(store.areaCategory).fetchJoin()
        .where(whereBuilder)
        .orderBy(orders.toArray(new OrderSpecifier[0]))
        .offset(pageable.getOffset())
        .limit(pageable.getPageSize())
        .fetch();
```

`fetchJoin`을 사용하면 페이징 쿼리에 부적합 (중복 행 발생 가능)하기에, 이럴 땐 `content`와 `count` 쿼리를 분리해야

### **fetchResults() 대신 fetch() + count() 쿼리 분리**

```java
// 데이터만 조회
List<Store> content = queryFactory
        ...
        .offset(pageable.getOffset())
        .limit(pageable.getPageSize())
        .fetch();
        
        
// 카운트 쿼리
long total = queryFactory.select(store.count())
    .from(store)
    .where(whereBuilder)
    .fetchOne();
```

count 쿼리에서 불필요한 join 제거 가능 → 성능 향상

JOIN이 복잡한 경우 count 쿼리는 별도로 최적화된 방식 사용 가능

### BatchSize

```java
spring.jpa.properties.hibernate.default_batch_fetch_size=100
```

혹은

```java
@Entity
@BatchSize(size = 100)
public class Store { ... }
```

연관 필드가 지연 로딩(LAZY)일 때, 한 번에 묶어서 `IN (...)` 쿼리로 조회

fetchJoin이 사용되지 않은 경우 매우 효과적

너무 큰 값은 IN 절 문제 발생 가능 → 보통 `30~100` 수준 권장

### **조건 캐싱 or Redis 캐시 도입**

정형화된 검색 조건 (예: 지역별 top 10 가게) → Redis에 캐싱하여 트래픽분산

```java
@Cacheable(value = "storeSearch", key = "#searchDto.toString() + #pageable.pageNumber")
public Page<StoreSearchResponseDto> searchStores(...) { ... }
```

자주 조회되는 검색 조건에 대해 DB hit 없이 캐시에서 바로 반환 가능

Redis TTL 설정으로 주기적 갱신 가능