# 시니어 미션

![내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)](Untitled.png)

내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)

- [x]  미션 1(내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함))에서 정렬 기준을 1순위는 포인트로 2순위는 최신순으로 하여 Cursor기반 페이지네이션을 구현해보세요
    
    ```sql
    1. 
    SELECT 
        m.id AS mission_id, 
        s.name AS store_name, 
        r.name AS region_name, 
        mi.reward AS mission_reward, 
        mi.status AS mission_status, 
        mm.status AS member_mission_status, 
        mi.deadline, 
        mi.created_at 
    FROM member mem 
    JOIN member_mission mm ON mem.id = mm.member_id 
    JOIN mission mi ON mm.mission_id = mi.id 
    JOIN store s ON mi.store_id = s.id 
    JOIN region r ON s.region_id = r.id 
    WHERE 
        mem.id = :사용자_ID
        AND mm.status = 'progress'
        AND (
            (mi.reward < :마지막_미션_포인트) OR
            (mi.reward = :마지막_미션_포인트 AND mi.created_at < :마지막_생성일자) OR
            (mi.reward = :마지막_미션_포인트 AND mi.created_at = :마지막_생성일자 AND m.id < :마지막_미션_ID)
        )
    ORDER BY
        mi.reward DESC,
        mi.created_at DESC,
        m.id DESC
    LIMIT :페이지_크기;
    
    2.
    SELECT
        m.id AS mission_id,
        s.name AS store_name,
        r.name AS region_name,
        mi.reward AS mission_reward,
        mi.status AS mission_status,
        mm.status AS member_mission_status,
        mi.deadline,
        mi.created_at
    FROM member mem
    JOIN member_mission mm ON mem.id = mm.member_id
    JOIN mission mi ON mm.mission_id = mi.id
    JOIN store s ON mi.store_id = s.id
    JOIN region r ON s.region_id = r.id
    WHERE
        mem.id = :사용자_ID
        AND mm.status = 'completed'
        AND (
            (mi.reward < :마지막_미션_포인트) OR
            (mi.reward = :마지막_미션_포인트 AND mi.created_at < :마지막_생성일자) OR
            (mi.reward = :마지막_미션_포인트 AND mi.created_at = :마지막_생성일자 AND m.id < :마지막_미션_ID)
        )
    ORDER BY
        mi.reward DESC,
        mi.created_at DESC,
        m.id DESC
    LIMIT :페이지_크기;
    ```
    

- [x]  SQL Injection에 대해 조사하고 어떠할 때 일어나고 어떻게 막을 수 있는 지를 적어주세요
    - 내용들을 간단하게 정리하여 주세요
        
        ## ***SQL Injection*이란?**
        
        SQL Injection은 웹 애플리케이션에서 사용자 입력을 제대로 검증하지 않을 경우 발생하는 보안 취약점입니다. 공격자는 **SQL 쿼리에 악의적인 코드를 삽입하여 데이터베이스를 조작하거나 민감한 정보를 탈취**할 수 있습니다.
        
        ## **SQL Injection 발생 조건**
        
        **첫번째.** 사용자 입력이 직접 SQL 쿼리에 포함될 때.
        
        **두번째.** 입력값 검증 및 필터링이 제대로 이루어지지 않을 때.
        
        **세번째.** 동적 쿼리를 사용하면서 매개변수화된 쿼리를 사용하지 않을 때.
        
        - **예시**
        
        ```sql
        SELECT * FROM users WHERE username = 'admin' AND password = 'password' OR '1'='1';
        ```
        
        위와 같은 쿼리는 **`OR '1'='1'`** 조건이 항상 참이므로 인증을 우회할 수 있습니다.
        
        ## **SQL Injection 방지 방법**
        
        1. **매개변수화된 쿼리 사용**:
            - Prepared Statements 또는 Parameterized Queries를 통해 사용자 입력을 데이터로만 처리하여 실행 가능한 코드로 해석되지 않게 합니다.
            - **예시 (Java)**
            
            ```java
            String query = "SELECT * FROM users WHERE username = ? AND password = ?";
            PreparedStatement stmt = connection.prepareStatement(query);
            stmt.setString(1, username);
            stmt.setString(2, password);
            ResultSet rs = stmt.executeQuery();`
            ```
            
        2. **입력값 검증 및 필터링**:
            - 사용자 입력값을 철저히 검증하고, 허용된 데이터 타입 및 길이를 제한합니다.
            - 예를 들어, 숫자만 허용되는 필드에 문자열 입력을 차단.
        3. **특수 문자 이스케이프 처리**:
            - 입력값에 포함된 특수 문자를 이스케이프 처리하여 SQL 구문으로 해석되지 않도록 합니다.
        4. **최소 권한 원칙 적용**:
            - 데이터베이스 계정에 최소한의 권한만 부여하여 공격 성공 시 피해를 최소화합니다.
        5. **웹 애플리케이션 방화벽(WAF) 사용**:
            - WAF를 통해 SQL Injection 패턴을 탐지하고 차단합니다.
        6. **정기적인 보안 점검 및 업데이트**:
            - 애플리케이션 및 데이터베이스를 최신 상태로 유지하고 정기적인 보안 점검을 수행합니다

- [x]  다양한 JOIN 방법들에 대해 찾아보고, 각 방식에 대해 비교하여 간단히 정리해주세요.
    - 내용들을 간단하게 정리하여 주세요
        
        ## **JOIN 방식 비교**
        
        | **JOIN 유형** | **설명** | **결과 데이터** | **주요 사용 사례** |
        | --- | --- | --- | --- |
        | **INNER JOIN** | 두 테이블에서 조건에 맞는 공통 데이터를 조회. | 공통된 데이터만 반환 | 주문-고객 매칭 등 |
        | **LEFT JOIN** | 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 일치하는 데이터 조회. | 왼쪽 테이블의 모든 데이터 포함 | 고객 목록과 주문 내역 결합 등 |
        | **RIGHT JOIN** | 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 일치하는 데이터 조회. | 오른쪽 테이블의 모든 데이터 포함 | 제품 목록과 판매 기록 결합 등 |
        | **FULL OUTER JOIN** | 두 테이블의 모든 데이터를 조회하며 일치하지 않는 경우 NULL 반환. | 두 테이블의 전체 데이터 포함 | 프로젝트와 담당자 정보 결합 등 |
        | **CROSS JOIN** | 두 테이블의 모든 가능한 조합 생성 (카테시안 곱). | 모든 조합 반환 | 마케팅 캠페인 조합 생성 등 |
        | **SELF JOIN** | 동일한 테이블 간 데이터를 연결하여 계층적 관계 분석. | 자기 자신과 매칭된 데이터 반환 | 직원-매니저 관계 분석 등 |

정리된 글을 바탕으로 블로그를 작성하여 주세요