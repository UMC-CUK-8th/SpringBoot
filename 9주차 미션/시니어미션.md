# 시니어 미션

**미션 목표:**

- **Slice**와 **Page**의 구조적 차이와 적용 시점 파악하기
- **for**와 **stream**의 **성능, 가독성, 유지보수성**을 직접 비교

**미션 상세 내용:**

### 1️⃣ Page와 Slice가 각각 어떻게 출력값이 나오는 지 알아보기

- 기존 미션에 나왔던 pagination에서 Page와 Slice로 바꾸어 각각 출력값 비교
    - 다른 API를 하나 만들어도 됩니다.

### 2️⃣ Page, Slice 각각 적용 시 장단점 파악하기

- 찾아본 원리를 토대로 서로의 장단점 적어보기

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- 장단점을 토대로 언제 Page, Slice를 언제 적용하면 좋을 지 적기

### 1️⃣ for과 stream이 어떻게 작동되는지 파악하기

- 동일한 연산(sum, filter 등)을 for문, stream 각각으로 구현해보기
    - 가능하다면 많은 양의 데이터(10만 건)를 넣고 실행하여 시간 재보기 (시니어 포함 필수 아님)
- 인터넷 검색을 통해 둘의 차이 파악하기

### 2️⃣ for, stream 각각 적용 시 장단점 파악하기

- 찾아본 원리를 토대로 서로의 장단점 적어보기

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- 장단점을 토대로 언제 적용하면 좋을 지 파악하기
    - 가독성 측면, 성능 측면 등
- 미션 기록
    
    ## Page vs Slice 비교 분석
    
    ## **Page와 Slice 구조적 차이**
    
    **Page 인터페이스**
    
    - `Slice`를 상속받아 확장된 인터페이스
    - 전체 데이터 개수(`getTotalElements()`)와 전체 페이지 수(`getTotalPages()`) 제공
    - 추가적인 count 쿼리를 실행하여 전체 정보를 계산
    
    **Slice 인터페이스**
    
    - 다음 페이지 존재 여부(`hasNext`)만 확인 가능
    - count 쿼리를 실행하지 않음
    - 요청한 크기보다 하나 더 많이 조회하여 다음 페이지 존재 여부 판단
    
    ## **출력값 차이점**
    
    ```java
    *// Page 사용 시*
    Page<TestEntity> page = repository.findPageBy(pageRequest);
    *// 실행되는 쿼리: SELECT + COUNT 쿼리 2개// Slice 사용 시*  
    Slice<TestEntity> slice = repository.findSliceBy(pageRequest);
    *// 실행되는 쿼리: SELECT 쿼리 1개 (limit + 1)*
    ```
    
    **Page 출력 정보**
    
    - 현재 페이지 데이터
    - 전체 데이터 개수
    - 전체 페이지 수
    - 현재 페이지 번호
    - 다음/이전 페이지 존재 여부
    
    **Slice 출력 정보**
    
    - 현재 페이지 데이터
    - 다음/이전 페이지 존재 여부만
    - 현재 페이지 번호
    
    ## **Page와 Slice 장단점**
    
    | 구분 | Page | Slice |
    | --- | --- | --- |
    | **장점** | 전체 정보 제공, 페이지 네비게이션 구현 가능 | 성능 최적화, 빠른 응답 속도 |
    | **단점** | 추가 count 쿼리로 인한 성능 부하 | 제한된 정보, 전체 페이지 수 알 수 없음 |
    
    **Page 사용**
    
    - 전체 페이지 수가 필요한 일반적인 페이지네이션
    - 사용자가 특정 페이지로 직접 이동해야 하는 경우
    - 데이터 양이 적거나 count 쿼리 비용이 크지 않은 경우
    
    **Slice 사용**
    
    - 무한 스크롤 구현
    - 대용량 데이터에서 count 쿼리 비용이 큰 경우
    - "더보기" 방식의 UI
    
    ## For vs Stream 비교
    
    ## **작동 방식 차이**
    
    **For문**
    
    - 명령형 프로그래밍 스타일
    - 직접적인 반복 제어
    - 인덱스 기반 메모리 접근
    
    **Stream**
    
    - 함수형 프로그래밍 스타일
    - 선언적 접근 방식
    - 지연 연산과 파이프라인 처리
    
    ## **성능 비교**
    
    **For문의 성능 우위**
    
    - 원시 타입 처리 시 약 7배 빠름
    - JVM 최적화가 잘 되어있음 (Java 1부터 지원)
    - 오버헤드가 거의 없음
    
    **Stream의 성능 특성**
    
    - Stream 객체 생성과 boxing/unboxing으로 인한 오버헤드
    - 대용량 데이터에서는 병렬 처리로 성능 향상 가능
    - 소량 데이터에서는 For문보다 느림
    
    ## **장단점 비교**
    
    | 구분 | For문 | Stream |
    | --- | --- | --- |
    | **성능** | 우수 (특히 소량 데이터) | 보통 (병렬 처리 시 향상 가능) |
    | **가독성** | 보통 (복잡한 로직 시 저하) | 우수 (선언적 스타일) |
    | **디버깅** | 쉬움 | 어려움 (스택 트레이싱 복잡) |
    | **병렬 처리** | 복잡함 (수동 구현 필요) | 간단함 (`parallelStream()`) |
    | **유지보수** | 보통 | 우수 |
    
    **For문 사용**
    
    - 성능이 중요한 대용량 데이터 처리
    - 원시 타입 데이터 처리
    - 조건부 종료(`break`, `continue`)가 필요한 경우
    - 단순한 반복 작업
    
    **Stream 사용**
    
    - 복잡한 데이터 변환과 필터링
    - 가독성과 유지보수성이 중요한 경우
    - 병렬 처리가 필요한 경우
    - 함수형 프로그래밍 스타일 선호 시