# 시니어 미션

- **JPA의 깊은 개념을 이해하고 실제 서비스에서 발생하는 문제를 해결**한다.
- **복잡한 연관관계 매핑 & 성능 최적화**를 고려한 엔티티 설계를 적용한다.

---

### 📌 **미션 상세 내용**

### **1️⃣ 성능을 고려한 연관관계 매핑 & 최적화 적용**

- **`@OneToMany` 컬렉션을 조회할 때 `List<MemberPrefer>`를 `Set<MemberPrefer>`로 변경 후 차이점 분석**
- **데이터 정합성을 고려하여 `orphanRemoval = true`가 필요한 곳 확인 후 적용**

---

### **2️⃣ 트랜잭션 & 동시성 이슈 처리**

- **하나의 트랜잭션에서 여러 엔티티를 처리하는 비즈니스 로직 작성**
    - 예) `Member`가 탈퇴할 경우 **관련된 모든 데이터를 삭제하는 API** 구현
    - `@Transactional`을 적용하고, `@Modifying`을 활용하여 **Batch Delete 쿼리 최적화**
- **동시성 문제가 발생할 수 있는 시나리오**를 고민하고 해결책 적용
    - 예) 같은 회원이 동시에 같은 `Store`를 찜하려고 할 때 중복이 발생하지 않도록 `@Lock` 사용
    - 다양한 락킹 전략에 대해 공부해보고, 이를 정리하기

---

## List와 Set, 어떻게 다를까?

JPA에서 연관관계를 맺을 때 `List`와 `Set` 중 뭘 써야 할지 고민하는 경우가 많죠.

둘의 차이를 간단히 정리하면 이렇습니다.

- **List**는 요소의 순서를 보장하고, 중복도 허용합니다.
    
    예를 들어, 게시글에 달린 댓글처럼 순서가 중요한 경우에 주로 씁니다.
    
    `@OrderBy` 같은 어노테이션으로 정렬 기준도 쉽게 줄 수 있죠.
    
- **Set**은 순서가 없고, 중복을 허용하지 않습니다.
    
    내부적으로 해시값을 이용해 관리하기 때문에, 같은 값이 들어오면 자동으로 걸러집니다.
    
    다만, 순서가 필요할 땐 적합하지 않습니다.
    

## 성능상 차이점

- **List를 쓸 때**
    
    `@OneToMany` 관계에서 `List`로 매핑하면, JPA가 컬렉션의 순서를 맞추기 위해
    
    기존 데이터를 싹 지우고 다시 다 넣는 쿼리를 날릴 때가 있습니다.
    
    데이터가 많아질수록 성능에 부담이 생길 수 있죠.
    
- **Set을 쓸 때**
    
    `Set`은 중복만 체크하면 되니까, 추가나 삭제가 단순하게 처리됩니다.
    
    그래서 쿼리도 훨씬 간결해지고, 성능도 좋아집니다.
    
    하지만, 중복 체크를 위해 컬렉션 전체를 로딩해야 하다 보니
    
    `Lazy Loading`이 제대로 동작하지 않을 수 있다는 점은 주의해야 합니다.
    

## 언제 List, 언제 Set?

- **List**는 순서가 중요하거나, 컬렉션이 커서 지연 로딩이 필요할 때 적합합니다.
- **Set**은 중복이 절대 허용되면 안 되고, 컬렉션 크기가 작을 때 쓰는 게 좋습니다.

## orphanRemoval이란?

`orphanRemoval`은 부모와의 관계가 끊긴 자식 엔티티를 자동으로 삭제해주는 기능입니다.

예를 들어, 부모가 자식 리스트에서 어떤 엔티티를 빼면,

JPA가 알아서 해당 자식을 DB에서 지워줍니다.

```java
@Entity
public class Parent {
    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "parent", orphanRemoval = true)
    private List<Child> childList = new ArrayList<>();
}
```

이렇게 설정해두면,

`parent.getChildList().remove(child);`

처럼 리스트에서 자식을 빼는 것만으로도 DB에서 삭제가 이뤄집니다.

## 언제 쓰면 좋을까?

- 자식 엔티티가 오직 한 부모만 참조할 때
- 부모가 자식의 생명주기를 완전히 관리해야 할 때
    
    (도메인 주도 설계에서 애그리거트 루트 패턴과 잘 어울립니다)
    

`CascadeType.REMOVE`와 비슷하지만,

관계가 끊어질 때도 삭제된다는 점이 다릅니다.

## 트랜잭션 관리 & 벌크 연산

## @Transactional, 언제 필요할까?

여러 데이터를 한꺼번에 바꿔야 하거나,

데이터 일관성이 중요한 작업에는 트랜잭션이 꼭 필요합니다.

```java
@Transactional
public void processBusinessLogic() {
    *// 여러 엔티티를 수정하는 로직*
}
```

조회만 하는 경우라면 굳이 트랜잭션을 쓸 필요는 없고,

읽기 전용 트랜잭션 옵션을 주는 것도 방법입니다.

## 벌크 연산으로 성능 높이기

반복문 돌면서 하나씩 삭제하거나 업데이트하면

쿼리가 너무 많이 나가서 성능이 떨어집니다.

이럴 땐 JPQL이나 네이티브 쿼리로 한 번에 처리하는 게 훨씬 효율적입니다.

```java
@Modifying
@Query("DELETE FROM UserCertLog u WHERE u.regDatetime < :cutoff")
int deleteByOldLogs(@Param("cutoff") LocalDateTime cutoff);
```

`@Modifying` 어노테이션을 꼭 붙여야 실제로 DB에 반영됩니다.

## 동시성 문제와 락

## 실무에서 겪는 문제

여러 사용자가 동시에 같은 데이터를 수정하면

내가 저장한 값이 다른 사람에 의해 덮어써지는 일이 생길 수 있습니다.

## JPA의 락 전략

- **낙관적 락(Optimistic Lock)**
    - `@Version` 필드를 두고, 트랜잭션 종료 시점에 버전을 비교합니다.
    - 충돌이 잘 안 나는 환경에 적합합니다.
- **비관적 락(Pessimistic Lock)**
    - DB에서 아예 락을 걸고, 다른 트랜잭션이 접근하지 못하게 막습니다.
    - 충돌이 자주 일어나거나, 데이터 정합성이 아주 중요한 경우에 씁니다.

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
Optional<Store> findByIdWithLock(Long id);
```

```java
@Transactional
public void addFavorite(Long memberId, Long storeId) {
    Store store = storeRepo.findByIdWithLock(storeId)
        .orElseThrow(() -> new EntityNotFoundException("매장 없음"));
    Member member = memberRepo.findById(memberId)
        .orElseThrow(() -> new EntityNotFoundException("회원 없음"));

    favoriteRepo.save(new FavoriteStore(member, store));
}
```

## 락 전략, 어떻게 고를까?

- **낙관적 락**: 충돌이 거의 없는 환경, 동시성이 중요한 서비스에 적합
- **비관적 락**: 충돌이 잦거나, 데이터가 꼬이면 안 되는 상황에 추천

## 회원 탈퇴 API 예시

실제 회원 탈퇴 기능을 만든다고 하면,

회원 정보와 연관된 데이터(예: 선호 정보, 찜한 매장 등)를 한 번에 삭제해야 합니다.

```java
@Service
public class MemberService {
    private final MemberRepo memberRepo;
    private final PreferRepo preferRepo;
    private final FavoriteRepo favRepo;

    @Transactional
    public void withdrawMember(Long memberId) {
        preferRepo.deleteAllByMemberId(memberId);
        favRepo.deleteAllByMemberId(memberId);
        memberRepo.deleteById(memberId);
    }
}

@Repository
public interface PreferRepo extends JpaRepository<MemberPrefer, Long> {
    @Modifying
    @Query("DELETE FROM MemberPrefer mp WHERE mp.member.id = :memberId")
    void deleteAllByMemberId(@Param("memberId") Long memberId);
}
```