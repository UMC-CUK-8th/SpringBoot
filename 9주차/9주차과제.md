# 시니어 미션

### 1️⃣ Page와 Slice가 각각 어떻게 출력값이 나오는 지 알아보기

- Page

```jsx
Page<Post> postPage = postRepository.findAll(PageRequest.of(0, 10));
```

- 출력 결과
    - `getContent()` → 실제 데이터 리스트
    - `getTotalPages()` → 전체 페이지 수
    - `getTotalElements()` → 전체 요소 수
    - `isLast()`, `isFirst()` 등 제공

- Slice

```jsx
Slice<Post> postSlice = postRepository.findAll(PageRequest.of(0, 10));
```

- 출력 결과
    - `getContent()` → 실제 데이터 리스트
    - `hasNext()` → 다음 페이지 존재 여부
    - `isLast()` → 마지막 페이지 여부
    - `총 개수 관련 정보 없음 (getTotalElements() 사용 불가)`

### 2️⃣ Page, Slice 각각 적용 시 장단점 파악하기

| 구분 | Page | Slice |
| --- | --- | --- |
| 장점 | 전체 개수, 전체 페이지 수 확인 가능 | 퍼포먼스 우수
count 쿼리 |
|  | UI 페이지네이션에 유리 | 단순 판단에 적합 |
| 단점 | count(*)쿼리로 성능 이슈 | 전체 개수 파악 불가능 |
|  | 불필요한 연산이 들어갈 수 있음 | page 기반 UI 구현 어려움 |

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- ✅ **Page**
    - 페이지 수/전체 데이터 수를 보여줘야 할 때
    - 관리자 페이지, 검색 기능 등에서 유용
- ✅ **Slice**
    - 무한 스크롤 구현 시
    - 성능 최적화가 중요한 경우
    - “다음 페이지 존재 여부만” 필요할 때

### 1️⃣ for과 stream이 어떻게 작동되는지 파악하기

- for문
    - 합계 계산
    - 단순 연산은 더 빠름

- Stream은 람다식
    - 병렬 처리 시 성능이 더 좋아질 수 있음
    - Stream = 컬렉션 처리용 API
        - 안에서 사용하는 함수에 람다식을 매개변수로 전달

### 2️⃣ for, stream 각각 적용 시 장단점 파악하기

| 구분 | for | stream |
| --- | --- | --- |
| **장점** | 빠름, 명확한 흐름 제어 | 가독성 좋음, 간결함, 함수형 |
| **단점** | 코드가 길어질 수 있음 | 성능 이슈 가능, 디버깅 어려움 |
| **기타** | 복잡한 분기 처리 유리 | 병렬 처리에 유리(parallelStream |

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- for문
    - 복잡한 조건이나 예외 처리가 필요한 경우
    - 성능이 중요한 루프
    - 명확한 흐름 제어가 필요한 경우

- stream
    - 필터, 매핑, 수집 등 선언적 코드가 가능한 경우
    - 가독성을 중요시하는 팀 문화
    - 병렬 처리의 이점을 살리고 싶은 경우