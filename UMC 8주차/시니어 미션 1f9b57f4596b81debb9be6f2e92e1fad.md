# 시니어 미션

**미션 목표:**

- **@DynamicInsert, @DynamicUpdate** 어떻게 작동되는 지 파악하고 장단점을 파악 후에 언제 **적용**하면 좋을 지 파악해보기
- **Rest Docs**가 무엇인지 알아보고 **Swagger**와 장단점 파악하기

**미션 상세 내용:**

### 1️⃣ @DynamicInsert와 @DynamicUpdate가 어떻게 작동되는 지 파악하기

- 기존 JPA 쿼리 문이 어떻게 만들어지는 지 알아보기

기존 JPA 쿼리문은 insert, update시 해당 칼럼만이 아닌, 

해당 엔티티의 모든 칼럼에 대해 수정 쿼리가 발생하게됨.

→모든 필드를 업데이트하기에 db 부하 증가 및 성능 저하

하지만 이렇게 하는 이유가 있는데, 

1. Hibernate는 모든 필드 사용시 바인딩 되는 데이터만 다를뿐, 등록 및 수정 쿼리가 항상 같기에 쿼리를 미리 생성해두고 재사용 가능
2. db에 동일한 쿼리문을 보내면 이미 한 번 파싱된 쿼리를 재사용 가능

즉 SQL 재사용이 가능.

- @DynamicInsert, @DynamicUpdate 적용 시 어떻게 바뀌는 지 알아보기

-DynamicInsert

등록되는 엔티티에 대해 값이 설정된 필드만 db에 등록됨

실제 저장되는 필드에 대한 쿼리만 발생하게됨

기본값을 DB에 위임 가능 (`DEFAULT` 값 적용 가능

-DynamicUpdate

역시 실제 수정되는 칼럼에 대해서만 수정 쿼리가 발생함.

### 2️⃣ 기존과 @DynamicInsert, @DynamicUpdate 적용 시 장단점 파악하기

- 찾아본 원리를 토대로 서로의 장단점 적어보기

값이 설정된 필드에 대해서만 쿼리가 발생하기에 성능 향상이 가능해지지만

쿼리가 매번 달라지기에 SQL 재사용이 어려워 유지보수 측면에서는 아쉬워보인다.

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- 장단점을 토대로 언제 @DynamicInsert, @DynamicUpdate를 적용하면 좋을 지 적기

DB에 dafulat 값이 있는 컬럼이 존재하는 경우나, DB 부하에 민감한 서비스, 엔티티의 필드가 많고 특정 칼럼에 수정이 잦은 경우에 적용 가능.

- 시간이 되신다면 테스트 용 엔티티를 만들어서 시간까지 측정해보면 좋을 것 같습니다. 그 후 정말 쓸모가 있는 지도 파악해보면 좋을 것 같습니다. (이것은 시니어 분들 포함 필수가 아닙니다.)

### 1️⃣ Rest Docs가 무엇인지 알아보기

- Rest Docs가  무엇인지 검색해보기

Spring MVC 테스트를 기반으로 **실제 API 호출 결과로 문서를 생성**

API 동작에 대한 테스트를 기반으로 하기 때문에 **문서와 실제 코드가 동기화**

### 2️⃣ Swagger와 Rest Docs의 장단점 비교하기

- Swagger와 Rest Docs의 장단점 적어보기

Swagger는 어노테이션 기반(@Api), Rest Docs는 테스트 기반(MockMvc)으로 문서 생성. swaggger는 수동으로 유지해야 하지만 비교적 쉽게 적용이 가능하고, Rest Docs는 테스트를 기반으로 하기에 동기화에 용이하지만 테스트 코드를 작성해야하기에 진입 장벽이 조금 더 높다.

Swagger 같은 기존 문서화 도구들은 swagger를 위한 코드가 프로덕션 환경에 묻는다는 점, 그리고 수정 시 업데이트 상태와 문서의 상태가 서로 맞지 않는 문제 등이 있다. 

스프링 REST Docs는 테스트, 빌드를 기반으로 작성하기에 싱크가 유지될 수 있다는 장점이 있음

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- 장단점을 토대로 언제 Swagger와 Rest Docs를 적용하면 좋을 지 적기

빠르게 시각화할 문서가 필요한 상황이라면 Swagger로, 테스트 기반으로 정확한 문서가 필요한 경우라면 Rest Docs를 적용하면 좋을 것이다.

개발 완료 후 문서화를 진행한다면 간편한 Swagger를, 개발 중에 문서화가 필요하다면 빠른 동기화를 위해 Rest Docs를 사용할 것 같다.

- 시간이 되신다면 Rest Docs를 실제로 적용해보고 테스트 코드를 적어본 후 문서를 생성해보며 직접 경험해본 후에 적어봐도 좋을 것 같습니다. (이것은 Rest Docs를 적용하는 데도 시간이 많이 걸릴 수 있기에 시니어 분들 포함 필수가 아닙니다.)

Rest Docs

```groovy

dependencies {
    testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'
}
```

테스트 api

```java
@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping
    public ResponseEntity<UserResponse> createUser(@RequestBody UserRequest request) {
        UserResponse response = new UserResponse("1", request.getName());
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}

```

테스트 코드 통한 REST Docs 문서화

```java
@WebMvcTest(UserController.class)
@AutoConfigureRestDocs(outputDir = "build/generated-snippets")
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void createUser_문서생성() throws Exception {
        String requestBody = """
                {
                  "name": "John Doe"
                }
                """;

        mockMvc.perform(post("/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isCreated())
            .andDo(document("user-create", // 문서 조각 이름
                    requestFields(
                        fieldWithPath("name").description("사용자 이름")
                    ),
                    responseFields(
                        fieldWithPath("id").description("생성된 사용자 ID"),
                        fieldWithPath("name").description("사용자 이름")
                    )
            ));
    }
}

```