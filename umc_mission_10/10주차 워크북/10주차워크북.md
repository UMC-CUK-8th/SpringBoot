

## 🎯 핵심 키워드

<aside>
💡 주요 내용들을 정리하고, 여러분만의 생각을 통해 정리해보세요!

- 레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 괜찮습니다.
- 조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**
</aside>

- **Spring Security**
    
    **Spring Security**는 **인증, 권한 관리 그리고 데이터 보호 기능을 포함**하여 **웹 개발 과정에서 필수적인 사용자 관리 기능을 구현하는데 도움을 주는 Spring의 프레임워크이다.** 
    자바 개발자들이 보안 기능을 추가 할 때 spring security 를 사용하는 이유는 Spring Security가 Spring생태계에서 보안에 필요한 기능들을 제공하기 때문이다. Spring Security는 개발 구조가 Spring 이라는 프레임워크 안에서 활용하기 적합한 구조로 설계되어 있어, 보안 기능을 추가할 때 활용하기 좋다.
    프레임워크를 사용하지 않으면 IoC/DI 패턴과같은 확장 패턴을 염두해서 개발해야하기 때문에 spring security 프레임워크를 사용하는 것이 좋다. 
    
- **인증(Authentication)과 인가(Authorization)**
    
    인증(Authentication) : 증명으로, 유저가 누구인지 확인하는 것이다, 통상 회원가입 하고 로그인 하는 것을 말한다
    즉 사용자가 신원을 증명하고 로그인하는 과정. Spring Security는 사용자의 로그인 정보를 기반으로 인증을 처리
    
    인가(Authorization) : 허락으로, 유저에 대한 권한을  확인, 허락하는 것 
    즉 특정 리소스 또는 기능에 접근할 권한이 있는지를 결정하는 과정. Spring Security는 사용자의 권한을 관리하고 보호된 리소스에 대한 접근을 허용하거나 거부하는데 사용한다
    
- **세션과 토큰**
    
    세션 또는 토큰을 사용하는 이유 : 클라이언트가 로그인 인증을 위해 요청을 보내더라도 무상태성때문에 로그인의 상태가 유지되지 않는다. 이러한 단점을 보안하기 위해 **쿠키와 세션**을 사용한다
    
    **세션 기반 자격 증명**
    세션은 클라이언트의 Request에 자동으로 서버에 전달되는 쿠키에 `세션 Id`가 담겨 전달되는 방식으로 사용되지만 브라우저에 저장되는 쿠키와는 달리 서버에서 관리된다
    ⇒ **인증된 사용자의 정보를 서버의 세션 저장소에서 관리**하고 클라이언트에겐 해당 사용자를 구분할`세션 Id`만 전달
    
    - 인증된 사용자의 정보를 서버의 세션 저장소에서 관리
    - 서버로부터 생성된 세션ID는 고유한 값을 가지며, 클라이언트의 쿠키에 저장되어 있다가request시 쿠키가 전송되는 시점에 함께 전송되며 인증된 사용자임을 증명하는 수단으로 사용된다.
    - 세션ID만 클라이언트 쪽에서 사용하므로 상대적으로 적은 네트워크 트래픽을 사용
    - 서버에서 세션 정보를 관리하므로 보안성 측면에서 조금 더 유리
    - 서버의 확장성 면에서는 세션 불일치 문제가 발생할 가능성이 높다 (⇒ 서버가 여러개로 확장힌다면 세션 불일치 문제가 발생할 수 있다.) 외부 저장소로 세션을 옮겨서 보안함
    - 세션 데이터가 많아질수록 서버의 부담이 가중된다
    - SSR 방식의 애플리케이션에 적합한 방식이다(***SSR***은 브라우저가 페이지를 요청할 때마다 해당 페이지에 관련된 HTML, CSS, JS 파일 및 데이터를 받아와서 렌더링하는 ***방식***)
    
    **토큰 기반 자격 증명 방식**
    
    클라이언트의 요청 시마다 사용자의 자격 증명 정보를 보내는 것이다.
    - 토큰에 인증된 사용자 정보를 저장하기 때문에 서버에서 별도의 관리를 하지 않는다.
    - 생성된 토큰은 클라이언트의 Request를 보낼 때, header에 포함되어 사용자를 증명하는 수단으로 사용된다.
    - Request마다 사용자 정보가 저장된 토큰을 보내야하므로 세션에 비해 더 많은 네트워크 트래픽을 사용한다.
    - 서버에서 토큰을 관리하지 않기 때문에 보안성 측면에서 조듬 더 불리하다
    - 사용자의 인증된 정보를 서버에서 관리하지 않기 때문에 서버의 확장성 면에서 유리하고 세션 불일치와 같은 문제가 발생하지 않는다.
    - 기본족으로 토큰이 만료되기 전까지는 토큰을 무효화 시킬 수 없다.
    - CSR 방식의 애플리케이션에 적합한 방식(웹 브라우저에서 JavaScript를 사용하여 웹페이지를 렌더링 하는 방식입니다.즉, 사용자의 브라우저가 서버로부터 데이터를 받아와서 웹 페이지를 직접 생성) 
    
    토큰에 저장된 사용자 정보는 토큰의 특성 상 암호화가 되지 않기 때문에 탈취될 위험이 크다. 따라서 민감한 정보를 포함시키지 않도록 주의해야한다.
    토큰의 무효화 문제는 토큰의 만료기간은 짧게 설정해 보완한다.
    
- **액세스 토큰(Access Token)과 리프레시 토큰(Refresh Token)**
    
    JWT방식의 인증 강화 방식으로 액세스 토큰만을 통한 인증 방식의 문제는 제 3자에세 탈취당할 경우 보안에 취약하다는 점이다
    액세스 토큰은 발급된 이후, 서버에 저장되지 않고 토큰 자체로 검증을 하며 사용자 권한을 인증하기 때문에 액세스 토큰이 탈취되면 토큰이 만료되기 전 까지 토큰을 획득한 사람은 누구나 권한 접근이 가능해 지기 때문이다.
    JWT는 발급한 후 삭제가 불가능하기 때문에 접근에 관여하는 토큰에 유효시간을 부여하는 식으로 탈취 문제에 대해 대응을 하여야 한다
    ⇒ 토큰 유효기간 짧게하기 ⇒ 로그인 자주해야한다
    ⇒ 토큰 유효기간 길게하기 ⇒ 토큰이 탈취당했을 때 보안에 취약해진다
    유효기간 짧게 하면서 보안성 확보 ⇒ 리프래시 토큰
    
    리프레시 토큰과 액세스 토큰은 똑같은 JWT이다 차이점은 액세스 토큰은 접근에 관한 것 리프레시 토큰은 재발급에 관여하는 토큰으로 하는 역할이 다르다.
    
    처음 로그인 했을 때 서버는 로그인을 성공시키면서 클라이언트에게 액세스 토큰과 리프레시 토큰을 동시에 발급한다. 서버는 DB에 리프레시 토큰을 저장하고 -, 클라이언트는 액세스 토큰과 리프레시 토큰을 쿠키, 세션 혹은 웹스토리지에 저장하고 요청이 있을때마다 이 둘을 헤더에 담아서 보낸다.
    이 리프레시 토큰은 긴 휴효기간을 가지면서 액세스 토큰이 만료됐을 때 새로 재발급해주는 열괴가 도니다. 다라서 만일 만료된 액세스 토큰을 서버에 보내면 서버는 같이 보내진 리프레시 토큰을 DB에 있는 것과 비교해서 일치하면 다시 액세스 토큰을 재발급하는 원리다. 사용자가 로그아웃을 하면 저장소에서 리프레시 토큰을 삭제하여 사용이 불가능하도록 하고 새로 로그인하면 서버에서 다시 재발급해서 DB에 저장한다.
    즉 리프레시 토큰은 접근에 대한 권한을 주는 것이 아니라 액세스 토큰 재발급에만 관여하는 것이다.
    

## 📢 학습 후기

<aside>
💡 이번 주차 워크북을 해결해보면서 어땠는지 회고해봅시다.

- Spring Security의 로그인 과정에 대해 완전히 이해했나요?
- 혹시 이해가 안 되는 부분이 있었나요?
- 이번 실습에서 어려웠던 부분은 무엇이었나요?
</aside>

## ⚠️ 스터디 진행 방법

1. 스터디를 진행하기 전, 워크북 내용들을 모두 채우고 스터디에서는 서로 모르는 내용들을 공유해주세요.
2. 미션은 워크북 내용들을 모두 완료하고 나서 스터디 전/후로 진행해보세요.
3. 다음주 스터디를 진행하기 전, 지난주 미션을 서로 공유해서 상호 피드백을 진행하시면 됩니다.

## 🔥 미션

<aside>
📍 **주의 사항**

결과물만 올리면 안되고, 중간 과정 또한 기록을 남겨주셔야 합니다.
(DB 연결, 테이블 생성 등)

**결과물과 중간 과정 모두 기록하여 제출**하라는 뜻입니다.

</aside>

### 필수 미션

<aside>

**⚠️ 모든 미션 과정은 깃허브에 업로드해주세요.**

</aside>

1. **실습 1: Spring Security를 활용한 로그인 및 회원가입 구현 = Session 방식**
    - 회원가입, 로그인, 로그아웃 기능을 구현하고 **DB에 저장**되는 과정을 캡처하고 설명하세요.
    
    ![image.png](image%2033.png)
    
    ![image.png](image%2034.png)
    
    ![image.png](image%2035.png)
    
    위 내용은 로그인 페이지에서 작성후 db에 입력되는 로그와 db에 입력된 내용을 보여준 것이다.
    
    ![image.png](image%2036.png)
    
    로그인 후 나오는 홈페이지
    
    관리자 페이지 테스트
    
    ![image.png](image%2037.png)
    
    관리 계정의 관리자 페이지
    
    ![image.png](image%2038.png)
    
    일반 회원 페이지 관리자 페이지에 접속불가
    
2. **실습 2: Spring Security를 활용한 로그인 및 회원가입 구현 = JWT 방식**
    - 회원가입, 로그인을 구현하고 **Swagger에서 테스트 및 DB에 저장**되는 과정을 캡처하고 설명하세요.
        1. jwt토큰을 구현 후 스웨거를 통한 회원가입 성공 화면
    
    ![image.png](image%2039.png)
    

![image.png](image%2040.png)

JWT를 통한 유저의 로그인 성공 화면

![image.png](image%2041.png)

![image.png](image%2042.png)

JWT 코드 구현

로그인 정보를 받기위한 dto

![image.png](image%2043.png)

![image.png](image%2044.png)

1. yml 설정 파일에 있는 해당 설정값들을 가져오는 방식으로 **`JwtProperties`**  클래스를 사용

![image.png](image%2045.png)

1. 변하지 상수들을 전역처리 하는 클래스

![image.png](image%2046.png)

1. 인증 경로를 추가해주는 클스

![image.png](image%2047.png)

1. 로그인에 필요한 `Authentication` 객체를 만들어서 jwt token을 발급해주기 위한 클래스를 구현 및 인터페이스를 설정 구현 클래스에서는 입력받은 멤버가 실제로 있는지 확인하고 jwt 토큰을 발급하여 loginResultDTO에 담아서 보내는 기능을 수행한다.

![image.png](image%2048.png)

![image.png](image%2049.png)

1. 앞단에서 로그인 결과 dto를 보여주기위해 멤버REST컨트롤러에 추가한 코드

![image.png](image%2050.png)

1. 내 정보 조회 로직을 위한 클래스

로그인한 회원의 정보를 담기위한 DTO

![image.png](image%2051.png)

![image.png](image%2052.png)

위 사진은 멤버쿼리서비스 인터페이스로 구현클래스의 내 정보 조회 로직을 위해 추가로 입력

![image.png](image%2053.png)

 `JwtTokenProvider`에 정의한 `extractAuthentication` 메소드를 통해 토큰을 파싱하고, Authentication 객체를 추출 추출해낸 인증 객체(Authentication)을 통해 사용자 정보를 가져오고, `MemberRepository` 로부터 사용자 정보를 조회 조회에 성공하면, 정의한 Response DTO인 `MemberInfoDTO` 로 반환

![image.png](image%2054.png)

컨트롤러단에서  내 정보 조회’는 로그인한 사용자만이 접근할 수 있는 API여야 하기에 Swagger 어노테이션인 `@Operation` 어노테이션에 security 필드를 추가해서 token이 요청 필수값임을 명시

스웨거 수행 결과 

![image.png](image%2055.png)

![image.png](image%2056.png)

- 아래는 실습 참고 코드입니다.
    
    [GitHub - chock-cho/UMC-8th-spring-workbook at feature-week10-workbook-2](https://github.com/chock-cho/UMC-8th-spring-workbook/tree/feature-week10-workbook-2)
    

### 시니어 미션

- **카카오, 구글 또는 네이버 소셜 로그인 추가 구현**
    - 결과물과 중간 과정을 기록하여 제출하세요.
- **리프레시 토큰 방식 로그인 추가 구현**
    - 결과물과 중간 과정, 액세스 토큰만 이용했을 때의 인증방식과의 장단점을 비교해서 제출하세요.

## 💪 미션 기록

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

- **미션 기록**

> **GitHub 저장소 주소**
> 
> 
> https://github.com/…
> 

## ⚡ 트러블 슈팅

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널**에 질문해보세요!

</aside>

- ⚡이슈 작성 예시 (이슈가 생기면 아래를 복사해서 No. 1, No. 2, No. 3, … 으로 작성해서 트러블 슈팅을 꼭 해보세요!)
    
    **`이슈`**
    
    👉 앱 실행 중에 노래 다음 버튼을 누르니까 앱이 종료되었다.
    
    **`문제`**
    
    👉 노래클래스의 데이터리스트의 Size를 넘어서 NullPointException이 발생하여 앱이 종료된 것이었다. 
    
    **`해결`**
    
    👉  노래 다음 버튼을 눌렀을 때 데이터리스트의 Size를 검사해 Size보다 넘어가려고 하면 다음으로 넘어가는 메서드를 실행시키지 않고, 첫 노래로 돌아가게끔 해결
    
    **`참고 레퍼런스`**
    
    - 링크
- ⚡이슈 No. 1
    
    **`이슈`**
    
    👉 [트러블이 생긴 상태 작성]
    
    **`문제`**
    
    👉 [어떤 이유로 해당 이슈가 일어났는지 작성]
    
    **`해결`**
    
    👉  [해결 방법 작성]
    
    **`참고 레퍼런스`**
    
    - [문제 해결 시 참고한 링크]

Copyright © 2025 신수정(베뉴) All rights reserved.

Copyright © 2024 김준석(벡스) All rights reserved.