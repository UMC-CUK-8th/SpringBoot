# 시니어 미션

### 1️⃣ Page vs Slice

Page와 Slice는 상속관계이다.

```java
public interface Page<T> extends Slice<T> {
```

그래서 Slice가 가진 모든 메소드를 Page도 사용할 수 있지만, 다른 요소가 있는데 반환값 비교를 해보면 getTotalElements, getTotalPages를 갖고 있다.

그 외는 같다.

-slice

```java
{
  "status": "OK",
  "message": "허브 검색 성공",
  "data": {
    "content": [ ... ],
    "pageable": {
      "pageNumber": 0,
      "pageSize": 2,
      "offset": 0,
      "paged": true,
      "unpaged": false
    },
    "last": false,
    "size": 2,
    "number": 0,
    "sort": {
      "empty": true,
      "sorted": false,
      "unsorted": true
    },
    "first": true,
    "numberOfElements": 2,
    "empty": false
  }
}

```

-page

```java
{
  "status": "OK",
  "message": "허브 검색 성공",
  "data": {
    "content": [ ... ],
    "pageable": {
      "pageNumber": 0,
      "pageSize": 2,
      "offset": 0,
      "paged": true,
      "unpaged": false
    },
    "last": false,
    "totalElements": 10,
    "totalPages": 5,
    "size": 2,
    "number": 0,
    "sort": {
      "empty": true,
      "sorted": false,
      "unsorted": true
    },
    "first": true,
    "numberOfElements": 2,
    "empty": false
  }
}

```

slice엔 나오지 않던 totalElements와 totalPages가 함께 반환된다.

### 2️⃣ Page, Slice 각각 적용 시 장단점

**`Page`는 페이지 번호나 전체 페이지 수가 필요할 때 사용할 수 있다**는 장점이 있지만**,** 내부적으로 **`SELECT COUNT(*)` 쿼리를 추가로 실행**하므로, 데이터량이 많거나 복잡한 조건의 경우 반환 속도가 느려지고 쿼리 비용이 상당히 증가할 수 있다.

**`Slice`는 다음 페이지가 존재하는지만 판단하기 때문에 항상 `limit + 1` 로 조회**하게 되어 응답 시간이 빠르다. 메모리 측면에서도 더 절약할 수 있다.

### 3️⃣ 언제 적용?

-Page

- **페이지네이션 UI가 필요한 경우** (페이지 번호, 전체 페이지 수, 전체 개수 등 표시)
- 관리자가 전체 데이터 흐름을 파악할 필요가 있을 때 (ex. 관리자 웹 페이지)
- 고정된 데이터셋의 목록을 정확하게 탐색해야 할 때

-Slice

- **모바일 앱, 무한 스크롤 UI**: 전체 페이지 수 없이 "더 보기" 버튼이나 "스크롤 시 자동 로딩"
- **성능이 중요한 경우**: 대규모 데이터에서 전체 count를 조회하지 않도록 하여 DB 부담 줄이기
- 응답 시간이 중요한 실시간 시스템 (예: 인스타그램 피드, 로그 조회, 무한 스크롤 등)

### 1️⃣ for과 Stream

for문

```java
public static void main(String[] args) {
    
        // List를 생성한다.
        List<String> list = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");

        // 결과를 저장할 새 List 생성
        List<String> result = new ArrayList<>();

        // List를 순회하며 "apple"을 찾고 대문자로 변환
        for (String fruit : list) {
            if (fruit.equals("apple")) {
                result.add(fruit.toUpperCase());
            }
        }

        // 결과 출력
        System.out.println(result);
    } 
```

-stream

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamExample {
    public static void main(String[] args) {
        // List 생성
        List<String> list = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");

        // List를 Stream으로 변환하고 "apple"을 찾아 대문자로 변환
        List<String> result = list.stream()
            .filter(fruit -> fruit.equals("apple"))
            .map(String::toUpperCase)
            .collect(Collectors.toList());

        // 결과 출력
        System.out.println(result);
    }
}

```

1. 스트림의 중간 연산들은 레이지(lazy)하게 동작.

- 중간 연산이란?

.filter(), .map() 등이 중간 연산이다. 

이런 연산들은 실제로는 데이터에 즉시 적용되지 않는다. 대신에 "이런 작업을 할 거야"라고만 표시한다.

- 최종 연산이란?

.collect(), .forEach(), .sum() 등. 이 연산들이 호출되는 순간, 중간 연산에 적용될 모든 작업이 실제로 실행된다. 즉, .filter()나 .map() 같은 중간 연산을 정의해도, 실제로 그 연산이 실행되는 것은 최종 연산인 .collect()가 호출될 때라는 것이다.

### 2️⃣ for, stream 각각 적용 시 장단점

- 가독성

무엇을 할지 선언적으로 표현하고 의도가 명확히 드러난다는 점에서 stream 승

```java
// 전통적 방식
List<UserDTO> result = new ArrayList<>();
for (User user : users) {
    if (user.isActive()) {
        result.add(new UserDTO(user));
    }
}

// stream 방식
List<UserDTO> result = users.stream()
                            .filter(User::isActive)
                            .map(UserDTO::new)
                            .collect(Collectors.toList());

```

하지만 간단한 출력문 반복 등에서는 이중 for문을 사용하는 방식이 가독성이 더 좋다. 그래도 api 개발시에는 stream이 더 좋은 것은 맞는듯하다.

- 디버깅

프로그램 실행 중 예외(Exception)가 발생했을 때, **어디서 문제가 발생했는지** 

에러 스택 트레이싱 과정에서는 어떤게 좋을까

```java
users.stream()
     .filter(user -> user.getName().startsWith("A"))
     .map(UserDTO::new)
     .collect(Collectors.toList());

```

이 경우 예외 발생시 람다 내부의 코드 라인을 정확히 알려주지 않는다

```java
java.lang.NullPointerException
    at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:174)
    ...

```

stream 구현체에서 발생했다고만 로그가 뜰뿐, 어느 부분 어느 메소드 어느 라인에서 발생했는지 위치는 파악 힘들다.

반면 for문에서는

```java
for (User user : users) {
    if (user.getName().startsWith("A")) {
        result.add(new UserDTO(user));
    }
}

```

```java
java.lang.NullPointerException
    at com.example.service.UserService.getUsers(UserService.java:22)

```

정확한 코드 라인, 클래스를 파악 가능하다.

- 성능

-원시 데이터 ( ex)int, long .. )

성능은 stream보단 for loop가  좋은 편. 오래전부터 JVM에서 내부 최적화가 잘 되어왔지만, stream은 java 8 출시 시점인 2015년에 등장했기에 최적화가 아직 for문에 비해 잘 되어있지는 않다고 한다.

-참조 데이터 (String, ArrayList ..)

이 경우 for문이 더 좋긴하지만 시간 차이가 크게 발생하지 않는다.

ArrayList 순회 비용 자체가 매우 커 속도의 차이가 묻힌다고 한다.

### 3️⃣ 언제 적용?

-for문 

원시 타입의 데이터 반복시에는 → for문 사용

또한 실시간 데이터를 송출해야하는 상황에서는 성능을 우선적으로 고려하여 for문을 사용해야할 것 같다.

-Stream

개발자의 의도가 코드에서 보이기에 가독성이 올라가고 코드 간결성도 좋다.

또한 Spring에선 Optional, Lamda 등 함수형 프로그래밍을 많이 사용하기에 이 관점에서 Stream 사용이 더 적합해보인다.

또한 SRP 측면에서도 좋아 테스트 및 리팩토링에 유리하다는 장점이 있다.

이러한 이유에서 실무에서는 stream을 많이 사용한다고 한다.