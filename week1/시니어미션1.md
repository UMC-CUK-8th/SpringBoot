# 시니어 미션

- [ ]  미션 자료로 제공된 피그마를 보고 ERD를 설계한 후 제 1,2,3 정규화를 통해 제 1,2,3 정규형을 만들고 각각 중복된 데이터가 어떻게 변화하였고 어떠한 이점이 있었는 지 작성하여 주세요
    - 내용들을 간단하게 정리하여 주세요
        
        ![image.png](%E1%84%89%E1%85%B5%E1%84%82%E1%85%B5%E1%84%8B%E1%85%A5%20%E1%84%86%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%201b7b57f4596b81529f2ece13d3d17e38/image.png)
        
        ## 제 1 정규화 (1NF)
        
        모든 컬럼은 **원자값(atomic value)**만을 가져야 하며, **반복 속성 또는 배열 형태가 있으면 안 됨**
        
        ### 적용 전 (예상되는 나쁜 예시)
        
        - `food_category`에 **콤마로 구분된 여러 값**이 들어감 → 1NF 위반
        - 음식 카테고리는 **원자값이 아니며**, 반복 속성임
        
        ### 적용 후 (현재 ERD 구조)
        
        - `food_category`는 `User_FoodCategory` 테이블로 분리되어 1:N 관계로 표현됨
        - 모든 필드는 **하나의 값만 저장 (원자성)**
        
        ### 제1정규화의 이점
        
        | 항목 | 내용 |
        | --- | --- |
        |  중복 데이터 감소 | 여러 개의 값을 한 칸에 넣지 않음 |
        | 검색, 필터링 쉬움 | `JOIN`으로 명확하게 연결 가능 |
        |  확장성 향상 | 음식 카테고리 추가 시 구조 변화 없음 |
        
        ---
        
        # 제2정규화 (2NF)
        
        ### 정규화 조건
        
        > 기본키가 복합키인 경우, 일부 속성에만 종속된 컬럼이 없어야 한다.
        > 
        
        ---
        
        ### 적용 전
        
        - `user_name`은 `user_id`에만 종속되고, `foodcategory_id`에는 관련 없음
        - 즉, `user_id + foodcategory_id`가 복합키인데, 그 중 `user_id`에만 종속된 데이터가 존재 → 2NF 위반
        
        ### 적용 후 (현재 ERD 구조)
        
        - `user_name`은 `User` 테이블에 있고, `User_FoodCategory`는 관계만 담당
        - **부분 종속 제거**, 관계 표현만 분리
        
        ### 제2정규화의 이점
        
        | 항목 | 내용 |
        | --- | --- |
        |  데이터 정합성 증가 | 정보가 하나의 테이블에만 존재 |
        |  중복 제거 | `user_name`을 관계 테이블에 중복 저장하지 않음 |
        |  테이블 역할 명확 | 관계 테이블은 관계만, 속성은 속성 테이블에만 존재 |
        
        ---
        
        # 제3정규화 (3NF)
        
        ### 정규화 조건
        
        > 기본키가 아닌 속성이, 또 다른 기본키가 아닌 속성에 종속되면 안 됨.
        > 
        
        ---
        
        ### 🔍 적용 전 (가상의 예시)
        
        - `region_name`은 `region_id`에 종속, `region_id`는 `Store.id`에 종속 → **이행적 종속 발생**
        
        ### 적용 후 (현재 ERD 구조)
        
        - `region_name`은 별도의 테이블(`Region`)로 분리되어, `region_id`를 통해 참조
        - 모든 **비키 속성은 기본키에 직접 종속**
        
        ### 제3정규화의 이점
        
        | 항목 | 내용 |
        | --- | --- |
        | 중복 최소화 | `region_name`이 여러 가게에 반복 저장되지 않음 |
        |  변경 용이성 | 서울 → 수도권으로 바뀌면 Region 테이블 하나만 수정하면 됨 |
        | 검색 정밀도 향상 | 지역별 필터링, 통계 집계 용이 |
        

- [ ]  피그마의 홈 부분에서 한 사람이 “미션 도전!” 버튼을 빠르게 여러 번 눌렀을 때 여러 가지 이유(비동기 로직 등)로 요청이 지연되어 완전히 처리하기 전 두 번 요청이 들어갈 수 있습니다. 이를 해결할 수 있는 방법에 대해 작성하여 주세요 (ERD 직접적으로 관련이 있기보다는 설계할 때 한번쯤 고민해보면 좋을 것 추가시켜 놓았습니다) (다양한 방법이 있으니 찾아봐 주세요)
    - 내용들을 간단하게 정리하여 주세요
        
        “미션 도전!” 버튼을 빠르게 여러 번 눌렀을 때 여러 가지 이유(비동기 로직 등)로 요청이 지연되어 완전히 처리하기 전 두 번 요청이 들어가는 문제를 워크북에서 제시해주고 있는데
        
        다른 관점에서 짧은 순간에 너무 많은 요청이 들어오면 서버 혹은 특정 자원이 과부하가 걸리는 상황도 생긴다 . 이때는 다음과같은 처리율 제한 장치를 도입하는 것도 고려해봐야할 것이다. 
        
        - **Token Bucket/Leaky Bucket 알고리즘**, **Sliding Window** 등을 캐시나 DB에서 구현
        - Nginx, API Gateway, Cloudflare 같은 인프라 레벨에서 Rate Limiting 설정
        
        [전에 정리했던 내용들](https://www.notion.so/183947e3ca8c80a7b343ebbe47d72254?pvs=21)
        
        그래도 워크북에서 제시한 내용만 적을래요,,
        
        # 1. DB 차원
        
        일단 DB 차원의 동시성 제어에 대해 정리해보겠다.
        
        동시성으로 발생하는 문제를 고민하기 전에 “두 번의 갱신 분실 문제” 에 대해 먼저 알아보자.
        
        ## 두번의 갱신 분실 문제
        
        → 두 트랜잭션에서 데이터를 변경하였을 때, 최종적으로 한 트랜잭션의 결과만 남는 것을 의미함.
        
        ![image.png](%E1%84%89%E1%85%B5%E1%84%82%E1%85%B5%E1%84%8B%E1%85%A5%20%E1%84%86%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%201b7b57f4596b81529f2ece13d3d17e38/image%201.png)
        
        - **상황**: A 사용자는 계좌에서 돈을 출금하고, B 사용자는 같은 계좌에 저축을 하는 동작을 거의 동시에 처리
        - **결과**: A의 출금 연산이 기록되기 전에 B의 저축 연산이 DB의 최종 상태를 덮어써서, A가 출금한 결과가 아예 사라짐
        
        이런 문제는 단순 트랜잭션 격리 수준만으로는 방지하기 어렵고, 추가적인 동시성 제어(락 등)가 필요함. JPA에선 **비관적 락**과 **낙관적 락**이라는 두 가지 방식으로 두 번의 갱신 분실을 예방할 수 있음
        
        ---
        
        ## 비관적 락 (Pessimistic Lock)
        
        ### 1) 기본 아이디어
        
        - **충돌이 발생할 가능성이 높다고 가정**하고, 트랜잭션 시작 시점 혹은 데이터 조회 시점에 **DB 락**을 걸어버리는 방식.
        - 락이 걸려 있는 동안, 다른 트랜잭션은 해당 데이터를 수정하거나 읽지 못하도록 막거나 지연시킬 수 있음.
        
        ### 2) 락 종류
        
        - **Shared Lock(공유 락, S Lock)**: 주로 `SELECT … FOR SHARE`같은 구문에서 적용되며, 여러 트랜잭션이 동시에 읽기는 가능하지만, 쓰기는 제한됩니다.
        - **Exclusive Lock(배타 락, X Lock)**: `SELECT … FOR UPDATE`, `UPDATE`, `DELETE` 등에서 사용되며, 한 트랜잭션이 배타 락을 잡으면 다른 트랜잭션은 해당 행에 대한 **읽기와 쓰기 모두**가 제한되거나 대기 상태가 됩니다.
        
        ### 3) JPA 사용 예시: `LockModeType`
        
        JPA에선 `@Lock` 어노테이션과 함께 특정 메서드에 `LockModeType`을 지정할 수 있음.
        
        ```java
        public interface AccountRepository extends JpaRepository<Account,Long>{
        	
        	@Lock(value=LockModeType.OPTIMISTIC)
        	Optional<Account> findByName(String name);
        	
        }
        ```
        
        - `PESSIMISTIC_READ`: 다른 트랜잭션이 해당 데이터를 수정하지 못하게 **공유 락**을 걸어둠. (잘 사용하지 않음)
        - `PESSIMISTIC_WRITE`: 일반적으로 가장 많이 사용하는 옵션으로, **배타 락**을 걸어 **수정**을 독점함. SELECT … FOR UPDATE 를 통해 사용.
        - `PESSIMISTIC_FORCE_INCREMENT`: 버전을 함께 사용하면서 버전 정보를 강제로 증가시키는 방식 (낙관적 락의 버전 관리와 유사한 면이 있음)
        
        **장점**: 락을 통해 **동시 갱신 충돌**을 즉시 막을 수 있어, 무결성을 확실히 보장할 수 있음.
        
        **단점**: DB 차원의 락으로 인해 **성능 저하**나 **병목**이 발생하기 쉬워, 트랜잭션이 길어지면 서비스 전체가 느려질 수 있음.
        
        ---
        
        ## 낙관적 락(Optimistic Lock)
        
        ### 1) 기본 아이디어
        
        - 대부분의 트랜잭션이 동시에 같은 데이터를 갱신하는 일이 많지 않다고 **낙관적으로** 보는 방식임.
        - DB 레벨의 락 대신, **애플리케이션 레벨**에서 **버전 관리**나 **검증**을 수행해, 나중에 충돌 여부가 판명나면 **롤백**하거나 **예외**를 발생시킴.
        
        ### 2) @Version을 통한 버전 관리
        
        - 엔티티에 `@Version` 필드를 선언하면, JPA는 엔티티 조회 시점에 **버전 번호**를 기억해두었다가, 트랜잭션이 커밋될 때 현재 버전과 **비교**합니다.
        - 만약 커밋 순간에 **버전이 바뀌어 있으면**, 이미 다른 트랜잭션이 데이터를 갱신한 것으로 판단하고 **OptimisticLockException**을 던집니다.
        - 이로써 동시에 여러 트랜잭션이 갱신 요청을 해도, 한 쪽이 먼저 성공하면 나중 요청은 버전 불일치로 실패하게 됩니다.
        
        ### @Version 필드 규칙
        
        - 엔티티당 하나의 버전 필드만 가능
        - int, Integer, long, Long, short, Short, Timestamp 등으로 선언 가능
        - **직접** 버전을 수정하면 안 되며,(탐색은 가능) JPA가 자동으로 증분 처리함
        
        ```java
        @Entity
        @NoArgsConstructor
        public class Account {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
            private String name;
            private Long money;
            @Version
            private int version;
            public Account(String name, Long money) {
                this.name = name;
                this.money = money;
            }
        }
        ```
        
        ### 3) 낙관적 락 모드
        
        - `LockModeType.(NONE)`
            - 엔티티에 버전필드가 존재하는데 락 모드가 정의되지 않았다면 적용되는 옵션
            - 조회한 엔티티를 수정하는 시점에 다른 트랜잭션으로부터 변경되지 않음을 보장.
        - `LockModeType.OPTIMISTIC`
            - NONE의 경우 엔티티를 수정할 때만 버전을 체크하지만 해당 옵션을 추가하면 엔티티를 조회만 해도 버전을 체크한다.
            - 즉, 한 번 조회한 엔티티는 종료할 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다.
            - READ 타입과 동일하다.
        - `LockModeType.OPTIMISTIC_FORCE_INCREMENT`
            - 낙관적 락을 사용하며 버전 정보를 항상 강제로 증가시킨다.
            - 엔티티가 물리적으로 변경되지 않았지만 논리적으로 변경 되었을 때, 버전 정보를 증가시킬 수 있다. → 논리적인 단위로 엔티티를 관리할 때 사용한다.
                - e.g. 1:N 관계의 엔티티에서 1의 변화는 없는데 N에 데이터가 추가되거나 제거된 경우, 1에는 물리적인 변화가 없지만 논리적인 변화가 일어난 것이다. 이런 경우에도 버전을 변경할 수 있다.
            - WRITE 타입과 동일하다.
            
        
        **장점**: DB에 락을 걸지 않으므로, 충돌이 적은 상황에서는 **높은 성능** 유지가 가능
        
        **단점**: 실제로 충돌이 자주 일어나는 경우, 예외와 재시도가 빈번히 일어나면서 **오히려 오버헤드**가 커짐.
        
        ---
        
        ## 분산락
        
        1. **분산락(Distribution Lock) 개념**
        
        1.1 **분산 환경에서의 동시성 문제**
        
        단일 서버에서는 `synchronized`나 DB 락(낙관적/비관적 락)만으로도 어느 정도 동시성 제어 가능함.
        
        근데 서버를 여러 대로 확장(분산)해버리면, 서버 간 공유 리소스(DB의 특정 row, 파일, 캐시 등)에 동시에 접근할 때 단순 로컬 락만으로 해결 어려워짐.
        
        1.2 **분산락의 역할**
        
        분산락은 락 정보를 Redis, Zookeeper, MySQL 같은 외부 저장소에 저장해두고, 여러 서버가 동일 자원에 접근하려 할 때 “오직 한 프로세스만” 진입할 수 있게 막아줌.
        
        즉, 분산된 서버 환경에서도 임계 구역(Critical Section)에 진입하려면 반드시 락 획득 과정을 거치도록 해서, 중복 갱신이나 두 번의 갱신 분실 같은 문제를 방지함.
        
        1. **분산락 vs 낙관적/비관적 락**
        
        2.1 **낙관적 락 / 비관적 락도 분산 환경에서 쓰면 되지 않을까?**
        
        보통 Write DB는 1대로만 운용하고, 여러 서버가 그 DB로 쓰기 요청을 보내는 구조가 많아서, DB 락만으로도 어느 정도 정합성 유지 가능함.
        
        근데 1:N 관계에서 “1은 안 바뀌는데, N만 추가되는” 상황처럼 실제로는 변경 없는 테이블에 락을 거는 건 꽤 어색.
        
        또, DB 행 단위가 아니라 특정 로직이나 자원(파일, 공유 메모리 등)에 락을 걸어야 할 수도 있음.
        
        2.2 **분산락 활용 시점**
        
        DB 자체를 건드리지 않고, Redis 같은 외부 저장소에 Lock 상태를 저장해두고 임계 구역에 접근할 때마다 락을 요청/해제하는 방식 사용 가능함.
        
        이러면 DB에서 불필요하게 `SELECT FOR UPDATE` 같은 걸 남발하거나, 실제 변경 없는 테이블에 락을 거는 문제 피할 수 있음.
        
        큰 틀에서 보면, 분산락은 낙관적/비관적 락과는 다른 계층에서 동작해 비즈니스 로직 자체를 보호하는 장치라 볼 수 있음.
        
        ---
        
        1. **Redis로 분산락 구현하기**
            
            Redis 기반 분산락은 크게 **Lettuce**를 이용한 단순 스핀락 방식과, **Redisson**을 통한 메시지 브로커(Pub/Sub) 방식으로 나뉨.
            
        
        **3.1 Lettuce를 이용한 스핀락**
        
        - **원리**
            - Redis의 `SETNX`(Set if Not eXists) 명령어 사용. “key(=파티 id)”가 없으면 생성 & 락 획득, 있으면 실패로 간주.
            - 락을 얻을 수 있을 때까지 계속 Redis에 락 획득 시도(스핀)
        - **장점**
            - 구현 단순 (직접 `setIfAbsent()` 호출)
        - **문제점**
            - 계속 Redis에 요청을 보내므로 서버 부하 증가.
            - `SETNX`만으론 만료 시간 설정 힘들어, 예상치 못한 에러로 락이 영구 미해제될 수도 있음(데드락).
            - 해결책으로 `setIfAbsent(key, value, Duration timeout)` 같은 방식이나 만료 설정을 직접 해야 함.
        
        **3.2 Redisson을 통한 메시지 브로커 방식**
        
        - **원리**
            - Redisson은 Redis Pub/Sub를 활용해 락 해제 이벤트가 발생하면 구독 중인 클라이언트에게 알려줌.
            - 클라이언트는 락 해제 시점에만 재시도하므로, Lettuce 스핀락처럼 무한 반복으로 Redis를 괴롭히지 않음.
        - **장점**
            - `tryLock(waitTime, leaseTime, TimeUnit)`을 통해 락 획득 대기 시간, 자동 만료 시간 설정 가능.
            - leaseTime 지나면 자동 해제돼, 데드락 가능성 낮춤.
            - 락 해제 이벤트 기반이라 Redis 부하가 훨씬 적음.
            
        
        ---
        
        ## DB 제약 조건 + 트랜잭션 (by GPT)
        
        ~~이걸로만 해결하는 사례를 많이 보지 못해서 안적으려다가 gpt님이 알려주셔서 넣어봅니다.~~
        
        DB에 특정 컬럼 조합에 대해 **Unique Key**를 설정해두고, 같은 요청이 트랜잭션 내에서 여러 번 발생하면 DB에서 **Unique Key 예외**가 남.
        
        이 방법은 **간단**하나, DB 예외 처리를 통해 중복임을 인지해야 하므로 개발 편의성 측면에서 예외 처리 로직이 추가됨.
        
        ---
        
        # 애플리케이션 차원
        
        중복 요청에 대해서 ‘멱등성’을 보장하자
        
        ### 멱등성
        
        → 첫 번째 수행을 한 뒤 여러 차례 적용해도 결과를 변경시키지 않는 작업 또는 기능의 속성을 뜻함. 즉 멱등한 작업의 결과는 한 번 수행하든 여러 번 수행하든 같음.
        
        멱등성을 보장하는 시간과 요청이 중복되었음을 판단할 요청의 식별자, 즉 멱등키가 필요함
        
        ### 멱등키
        
        멱등키의 저장되는 특성을 살펴보면 다음과 같음
        
        - 동선 생성은 비즈니스적으로 잦게 요청된다.
        - n초 주기로 동선 생성 요청이 올 때마다 새로운 멱등키를 생성해야 한다.
        - 동선 생선 요청 시마다 멱등키를 조회해야한다.
        - 멱등키는 다른 비즈니스 데이터와 별다른 관계를 가지지 않는다.
        
        그럼 이 멱등키를 저장할 DB도 고려해볼 수 있는데 Redis 까지 생각해볼 수 있음.
        
        why? ( 모두가 다 그렇다는 건 아님)
        
        - **저장되는 멱등키의 특성이 Redis에 더 적합하다.**
            - 데이터 접근이 잦다.
            - 다른 비즈니스 데이터와 별다른 관계를 갖지 않는다.
        - **동시 요청으로 멱등키를 저장할 때 성능 측면에서 Redis가 적합하다. (동시성 처리 시 성능)**
            - 첫 요청 시 사용자가 여러번 빠르게 버튼을 누르게 되면 동시 요청으로 멱등키 저장이 되는 상황
            - 이러한 동시성 부분은 Lock을 통해서 해결
            - RDB의 Lock은 비관적 락을 사용할 텐데 처리 성능이 Redis가 인메모리 DB이므로 더 빠르다.
        - **멱등키의 조회 부하가 다른 데이터에 영향을 미친다.**
            - RDB에 저장하게 된다면, 잦은 조회가 발생하는 멱등키의 조회 부하 때문에 다른 데이터 Write/Read 성능에 영향을 미친다.
        
        ---
        
        [참고]
        
        - [레디스와 분산 락(1/2) - 레디스를 활용한 분산 락과 안전하고 빠른 락의 구현](https://hyperconnect.github.io/2019/11/15/redis-distributed-lock-1.html)
        - [[Redis] 분산락(Distribution Lock) 을 구현해 다중화 서버에서 발생하는 동시성 문제 제어하기](https://velog.io/@msung99/Redis-%EB%B6%84%EC%82%B0-%EB%9D%BD%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%B4-race-condition-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0)
        - [Redis로 분산 락을 구현해 동시성 이슈를 해결해보자!](https://hudi.blog/distributed-lock-with-redis/)
        - [MySQL을 이용한 분산락으로 여러 서버에 걸친 동시성 관리 | 우아한형제들 기술블로그](https://techblog.woowahan.com/2631/)
        - [What is a Java distributed lock? | Redisson](https://redisson.org/glossary/java-distributed-lock.html)
        - [6.2 Distributed locking | Redis](https://redis.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-2-distributed-locking/)
        - [[개발자유주제 1편] 데이터 동시성 접근 문제가 발생했을 때 해결 방안 (DB lock, Redis)](https://insanelysimple.tistory.com/396)
        - [Introduction to Lettuce - the Java Redis Client | Baeldung](http://baeldung.com/java-redis-lettuce)
        - [redis 설치 및 redisson을 이용한 분산락 구현](https://it-hhhj2.tistory.com/102)