# 시니어 미션

- [ ]  Soft Delete가 무엇인지 찾아보시고 soft delete에는 어떠한 HTTP Method가 들어가면 좋을지 적어주세요
    - 
        - soft delete란?
        
        데이터베이스에서 데이터를 삭제하지 않고, 사용자 입장에서 접근할 수 없게 하는 방식. 흔히 테이블에 is_deleted 칼럼을 만들어 사용여부를 결정하는 방식이다.
        
        - hard delete?
        
        데이터베이스에서데이터를 직접 삭제하는 방식
        
        그렇다면 왜 soft delete를 사용하는걸까?
        
        1. 더 이상 사용하지 않을 데이터라도 실제 서비스 운영시 개선을 위해  분석해볼 필요가 있음.
        2. 데이터 복구가 필요한 상황을 염두에 둠.
        3. 다른 테이블에서 해당 데이터를 참조하는 경우, 삭제하면 참조 무결성 문제가 발생할 수 있음. 
        4. update 쿼리가 delete 쿼리보다 빨라 성능에도 도움됨.
        
        하지만 역시 단점도 존재한다.
        
        1. is_deleted 컬럼을 추가해 테이블 복잡성 증가
        2. 사용되지 않을 데이터가 db에 남아있기에 용량 및 부하 증가
        3. 쿼리 작성시 복잡성 증가
        4. 민감한 데이터가 남아있으면 보안 이슈 발생 가능
        
        soft delete는 다른 데이터와 연관되어 있는 경우가 많은 사용자 정보나 감사가 중요한 시스템에 적용하면 좋을 것 같고, hard delete 는 민감한 개인정보(금융, 의료 등)를 다루는 시스템에서 적용되면 좋을 것 같다.
        
        현업에서는 우선 soft delete로 관리하다 일정 기간이 지나면, 데이터를 물리적으로 사용하는 경우도 많다고 한다. 
        
        -어떤 http 메소드를 적용?
        
        결국 클라이언트 입장에서 리소스가 삭제된 것으로 인식해야하고, Restful 설계 관점에서도 Delete를 사용하는 것이 직관적이라 생각된다. 
        
        -spring에서의 사용법
        
        - **@SQLDelete**
        
        jpa를 사용할 경우 orm 딴에서 delete 쿼리를 update 쿼리로 대체해주는 기능.
        
        ```java
        @Entity
        @Table(name = "user")
        @SQLDelete(sql = "UPDATE user SET is_deleted = true WHERE id = ?")
        @Where(clause = "is_deleted = false")
        public class User {
            
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
        
            private String username;
        ```
        
        - **@Where**
        
        모든 조회 쿼리에 자동으로 조건을 추가하여, 삭제되지 않은(is_deleted = false) 레코드만 가져오도록 함.
        
        해당 
        
        어노테이션을 적용하면,
        
        ```java
        @Where(clause = "is_deleted = false")
        ```
        
        Hibernate는 해당 엔티티를 조회할 때마다 자동으로 "WHERE is_deleted = false" 조건을 추가
        
        하지만 이 방법은 의존성이 너무 강력해 기능 구현시 문제가 발생가능해보여 상황에 맞게 잘 적용해야할 것 같다.
        
        [[개발/Spring] Soft delete vs Hard delete에 대한 나의 생각](https://resilient-923.tistory.com/419)
        

- [ ]  컨트롤 URI에 대해 조사해주시고 어떠할 때 사용이 가능한 지 예시를 들어 설명해주세요.
    - 
        
        -컨트롤 URI란?
        
        특정 http메소드로 행위를 나타내기 어려운 경우 사용됨. 
        
        단순한 데이터 변경을 넘어 프로세스를 처리하는 경우에 사용된다
        
        restful 원칙을 조금 벗어나 동사를 직접 사용하기도 한다.
        
        ex) 결제 처리 , 검증 등
        
        POST: api/payments/process
        
    
     
    

- [ ]  https://learn.microsoft.com/ko-kr/azure/architecture/best-practices/api-design - 문서를 읽고 주요 내용을 간단히 정리해주세요.
    - 
        
        **REST란?**
        
        REST는 하이퍼미디어 기반 분산 시스템을 구축하기 위한 아키텍처 스타일
        
         어떤 기본 프로토콜과도 독립적이며 HTTP에 연결될 필요가 없지만, 대부분의 일반적인 REST API 구현은 HTTP를 애플리케이션 프로토콜로 사용
        
        REST API는 *리소스*를 중심으로 디자인
        리소스마다 해당 리소스를 고유하게 식별하는 URI인 *식별자가 존재.*
        
        HTTP 기반의 REST API의 경우 표준 동사 수행작업인 GET, POST, PUT, PATCH, DELETE를 사용.
        
        HTTP 요청은 독립적이어야 하며 어떤 순서로든 발생할 수 있으므로 요청 간에 일시적인 상태 정보를 유지하는 것은 불가능해 정보는 리소스 자체에만 저장됨 → 서비스 확장성 우수
        
        리소스 URI를 *컬렉션/항목/컬렉션*보다 더 복잡하게 요구하지 않는 것이 좋다.
        
        - **GET**은 지정된 URI에서 리소스의 표현을 검색. 응답 메시지의 본문은 요청된 리소스의 세부 정보를 포함.
        - **POST**는 지정된 URI에 새 리소스를 만듦. 요청 메시지의 본문은 새 리소스의 세부 정보를 제공. 참고로 POST를 사용하여 실제로 리소스를 만들지 않는 작업을 트리거할 수 있음.
        - **PUT**은 지정된 URI에 리소스를 만들거나 대체. 요청 메시지의 본문은 만들 또는 업데이트할 리소스를 지정.
        - **PATCH**는 리소스의 부분 업데이트를 수행. 요청 본문은 리소스에 적용할 변경 내용을 지정.
        - **DELETE**는 지정된 URI의 리소스를 제거
        
        ### 비동기 작업
        
        클라이언트에 응답을 보내기 전에 완료될 때까지 기다리는 경우 허용할 수 없는 대기 시간이 발생 가능. 이 경우 비동기 작업을 고려 가능. 요청 처리가 수락되었지만 아직 완료되지 않았음을 나타내는 HTTP 상태 코드 202(수락됨)를 반환.
        
        ### **HATEOAS**
        
         URI 체계에 대해 미리 알고 있지 않아도 전체 리소스 집합을 탐색할 수 있어야함. 이 원칙을 **HATEOAS**(Hypertext as the Engine of Application State)라고 함.
        
        ### URI 버전 관리
        
        웹 API를 수정하거나 리소스의 체계를 변경할 때마다 각 리소스의 URI에 버전 번호를 추가
        
        ex) [https://adventure-works.com/v2/customers/3](https://adventure-works.com/v2/customers/3)
        
        모든 링크가 자신의 URI에 버전 번호를 포함해야 하므로 HATEOAS 구현을 복잡하게 만든다.
        
        그 외에도 쿼리 문자열이나 헤더로 버전 관리를 하는 방법이 있음
        
        ```java
        GET https://adventure-works.com/customers/3 HTTP/1.1
        Custom-Header: api-version=1
        ```