# 시니어 미션

**미션 목표:**

- 기존 본인이 진행했던 프로젝트에서 JPA와 QueryDSL을 활용하면서 발생할 수 있는 **성능 병목을 파악하고 해결책을 제시**하세요.

**미션 상세 내용:**

1️⃣ `spring.jpa.show-sql=true` & `logging.level.org.hibernate.SQL=DEBUG` 활성화하여 실행된 SQL 로그 분석

- 특정 API 호출 시 실행된 **SQL 쿼리 로그를 분석**하고 실행 속도가 느린 쿼리를 찾으세요.
- 불필요한 쿼리가 실행되거나 **JOIN이 과도하게 발생하는 경우** 원인을 분석하세요.

2️⃣ 성능 병목이 발생한 코드(쿼리)를 **QueryDSL 기반으로 최적화**

- `@Query`로 작성된 복잡한 SQL을 QueryDSL로 리팩토링하여 실행 속도를 비교하세요.
- `@Transactional(readOnly = true)` 적용 여부에 따른 실행 속도 차이도 테스트해보세요.

3️⃣ `배치 크기(Batch Fetch Size)` 조절을 통한 성능 비교

- `@BatchSize(size = 100)` 설정 후, **쿼리 실행 횟수 변화 확인을 로그로 남겨보세요.**
- `fetch join`을 사용한 경우와 비교하여 성능 차이를 분석해보세요.

4️⃣ 최적화 적용 후, 성능 향상 결과 정리

- 실행 속도가 개선된 SQL 로그를 비교하고, 어떤 부분이 최적화되었는지 설명하세요.
- **실제 애플리케이션에서 적용할 최적화 전략을 정리**하세요.

## 성능 병목 지점 분석

### 1. N+1 문제 발생 지점

**FollowService의 getFollowings메서드**

```java
 @Override
  @Transactional
  public List<FollowDTO.FollowingResponseDTO> getFollowings(Long userId) {
    UserEntity user = findUserById(userId);

    return followingRepository.findByUserId(userId).stream()
        .map(following -> FollowConverter.toFollowingResponseDTO(
            following.getFollowing()
        ))
        .collect(Collectors.toList());
  }

```

위 코드는 다음과 같은 문제점이 있습니다

Following, Follower Entity에서 UserEntity와의 관계는 ManyToOne(fetch=FetchType.LAZY)로 설정

→ stream map() 과정에서 getFollowing or getFollower 호출시마다 각각의 UserEntity에 대해

    별도의 SQL 쿼리 발생 가능 

### 2. 반복문에서 문제 발생

```java
followers.stream()
    .map(f -> FollowConverter.toFollowerResponseDTO(f.getFollower()))
```

- `f.getFollower()` → **`UserEntity`를 DB에서 개별 쿼리로 추가 조회**
- `FollowConverter` 내부에서 `userEntity.getProfileImage()` → **또 다른 쿼리** (ProfileImage는 `UserEntity`의 `@OneToOne(fetch = LAZY)`)

### 문제 발생 이유

구조에서 다음과 같은 쿼리 문제 발생

1. SELET * FROM follower WHERE user_id = ?
2. SELECY * FROM user WHERE id = ?
3. SELECT * FROM profile_image WHERE user_id = ?

**→ 총 1 + N + N → 2N + 1번의 쿼리 발생**

결국, 팔로워 수가 많아질수록 성능 급격히 저하됨

## 해결책

Repository단에서 fetch JOIN

```java
@Query("SELECT f FROM Follower f " +
       "JOIN FETCH f.follower u " +
       "LEFT JOIN FETCH u.profileImage " +
       "WHERE f.user.id = :userId")
List<Follower> findWithFollowerAndProfileImageByUserId(@Param("userId") Long userId);
```

- `Follower`와 `UserEntity follower`, `UserEntity.profileImage`까지 **한 쿼리로 모두 JOIN**
- LAZY 문제 제거 → N+1 문제 해결

## 최종 메서드

```java
@Override
@Transactional
public List<FollowDTO.FollowerResponseDTO> getFollowers(Long userId) {
    UserEntity user = findUserById(userId);

    // fetch join 쿼리 사용
    List<Follower> followers = followerRepository.findWithFollowerAndProfileImageByUserId(userId);

    return followers.stream()
        .map(follower -> FollowConverter.toFollowerResponseDTO(
            follower.getFollower()
        ))
        .collect(Collectors.toList());
}
```

Follower + UserEntity + ProfileImage 모두 한 번에 JOIN

→ 쿼리 단 1번

JPA와 QueryDSL을 활용한 성능 최적화를 통해

- N+1 문제를 해결하여 쿼리 수 감소
- 필요한 데이터만 효율적으로 조회
- 트랜잭션 관리 최적화로 리소스 사용 효율화