# 제목 없음

### **SQL 로그 분석 예시 (성능 병목 발견)**

```sql

select * from post p;
select * from member m where m.id = ?;  -- N+1 발생
select * from comment c where c.post_id = ?;

```

- 문제: 게시글(Post)을 조회할 때 작성자(Member)와 댓글(Comment)을 각각 추가 조회 (N+1 발생).

---

### **QueryDSL로 최적화 (Fetch Join 사용)**

```java

public List<Post> findAllWithMemberAndComments() {
    return queryFactory
        .selectFrom(post)
        .join(post.member, member).fetchJoin()
        .leftJoin(post.comments, comment).fetchJoin()
        .fetch();
}
```

- 해결: Fetch Join으로 한 번에 Post, Member, Comment 조회.
- 주의: `distinct` 필요할 수 있음 (중복 Row 제거).

---

### **Batch Fetch Size 적용 (지연로딩 최적화)**

```java

@Entity
public class Post {
    @ManyToOne(fetch = FetchType.LAZY)
    @BatchSize(size = 100)
    private Member member;

    @OneToMany(mappedBy = "post")
    @BatchSize(size = 100)
    private List<Comment> comments;
}
```

- 설정 추가:

```
spring.jpa.properties.hibernate.default_batch_fetch_size=100
```

- 효과: Lazy Loading 시 IN 절로 한 번에 여러 엔티티 로딩.

### **BrainPix 프로젝트에서의 최적화 전략**

- 조회 화면: Fetch Join 적극 사용, 필요시 Pagination 주의.
- 리스트 & 상세 분리: 목록 조회 시 DTO 프로젝션으로 필요한 필드만 가져오기.
- 대용량 컬렉션: `BatchSize` + Lazy Loading 조합.
- 트랜잭션 최적화: `@Transactional(readOnly = true)` 적극 사용