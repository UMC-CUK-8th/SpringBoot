# UMC 2주차

## 실전 SQL - 어떤 Query를 작성해야 할까?

1. 내가 진행중, 진행 완료한 미션 모아서 보는 쿼리 (페이징 포함)

```sql
SELECT 
  um.id AS user_mission_id,
  um.user_id,
  m.id AS mission_id,
  m.title,
  m.status
FROM user_missions AS um
JOIN missions AS m ON um.mission_id = m.id
WHERE um.user_id = :userId
  AND m.status IN ('IN_PROGRESS', 'COMPLETED')
ORDER BY m.created_at DESC
LIMIT :pageSize OFFSET ((:pageNumber - 1) * :pageSize);

```

- **FROM 및 JOIN 구문**
    
    **`user_missions AS um`:**
    
    사용자가 참여한 미션 기록을 담고 있는 테이블로, `um`이라는 별칭을 부여하여 간단하게 참조.
    
    **`JOIN missions AS m ON um.mission_id = m.id`:**
    
    `user_missions`에 기록된 미션의 상세 정보를 가져오기 위해 `missions` 테이블과 조인.
    
    여기서 `um.mission_id`와 `m.id`를 매칭시켜, 각 참여 기록에 해당하는 미션 정보를 결합.
    
- **SELECT 구문**
    
    **`um.id AS user_mission_id`:**
    
    사용자 미션 참여 기록의 고유 아이디를 조회하며, 결과 컬럼명을 `user_mission_id`로 지정.
    
    **`um.user_id`:**
    
    참여한 사용자의 ID.
    
    **`m.id AS mission_id, m.title, m.status, m.created_at`:**
    
    해당 미션의 아이디, 제목, 상태, 생성일자를 조회.
    
- **WHERE 구문**
    
    **`um.user_id = :userId`:**
    
    해당 사용자의 ID로 데이터 필터링.
    
    **`AND m.status IN ('IN_PROGRESS', 'COMPLETED')`:**
    
    미션의 상태가 **진행 중**이거나 **완료**인 경우만 선택.
    
- **ORDER BY 구문**
    
    **`ORDER BY m.created_at DESC`:**
    
    미션 생성일을 기준으로 내림차순 정렬. 가장 최근에 생성된 미션이 먼저 나오도록.
    
- **LIMIT 및 OFFSET 구문 (페이징 처리)**
    
    **`LIMIT :pageSize OFFSET ((:pageNumber - 1) * :pageSize)`:**
    
    한 페이지에 보여줄 최대 건수를 `:pageSize`로 제한하고, 현재 페이지 번호(`:pageNumber`)에 따라 시작 위치를 계산하여 해당 페이지의 결과만 반환.
    
    (ex: 페이지 번호가 2이면, 첫 페이지의 레코드 수만큼 건너뛰고 2페이지의 결과를 가져옴.)
    

1. 리뷰 작성하는 쿼리,
(* 사진의 경우는 일단 배제)

```sql
INSERT INTO reviews (
  user_id,
  store_id,
  rating,
  comment
) VALUES (
  :userId,
  :storeId,
  :rating,
  :comment
);
```

1. 홈 화면 쿼리
(현재 선택 된 지역에서 도전이 가능한 미션 목록, 페이징 포함)

```sql
SELECT 
  m.id AS mission_id,
  m.title,
  m.status,
  r.id AS restaurant_id,
  r.name AS restaurant_name,
  r.area,
  m.created_at
FROM missions AS m
JOIN Restaurants AS r ON m.restaurant_id = r.id
WHERE r.area = :selectedArea
  AND m.status = 'AVAILABLE'
  AND m.id NOT IN (
    SELECT mission_id
    FROM user_missions
    WHERE user_id = :userId
  )
ORDER BY m.created_at DESC
LIMIT :pageSize OFFSET ((:pageNumber - 1) * :pageSize);

```

- **SELECT 구문:**
    
    `m.id AS mission_id, m.title, m.status, m.created_at`:
    
    **missions** 테이블에서 미션의 아이디, 제목, 상태, 생성일자를 선택.
    
    `r.id AS restaurant_id, r.name AS restaurant_name, r.area`:
    
    **Restaurants** 테이블에서 아이디, 이름, 지역(area)을 선택.
    
- **FROM 및 JOIN 구문:**
    
    `FROM missions AS m`:
    
    미션 정보를 담고 있는 **missions** 테이블을 `m`이라는 별칭으로 사용.
    
    `JOIN Restaurants AS r ON m.restaurant_id = r.id`:
    
    missions와 **Restaurants** 테이블과 조인.
    
    여기서 `m.restaurant_id`는 해당 미션과 연결된 레스토랑의 ID이며, `r.id`와 매칭됨.
    
- **WHERE 구문:**
    
    `r.area = :selectedArea`:
    
    현재 사용자가 선택한 지역(:selectedArea)와 일치하는 레스토랑만 조회.
    
    `AND m.status = 'AVAILABLE'`:
    
    미션 상태가 'AVAILABLE'인 경우에만 조회하여, 아직 도전 가능한 미션만 선택.
    
    `AND m.id NOT IN ( SELECT mission_id FROM user_missions WHERE user_id = :userId )`:
    
    서브쿼리를 통해 해당 사용자가 이미 참여한 미션의 ID를 가져와, 그 미션들은 결과에서 제외.
    
    사용자가 도전하지 않은 미션만 보여주기 위한 필터 역할.
    
- **ORDER BY 구문:**
    
    `ORDER BY m.created_at DESC`:
    
    미션이 생성된 날짜를 기준으로 내림차순 정렬.
    
    가장 최근에 생성된 미션이 먼저 표시됨.
    
- **페이징 처리 (LIMIT 및 OFFSET):**
    
    `LIMIT :pageSize`: 한 페이지에 보여줄 최대 미션 건수를 제한.
    
    `OFFSET ((:pageNumber - 1) * :pageSize)`:
    
    페이지 번호에 따라 결과의 시작 위치를 계산.
    
    예를 들어, 페이지 번호가 2이면 첫 페이지의 미션 건수만큼 건너뛰고 2페이지의 미션 목록을 가져옴.
    

1. 마이 페이지 쿼리

```sql
SELECT 
  u.id,
  u.email,
  u.name,
  u.phone,
  u.address,
  u.point,
  u.food_category,
  u.created_at,
  (SELECT COUNT(*) FROM user_missions AS um WHERE um.user_id = u.id) AS mission_count,
  (SELECT COUNT(*) FROM reviews AS r WHERE r.user_id = u.id) AS review_count,
  (SELECT COUNT(*) FROM alarms AS a WHERE a.user_id = u.id) AS alarm_count
FROM users AS u
WHERE u.id = :userId;

```

서브 쿼리를 통해 별도의 join없이 사용자에 해당하는 미션 참여 수, 리뷰 작성 수, 알람 수 까지 함께 불러옴.

### 시니어 미션

- [ ]  미션 1(내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함))에서 정렬 기준을 1순위는 포인트로 2순위는 최신순으로 하여 Cursor기반 페이지네이션을 구현해보세요

```sql
SELECT 
  um.id AS user_mission_id,
  um.user_id,
  m.id AS mission_id,
  m.title,
  m.status,
  m.created_at,
  m.point
FROM user_missions AS um
JOIN missions AS m ON um.mission_id = m.id
WHERE um.user_id = :userId
  AND m.status IN ('IN_PROGRESS', 'COMPLETED')
  /* 커서 값이 제공된 경우, 이전 페이지의 마지막 미션 이후의 결과를 조회 */
  AND (
       (:lastPoint IS NULL) OR
       (m.point < :lastPoint) OR 
       (m.point = :lastPoint AND m.created_at < :lastCreatedAt)
  )
ORDER BY m.point DESC, m.created_at DESC
LIMIT :pageSize;

```

- **FROM 및 JOIN 구문**
    
    `FROM user_missions AS um`
    
    user_missions를 별칭 `um`으로 지정.
    
    `JOIN missions AS m ON um.mission_id = m.id`
    
    참여한 미션의 상세 정보를 가져오기 위해 `missions` 테이블과 조인.
    
- **SELECT 구문**
    
    `um.id AS user_mission_id, um.user_id, m.id AS mission_id, m.title, m.status, m.created_at, m.point`
    
    사용자 미션의 고유 식별자와 해당 미션의 제목, 상태, 생성일, 그리고 포인트 정보를 조회.
    
- **WHERE 절 – 사용자와 상태 필터링**
    
    `um.user_id = :userId`
    
    특정 사용자에 해당하는 미션 기록만 조회.
    
    `AND m.status IN ('IN_PROGRESS', 'COMPLETED')`
    
    미션 상태가 진행중(IN_PROGRESS) 또는 완료(COMPLETED)인 경우만 조회.
    
- **커서 기반 페이징 조건**
    
    커서 조건은 다음과 같이 처리합니다:
    
    첫 페이지 요청 시 `:lastPoint` 값이 `NULL`이면 모든 레코드가 대상이 됨.
    
    이후 페이지에서는 **이전 페이지 마지막 미션**의 포인트와 생성일자를 기준으로
    
    `(m.point < :lastPoint)` 또는
    
    `(m.point = :lastPoint AND m.created_at < :lastCreatedAt)` 조건을 만족하는 레코드를 가져옴.
    
    이 조건은 정렬 순서(포인트 내림차순, 생성일 내림차순)에 맞게 "이전 페이지보다 뒤쪽에 위치한" 레코드만 선택.
    
    - cursor값
        
        예를 들어, 첫 페이지를 조회한 후 마지막 미션의 point 값이 100이고, created_at 값이 '2025-03-29 12:00:00'이라면, 다음 페이지를 요청할 때 이 값들을 각각 :lastPoint와 :lastCreatedAt 파라미터에 바인딩하여 전달.
        
        이렇게 하면 쿼리에서는 "이전 페이지의 마지막 미션보다 순서상 뒤에 있는 레코드들만 선택해라"는 조건으로 동작
        
        이전 페이지에서 불러온 마지막 레코드의 정렬 기준 값(예: point, created_at)을 커서 값으로 사용하여, 그 값 이후에 위치한 데이터들만 조회 (이미 조회한 데이터들은 빼고 조회해 올 수 있도록)
        
        OFFSET 방식에 비해 대량의 데이터가 있을 때 성능이 좋고, 데이터 추가나 삭제로 인한 중복 또는 누락 문제를 줄일 수 있다는 장점
        
    
- **ORDER BY 절**
    
    `ORDER BY m.point DESC, m.created_at DESC`
    
    첫 번째 정렬 기준은 미션의 포인트(높은 순)이고, 동일 포인트인 경우 최신 미션을 먼저 조회.
    
- **LIMIT 절**
    
    `LIMIT :pageSize`
    
    한 번에 반환할 레코드 수를 제한하여 페이지 크기를 정의.
    

## SQL Injection

클라이언트 입력값으로 웹 사이트 쿼리가 완성되는 약점을 이용하여, 사용자의 입력값에 임의의 SQL 문을 주입해서 데이터베이스에 저장된 중요한 데이터를 가져오는 공격

난이도가 비교적 쉬운 편이라 웹 애플리케이션 보안 취약점 목록인 OWASP Top 10에 항상 속해있음.

### -공격 기법

1. Error Based SQL Injection

db 에러 메시지를 활용하여 데이터베이스에 대한 정보를 획득하는 공격 기법. 

에러 메시지를 통해 공격자가 db의 구조를 파악하여 sql injection을 준비가능. 민감한 데이터를 탈취.

1. Union Based SQL Injection

union 키워드를 사용해 2개의 쿼리를 요청해 내부 데이터를 얻어내는 공격 기법.

원래의 요청에 union으로 한 개의 쿼리를 추가해 정보를 얻어내는 것이 목적. db에 저장된 데이터가 보이는 경우에 사용됨(ex:  커뮤니티 게시글, 리뷰 등)

1. Blind SQL Injection

에러 메시지나 데이터가 직접 노출되지 않을 떄 사용하는 공격 기법

조작된 sql문을 삽입해도 어떠한 정보가 뜨지 않는 경우에 사용.

sql 문의 결과가 참 또는 거짓에 따라 서버의 응답이 달라지는 경우에 사용됨. (ex: 로그인 성공, 실패 페이지)

(요즘 개발된 웹사이트는 보안이 철저해 공격이 통한다면 blind 기법일 확률이 높다)

### -방어 기법

1. Prepared Statement

SQL 쿼리 작성 시, 사용자 입력값을 쿼리 문자열에 직접 포함하지 않고, 별도의 파라미터로 전달하는 방식

구문 분석(parse) 과정을 최초 1회만 수행하여 생성된 결과 컴파일하여 메모리에 저장해 필요할 때마다 사용하는 방법

사용자 입력값을 파라미터로 미리 컴파일된 SQL 쿼리문에 대입하기에, 문법에 영향을 미치는 특수문자나 구문이 입력되어도 입력값을 단순 데이터로 인식 → injection 방어

1. 화이트 리스트 기반 필터링

애플리케이션에 입력되는 데이터가 미리 정의된 허용 목록(화이트 리스트)에 포함된 값만 통과하도록 하는 보안 기법

**허용된 값만 처리:**

입력값에 대해 "이 값들만 허용된다"라는 명시적인 목록을 정의하고, 그 외의 모든 값은 거부. 

(ex: 사용자 이름에는 영문자와 숫자만 허용한다면, 정규 표현식 등을 사용하여 그 조건에 부합하지 않는 입력은 배제)

Prepared Statement 사용이 불가한 경우에 사용

1. ORM(Object-Relational Mapping) 사용

Hibernate, JPA, MyBatis 등 ORM 프레임워크는 내부적으로 파라미터 바인딩을 사용하여 SQL injection 위험을 줄임.

프레임워크를 올바르게 설정하고, 동적 쿼리 작성 시에도 주의해야한다.

## JOIN

- JOIN은 나누어진 테이블을 하나로 합치기 위해 데이터베이스가 제공하는 기능.
- JOIN 은 ON 이라는 키워드를 통해 기준이 되는 컬럼을 선택하여 2개의 테이블을 합쳐줌.
- JOIN을 할 때에는 적어도 하나의 컬럼을 서로 공유하고 있어야 하기 때문에 테이블에 외래 키가 설정 되어 있다면 해당 컬럼을 통해 JOIN을 하면 조건을 충족 가능.

### INNER JOIN(내부 조인)

가장 많이 사용되는 조인
두 테이블에서 지정한 조건을 만족하는 **공통된(매칭되는)** 행만 반환

```sql
SELECT a.col1, b.col2
FROM tableA AS a
INNER JOIN tableB AS b
  ON a.id = b.a_id;

```

### OUTER JOIN(외부 조인)

내부 조인과 달리, 한쪽에만 데이터가 있어도 결과 반환

- LEFT

왼쪽 테이블의 모든 값 출력

```sql
SELECT a.col1, b.col2
FROM tableA AS a
LEFT JOIN tableB AS b
  ON a.id = b.a_id;
```

왼쪽(첫 번째) 테이블의 모든 행을 반환하며, 오른쪽(두 번째) 테이블과의 매칭이 있으면 해당 데이터를 포함하고, 매칭이 없으면 오른쪽 컬럼은 `NULL`로 반환

- RIGHT

오른쪽 테이블의 모든 값이 출력

```sql
SELECT a.col1, b.col2
FROM tableA AS a
RIGHT JOIN tableB AS b
  ON a.id = b.a_id;
```

- FULL

왼쪽 외부 조인과 오른쪽 외부 조인이 합쳐진 것

```sql
SELECT a.col1, b.col2
FROM tableA AS a
FULL OUTER JOIN tableB AS b
  ON a.id = b.a_id;
```

### CROSS JOIN(상호 조인)

한쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인. 상호 조인 결과의 전체 행 개수는 두 테이블의 각 행의 개수를 곱한 수가 됨.

**카티션 곱(CARTESIAN PRODUCT)** 이라고도 불림**.**

```sql
SELECT a.col1, b.col2
FROM tableA AS a
CROSS JOIN tableB AS b;
```

### SELF JOIN(자체 조인)

동일한 테이블을 서로 다른 별칭(alias)을 사용하여 JOIN.

자기 자신과 조인하므로 1개의 테이블을 사용.

```sql
SELECT a.col1, b.col1 AS related_value
FROM employees AS a
JOIN employees AS b
  ON a.manager_id = b.id;
```

같은 테이블 내에서 계층적 관계나 자기 참조 관계를 처리할 때 사용됨.

### NATURAL JOIN

두 테이블에서 이름이 동일한 컬럼들을 자동으로 찾아 JOIN 조건으로 사용.

```sql
SELECT *
FROM tableA
NATURAL JOIN tableB;
```

JOIN 조건을 명시적으로 작성할 필요가 없지만, 두 테이블의 컬럼명이 동일해야 하며, 의도하지 않은 컬럼까지 JOIN될 위험 존재.

-참고

[SQL Injection 공격이란? (종류, 방어기법, 공격 시나리오)](https://studysteadily.tistory.com/15)

[SQL 기본 문법: JOIN(INNER, OUTER, CROSS, SELF JOIN)](https://hongong.hanbit.co.kr/sql-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-joininner-outer-cross-self-join/)