# 미션

## **쿠키, 세션, 토큰**

**세션과 토큰의 필요성**

우리가 사용하는 http 프로토콜은 stateless(무상태성) 이라는 특징을 가짐. 서버로 가는 모든 요청이 이전 요청과는 독립적으로 다뤄짐. 따라서 **요청할떄마다 우리가 누군지 알려줘야 함.**

## **쿠키란?**

서버와 클라이언트 간의 연결을 유지하기위해 서로를 인식할 수 있는 매개체, 식별 데이터

**동작 과정**

웹사이트에 방문시 브라우저(클라이언트)는 서버에 요청을 보냄. -> 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담는다. -> 사용자는 쿠키를 브라우저에 저장 -> 이후 요청을 보낼 때마다 매번 저장된 쿠키를 요청 헤더의 cookie에 담아 보냄.

**단점**

요청시 쿠키의 값을 그대로 보내기에 보안에 취약! 용량 제한이 있어 많은 정보를 담을 수 없음.

## **세션?**

클라이언트와 서버 간 연결이 활성화된 상태로, 쿠키와 마찬가지로 로그인과 같은 사용자 인증을 할때 주로 사용. (세션은 쿠키를 기반으로 함)

**쿠키는 클라이언트 쪽에 정보를 저장하는 반면, 세션은 서버 쪽에 정보를 저장(세션ID만 쿠키 형태로 저장해서 서버와 클라이언트를 연결)**

**인증 방식**

유저 A가 로그인. 유저네임과 비번을 서버로 보냄. -> 비번이 맞으면 서버는 사용자의 고유한 id를 부여하여 세션 저장소에 유저 생성 후 세션id 발급 -> 사용자는 서버에서 해당 세션 id를 받아 쿠키에 저장, 인증이 필요한 요청마다 쿠키를 헤더에 실어 보냄. -> 서버는 쿠키를 받아 세션 저장소에서 대조 후 대응되는 정보를 가져옴. -> 인증 완료시 데이터 반환

**단점**

쿠키를 포함한 요청이 외부에 노출되더라도 세션Id 자체에는 유의미한 개인정보를 담고있지 않다. 그러나, 탈취자가 세션Id 자체를 탈취하여 클라이언트인척 위장할 수 있다는 한계가 있다.

서버에서 세션 저장소를 사용하므로 로그인한 유저들의 모든 세션 id를 db에 저장해야함. -> 요청이 많아지면 서버에 부하가 심해진다.

**JWT 토큰**

JWT는 인증에 필요한 정보들을 암호화시킨 json 토큰으로, 클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 '토큰'을 부여.

이 토큰은 유일하며, 토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다.

그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증과정을 처리

**단점**

쿠키/ 세션과 다르게 토큰 자체의 데이터 길이가 길어 요청이 많아지면 네트워크 부하가 심해질 수 있음.

토큰은 발급하면 만료될 때 까지 계속 사용 가능하기에 탈취당하면 대처하기 어려움.

**jwt 검증?**

액세스토큰이 db에 저장되지 않는데 어떻게 그럼 발급한 토큰과 일치하는지 검증?

JWT의 Signature(서명)는 Header와 Payload를 조합한 후, Secret Key를 사용해 해싱한 결과로 서버측에서는 토큰이 변조되지 않았는지 확인하기위해 서명을 검증.

1. 서버는 JWT를 생성할 때, 헤더와 페이로드를 **서버의 개인키로 해싱하여 시그니처를 생성**한다. 이렇게 생성된 JWT를 사용자에게 발급한다.
2. 사용자는 이후 요청 시, 발급받은 JWT를 인증 수단으로 사용하기 위해 헤더에 JWT 넣어서 서버에게 전달한다.
3. 서버는 사용자로부터 받은 JWT의 헤더와 페이로드를 base64로 디코딩하여 1번의 과정과 마찬가지로 **서버가 가지고 있는 개인키로 해싱**하여 시그니처값이 같은지를 검증한다.
4. 검증이 성공하면 정상적으로 요청이 처리되며, 검증에 실패하면(시그니처 값이 다름) 위변조로 간주하고 인증 실패 처리한다.

**AccessToken & RefreshToken**

액세스 토큰은 사용자에 대한 정보를 담고 있어서 서비스에 접근(Access)할 수 있는 토큰을 의미한다. 사용자 검증을 위해 사용한 JWT 또한 액세스 토큰에 해당된다.

리프레시 토큰은 그 자체로는 별다른 정보를 담고있지 않다. 대신 Refresh라는 이름에 걸맞게 액세스 토큰이 만료되었을 때 서버에서 이를 확인하고 새로운 액세스 토큰을 발급해주기 위해 사용한다.

## **RefreshToken이 필요한 이유?**

Access Token은 발급된 이후, 서버에 저장되지 않고 토큰 자체로 검증을 하며 사용자 권한을 인증하기 떄문에, Access Token이 탈취되면 토큰이 만료되기 전 까지, 토큰을 획득한 사람은 누구나 권한 접근이 가능해 지기 때문이다. JWT는 발급한 후 삭제가 불가능하기 때문에, 접근에 관여하는 토큰에 유효시간을 부여하는 식으로 탈취 문제에 대해 대응을 하여야 한다.

**AccessToken은 접근(인증)에, RefreshToken은 재발급에 관여하는 토큰.**

case1 : access token과 refresh token 모두가 만료된 경우 → 에러 발생 (재 로그인하여 둘다 새로 발급)

case2 : access token은 만료됐지만, refresh token은 유효한 경우 →  refresh token을 검증하여 access token 재발급

case3 : access token은 유효하지만, refresh token은 만료된 경우 →  access token을 검증하여 refresh token 재발급

case4 : access token과 refresh token 모두가 유효한 경우 → 정상 처리

## **RefreshToken 인증 과정**

1. 사용자가 ID , PW를 통해 로그인.
2. 서버에서는 회원 DB에서 값을 비교
    
    3~4. 로그인이 완료되면 Access Token, Refresh Token을 발급한다. 이때 Refresh Token을 DB에 저장해둔다.
    
3. 사용자는 Refresh Token은 안전한 저장소에 저장 후, Access Token을 헤더에 실어 요청을 보낸다.
    
    6~7. Access Token을 검증하여 이에 맞는 데이터를 보낸다.
    
4. 시간이 지나 Access Token이 만료됐다.
5. 사용자는 이전과 동일하게 Access Token을 헤더에 실어 요청을 보낸다.
    
    10~11. 서버는 Access Token이 만료됨을 확인하고 권한없음을 신호로 보낸다.
    
6. 사용자는 Refresh Token과 Access Token을 함께 서버로 보낸다.
7. 서버는 받은 Access Token이 조작되지 않았는지 확인한후, Refresh Token과 사용자의 DB에 저장되어 있던 Refresh Token을 비교한다. Token이 동일하고 유효기간도 지나지 않았다면 새로운 Access Token을 발급해준다.
8. 서버는 새로운 Access Token을 헤더에 실어 다시 API 요청 응답을 진행한다.

[https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-Access-Token-Refresh-Token-%EC%9B%90%EB%A6%AC-feat-JWT](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-Access-Token-Refresh-Token-%EC%9B%90%EB%A6%AC-feat-JWT)

# **외부 인증 방식**

Spring Security는 외부 인증 시스템과의 통합 지원, 다양한 인증 방법을 제공.

**LDAP (Lightweight Directory Access Protocol)**

네트워크상에서 사용자와 그룹 같은 디렉토리 정보를 관리하기 위한 프로토콜. 사용자 인증, 정보 검색, 조직 구조 관리 등에 보통 많이 사용되는데 예를 들어 직원들의 로그인 정보, 이메일 주소, 부서 정보 등을 중앙 집중화하여 관리. 기업이나 대학과 같은 조직에서 주로 사용됨.

**OAuth2**

OAuth2는 외부 서비스 제공자를 통한 인증 및 권한 부여를 위한 표준 프로토콜. 다른 서비스(카카오, 네이버, 페이스북 등)의 인증을 통해 로그인하고 접근할 수 있게 해줌. 소셜 로그인이나 타 서비스에 대한 권한 부여에 사용됨.