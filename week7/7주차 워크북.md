# 시니어 미션

기존에는 젠킨스나 깃허브에서 health check 같은 걸로 서버 기동 상태 알림만 파이프라인에 작성해서 사용했었는데 실시간 장애 감지는 따로 설정하는 것은 처음 해봄.
생각보다 가동 중에 알림이 많이 올 거 같은데 심각도로 구분해서 다른 채널로 메시지를 보내는 것도 방법일 듯하다. 찾아보니 동일 에러 반복 시 Cool-Down 시간 설정을 둬 해결한다고 함.
로컬 서버에서 난 에러도 알림이 가게 한다면 팀 협업 시 지속적인 알람으로 혼란을 줄 수 있고 다른 팀원들은 어디서 발생한 에러인지 지속적으로 확인해야하는 수고로움이 생길 것이다.


1. 젠킨스 파이프라인

```java
pipeline
{
    agent
    {
        //아래의 작업이 수행될 에이전트
        label 'jenkins_agent'
    }

    environment
    {
        //Discord Webhook URL
        WEBHOOK_URL = credentials('DISCORD_CATXI')
        //Branch name
        BRANCH_NAME = 'develop'
        //Spring Boot Profile
        SPRING_PROFILES_ACTIVE = 'prod'
    }

    tools
    {
        //Gradle 8.12.1
        gradle 'catxi_gradle'
    }

    options 
    {
        //Enable timestamps
        timestamps()
    }

    stages
    {
        stage('Checkout Backend Repository')
        {
            steps
            {
                echo 'Checking out Backend Repository (develop branch)'
                //이전에 체크아웃된 프론트엔드 레포지토리 삭제
                deleteDir()
                //프론트엔드 레포지토리를 develop 브랜치로 체크아웃
                git branch: "${BRANCH_NAME}", url: 'https://github.com/dongjune8931/CATXI'
            }
        }

        stage('Gradle Clean Build')
        {
            steps
            {
                script
                {
                    run_with_error_handle('Gradle Clean Buiild')
                    {
                        echo 'Building Backend'
                        //백엔드 레포지토리의 빌드
                        sh '''
                            SPRING_PROFILES_ACTIVE=${SPRING_PROFILES_ACTIVE} gradle clean build
                            tar -czf app.tar.gz -C build/libs/ .
                        '''
                    }
                }
            }
        }

        stage('Transfer Jar File')
        {
            steps
            {
                script
                {
                    run_with_error_handle('Transfer Jar File')
                    {
                        echo 'Transferring Jar File to EC2'
                        //빌드 된 jar 파일을 EC2로 전송
                        sshagent(['ec2_catxi'])
                        {
                            sh '''
                                scp -o StrictHostKeyChecking=no -P ${CATXI_PORT} app.tar.gz ${CATXI_USER}@${CATXI_URL}:/home/${CATXI_USER}/app/
                            '''
                        }
                    }
                }
            }
        }

        stage('Run Spring Boot Application')
        {
            steps
            {
                script
                {
                    run_with_error_handle('Run Spring Boot Application')
                    {
                        echo 'Running Spring Boot Application on EC2'
                        //EC2에서 Spring Boot Application 실행
                        sshagent(['ec2_catxi'])
                        {
                            sh '''
                                ssh ${CATXI_USER}@${CATXI_URL} -p ${CATXI_PORT} 'bash /home/deploy/app/deploy.sh'
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Health Check')
        {
            steps
            {
                script
                {
                    def MAX_RETRIES = 10
                    def RETRY_INTERVAL = 5
                    def success = false

                    for (int i = 0; i < MAX_RETRIES; i++)
                    {
                        try
                        {
                            def response = httpRequest(
                                url : "http://${CATXI_URL}:8080/health",
                                validResponseCodes: '200',
                                timeout: 3
                            )

                            if (response.status == 200)
                            {
                                echo "✅ Health Check passed!"
                                success = true
                                break
                            }
                        }
                        catch (Exception e)
                        {
                            echo "⚠️ Request failed: ${e.message}"
                            echo "⏳ Waiting for app...(${i + 1}/${MAX_RETRIES})"
                            sleep(RETRY_INTERVAL)
                        }
                    }
                    if (!success)
                    {
                        error "❌ Health check failed after ${MAX_RETRIES} attempts."
                    }
                }
            }
        }
    }
    
    post
    {
        success
        {
           //빌드 성공 디스코드 메시지
            discordSend description: "빌드 성공은 했는데 안에 내용 자신있죠? ", 
                            footer: "The backend build has successfully completed without any errors.", 
                            link: env.BUILD_URL, result: currentBuild.currentResult, 
                            title: "${env.JOB_NAME} #${BUILD_NUMBER}", 
                            webhookURL: env.WEBHOOK_URL
        }

        failure
        {
           //빌드 실패 디스코드 메시지
            discordSend description: "빌드 실패. 제대로 안할래요?", 
                            //footer: "The build process encountered errors.", 
                            link: env.BUILD_URL, result: currentBuild.currentResult, 
                            title: "${env.JOB_NAME} #${BUILD_NUMBER}", 
                            webhookURL: env.WEBHOOK_URL
        }
    }
    
}

def run_with_error_handle(String stage_name, Closure task)
{
    try
    {
        //작업 수행
        task.call()
    }
    catch (Exception error)
    {
        //빌드 실패 디스코드 메시지
        currentBuild.result = "FAILURE"
       discordSend description: "Build Failed: ${stage_name}", 
                            footer: "The build process encountered errors.\nPlease review the log for detailed information on what went wrong and how to fix it.\n\n${error.message}", 
                            link: env.BUILD_URL, result: currentBuild.currentResult, 
                            title: "${env.JOB_NAME} #${BUILD_NUMBER}", 
                            webhookURL: env.WEBHOOK_URL
        //스테이지 실패
        error("Stage failed: ${stage_name}")
    }
}
```

2. 500 에러 api

```java
@RestController
@RequestMapping("/test")
public class TestController {

    @GetMapping("/error")
    public void triggerError() {
        throw new RuntimeException("500에러에러에러에러에러에러에러");
    }
}
```

3. 예외 핸들러 작성
    
    ```java
    @RestControllerAdvice
    public class GlobalExceptionHandler {
    
        private final DiscordNotifier discordNotifier;
    
        public GlobalExceptionHandler(DiscordNotifier discordNotifier) {
            this.discordNotifier = discordNotifier;
        }
    
        @ExceptionHandler(Exception.class)
        public ResponseEntity<String> handleAllExceptions(Exception ex, HttpServletRequest request) {
            String errorLog = String.format(
                " **500 Internal Server Error** \n" +
                "**URL:** %s\n" +
                "**Message:** %s\n" +
                "**Time:** %s",
                request.getRequestURL(),
                ex.getMessage(),
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
            );
    
            if (isProdEnvironment()) {
                discordNotifier.sendErrorNotification(errorLog);
            }
    
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Internal Server Error");
        }
    
        private boolean isProdEnvironment() {
            return "prod".equals(System.getenv("SPRING_PROFILES_ACTIVE"));
        }
    }
    
    ```
    
4. 웹훅 호출용 코드 구현

```java
@Component
public class DiscordNotifier {

    @Value("${webhook.url}")
    private String webhookUrl;

    private final RestTemplate restTemplate = new RestTemplate();

    public void sendErrorNotification(String message) {
        Map<String, String> payload = new HashMap<>();
        payload.put("content", message);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, String>> request = new HttpEntity<>(payload, headers);

        try {
            restTemplate.postForEntity(webhookUrl, request, String.class);
        } catch (Exception e) {
            System.err.println("Discord Notification Failed: " + e.getMessage());
        }
    }
}

```
