# 10주차 워크북

## 🎯 핵심 키워드

<aside>
💡 주요 내용들을 정리하고, 여러분만의 생각을 통해 정리해보세요!

- 레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 괜찮습니다.
- 조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**
</aside>

- **Spring Security**
    
    Spring Security 는 인증, 권한 관리 그리고 데이터 보호 기능을 포함하여 웹 개발과정에서 필수적인 사용자 관리 기능을 구현하는데 도움을 주는 spring 의 프레임워크이다. 인증과 인가에 초점을 맞춘 프레임워크이다. spring Security 는 인증과 권한에 대한 부분을 filter 흐름에 따라 처리하고 있다.
    
    Filter는 Dispatcher Servlet으로 가기 전에 적용되므로 가장 먼저 URL 요청을 받지만, Interceptor는 Dispatcher와 Controller사이에 위치한다는 점에서 적용 시기의 차이가 있다. Spring Security는 보안과 관련해서 체계적으로 많은 옵션을 제공해주기 때문에 개발자 입장에서는 일일이 보안관련 로직을 작성하지 않아도 된다는 장점이 있다. 인증과 인가에 대해서는 밑에 토글에서 자세히 설명하겠다. 
    
    Spring Security는 기본적으로 인증 절차를 거친 후에 인가 절차를 진행하게 되며, 인가 과정에서 해당 리소스에 대한 접근 권한이 있는지 확인을 하게 된다. Spring Security에서는 이러한 인증과 인가를 위해 Principal을 아이디로, Credential을 비밀번호로 사용하는 Credential 기반의 인증 방식을 사용한다.
    
    **SecurityContextHolder** :SecurityContextHolder는 보안 주체의 세부 정보를 포함하여 응용프래그램의 현재 보안 컨텍스트에 대한 세부 정보가 저장된다. SecurityContextHolder는 기본적으로 SecurityContextHolder.MODE_INHERITABLETHREADLOCAL 방법과 SecurityContextHolder.MODE_THREADLOCAL 방법을 제공한다.
    
    **SecurityContext:** Authentication을 보관하는 역할을 하며,  Authentication 객체를 꺼내올 수 있다.
    
    **Authentication:** 현재 접근하는 주체의 정보와 권한을 담는 인터페이스이다. Authentication 객체는 Security Context에 저장되며, SecurityContextHolder를 통해 SecurityContext에 접근하고, SecurityContext를 통해 Authentication에 접근할 수 있다.
    
    **UsernamePasswordAuthenticationToken:** Authentication을 implements한 AbstractAuthenticationToken의 하위 클래스로, User의 ID가 Principal 역할을 하고, Password가 Credential의 역할을 한다. UsernamePasswordAuthenticationToken의 첫 번째 생성자는 인증 전의 객체를 생성하고, 두번째 생성자는 인증이 완려된 객체를 생성한다.
    
    **AuthenticationProvider** : 실제 인증에 대한 부분을 처리하는데, 인증 전의 Authentication객체를 받아서 인증이 완료된 객체를 반환하는 역할을 한다. 아래와 같은 AuthenticationProvider 인터페이스를 구현해서 Custom한 AuthenticationProvider을 작성해서 AuthenticationManager에 등록하면 된다.
    
    **Authentication Manager:** 인증에 대한 부분은 SpringSecurity의 AuthenticationManager를 통해서 처리하게 되는데, 실질적으로는 AuthenticationManager에 등록된 AuthenticationProvider에 의해 처리된다. 인증이 성공하면 2번째 생성자를 이용해 인증이 성공한(isAuthenticated=true) 객체를 생성하여 Security Context에 저장한다. 그리고 인증 상태를 유지하기 위해 세션에 보관하며, 인증이 실패한 경우에는 AuthenticationException를 발생시킨다.
    
    **UserDetails:** 인증에 성공하여 생성된 UserDetails 객체는 Authentication객체를 구현한 UsernamePasswordAuthenticationToken을 생성하기 위해 사용된다. UserDetails 인터페이스를 살펴보면 아래와 같이 정보를 반환하는 메소드를 가지고 있다. UserDetails 인터페이스의 경우 직접 개발한 UserVO 모델에 UserDetails를 implements하여 이를 처리하거나 UserDetailsVO에 implements하여 처리할 수 있다.
    
    **UserDetailsService:** UserDetailsService 인터페이스는 UserDetails 객체를 반환하는 단 하나의 메소드를 가지고 있는데, 일반적으로 이를 구현한 클래스의 내부에 UserRepository를 주입받아 DB와 연결하여 처리한다.
    
    **Password Encoding:** 패스워드 암호화에 사용될 PasswordEncoder 구현체를 지정할 수 있다.
    
- **인증(Authentication)과 인가(Authorization)**
    
    인증(Authentication)은 spring security 에서 api에 접근하는 사용 주체가 누구인지 입증하는 과정을 의미한다.  유저가 누구인지 확인하는 것, 통상 회원가입하고 로그인하는 것을 말한다.
    
    1. **사용자 요청**:
        
        `/login` 페이지에서 아이디/비밀번호 입력 후 전송.
        
    2. **UsernamePasswordAuthenticationFilter**:
        
        사용자의 로그인 정보를 받는 **가장 대표적인 필터**.
        
        로그인 요청(`POST /login`)을 가로채서 내부적으로 `Authentication` 객체를 생성.
        
    3. **AuthenticationManager**:
        
        위의 Authentication 객체를 검증하는 **중앙 인증 처리자**.
        
        내부적으로 여러 인증 제공자(`AuthenticationProvider`)를 순회하며 인증을 시도.
        
    4. **AuthenticationProvider**:
        
        대표적으로 `DaoAuthenticationProvider` 사용.
        
        사용자의 정보는 **UserDetailsService**를 통해 불러오고,
        
        입력한 비밀번호와 `UserDetails`의 `password`를 `PasswordEncoder`로 비교.
        
    5. **성공 시**:
        
        인증된 `Authentication` 객체가 생성되어 **SecurityContextHolder**에 저장됨.
        
        세션 기반이라면 `HttpSession`에 저장됨 (기본 설정 기준).
        
    6. **실패 시**:
        
        `AuthenticationFailureHandler`에 의해 로그인 실패 처리됨.
        
    
    인가(Authorization) 은 인증후 요청한 자원에 대해 접근할 자격이 있는 판단하는 과정이다. 어떠한 권한을 가지고 어떤 리소스를 사용할 수 있는지에 대해 결정한다. 로그인한 사용자의 권한 정보에 따라 api나 url 을 다르게 허용할 수 있다.
    
    1. 사용자가 인증된 이후 리소스를 요청합니다. (예: `/admin`)
    2. **FilterSecurityInterceptor**:
        
        요청 경로에 따른 접근 권한을 확인.
        
        설정 파일에서 선언한 `.antMatchers("/admin/**").hasRole("ADMIN")` 같은 규칙을 바탕으로,
        
        현재 사용자의 `Authentication` 객체 안에 있는 권한(`GrantedAuthority`)와 비교.
        
    3. **AccessDecisionManager**:
        
        여러 `AccessDecisionVoter`를 통해 접근 허용 여부를 결정.
        
        기본적으로 `ROLE_*` 권한 기반으로 판단.
        
    4. **인가 성공**: 컨트롤러로 진입하여 로직 처리.
    5. **인가 실패**:
        
        `AccessDeniedHandler`가 동작하여 **403 Forbidden** 반환.
        
- **세션과 토큰**
    
    세션은 사용자가 인증에 성공한 상태를 말하고 토큰이란 권한이나 자격을 나태내는 징표이다. 
    
    세션은 비밀번호등 클라이언트의 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리한다. 서버의 메모리혹은 로컬파일이나 데이터베이스에 저장하기도 한다. 세션 객체는 key에 해당하느 세션id 와 이에 대응하는 value 로 구성되어있다.
    
    1. 유저가 웹사이트에서 로그인하면 세션이 서버 메모리(혹은 데이터베이스) 상에 저장된다. 이때, 세션을 식별하기 위한 Session Id를 기준으로 정보를 저장한다.
    2. 서버에서 브라우저에 쿠키에다가 Session Id를 저장한다.
    3. 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송한다. 4.
    4. 서버는 클라이언트가 보낸 Session Id 와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행한다.
    
    토큰은 서버에 접속을 하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 토큰을 부여한다. 이 토큰은 유일하고 발급받은 클라이언트는 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다. 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치여부를 체크하여 인증과정을 처리하게 된다. 세션과 달리 클라이언트에 저장되기때문에 서버의 부담을 덜 수 잇다. 토큰자체에 대이터가 들어있기에 클라이언트에서 받아 위조되었는지 판별만 하면 된다.
    
    1. 사용자가 아이디와 비밀번호로 로그인을 한다.
    2. 서버 측에서 사용자(클라이언트)에게 **유일한 토큰**을 발급한다.
    3. 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고, 서버에 요청을 할 때마다 해당 토큰을 서HTTP 요청 헤더에 포함시켜 전달한다.
    4. 서버는 전달받은 토큰을 검증하고 요청에 응답한다. 토큰에는 요청한 사람의 정보가 담겨있기에 서버는 DB를 조회하지 않고 누가 요청하는지 알 수 있다.
- **액세스 토큰(Access Token)과 리프레시 토큰(Refresh Token)**
    
    토큰은 유저의 신원이나 권한을 결정하는 정보를 담고있는 데이터 조각이다. 하지만 탈취당했을때는 문제가 발생한다. 따라서 유효기간을 가지고 있다. 유효기간에 대해 짧은 두면 사용자가 로그인을 자주해야되서 불편함이 있지만 유효기간이 길면 탈취 위험이 증가된다. 따라서 유효기간이 짧은 엑세스토큰(Access Token) 과 리프레시 토큰(Refresh Token) 이 있다. 평소에 API통신할 때는 Access Token을 사용하고 Refresh Token 은 Access Token 이 만료되어 갱신될 때만 사용한다. 
    
    로그인에 성공한 클라이언트는 엑세스토큰과 리프레시 토큰 2개를 서버로부터 받는다. 클라이언트는 두 토큰을 로컬에 저장해놓는다. 
    
    평소에는 엑세스 토큰으로 통신을 하고 유효기간이 만료되면 리프레시 토큰을 넣어 api를 재요청한다. 리프레시토큰으로 권한을 확인한 서버는 새로운 엑세스토큰을 넣어 응답한다. 
    
    리프레시토큰도 만료되었다면 서버는 에러코드를 보내고 클라이언트는 재로그인한다. 
    
    Access Token 에 대해 탈취당하더라도 만료기간을 조정할 수없다. JWT 토큰의 만료기간은 변경이 안되기 때문이다. 
    
    Refresh Token 에 대해 Refresh Token Rotation 을 통해 탈취를 예방한다. 클라이언트가 Access 토큰을 재요청할 때마다 Refresh 토큰도 새로 발급하는 것이다.
    

## 📢 학습 후기

<aside>
💡 이번 주차 워크북을 해결해보면서 어땠는지 회고해봅시다.

- Spring Security의 로그인 과정에 대해 완전히 이해했나요?
- 혹시 이해가 안 되는 부분이 있었나요?
- 이번 실습에서 어려웠던 부분은 무엇이었나요?
</aside>

## ⚠️ 스터디 진행 방법

1. 스터디를 진행하기 전, 워크북 내용들을 모두 채우고 스터디에서는 서로 모르는 내용들을 공유해주세요.
2. 미션은 워크북 내용들을 모두 완료하고 나서 스터디 전/후로 진행해보세요.
3. 다음주 스터디를 진행하기 전, 지난주 미션을 서로 공유해서 상호 피드백을 진행하시면 됩니다.

## 🔥 미션

<aside>
📍 **주의 사항**

결과물만 올리면 안되고, 중간 과정 또한 기록을 남겨주셔야 합니다.
(DB 연결, 테이블 생성 등)

**결과물과 중간 과정 모두 기록하여 제출**하라는 뜻입니다.

</aside>

### 필수 미션

<aside>

**⚠️ 모든 미션 과정은 깃허브에 업로드해주세요.**

</aside>

1. **실습 1: Spring Security를 활용한 로그인 및 회원가입 구현 = Session 방식**
    - 회원가입, 로그인, 로그아웃 기능을 구현하고 **DB에 저장**되는 과정을 캡처하고 설명하세요.
2. **실습 2: Spring Security를 활용한 로그인 및 회원가입 구현 = JWT 방식**
    - 회원가입, 로그인을 구현하고 **Swagger에서 테스트 및 DB에 저장**되는 과정을 캡처하고 설명하세요.

- 아래는 실습 참고 코드입니다.
    
    [GitHub - chock-cho/UMC-8th-spring-workbook at feature-week10-workbook-2](https://github.com/chock-cho/UMC-8th-spring-workbook/tree/feature-week10-workbook-2)
    

### 시니어 미션

- **카카오, 구글 또는 네이버 소셜 로그인 추가 구현**
    - 결과물과 중간 과정을 기록하여 제출하세요.
- **리프레시 토큰 방식 로그인 추가 구현**
    - 결과물과 중간 과정, 액세스 토큰만 이용했을 때의 인증방식과의 장단점을 비교해서 제출하세요.

## 💪 미션 기록

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

- **미션 기록**
    1. Session 방식 로그인/회원가입 방식
    
    ![스크린샷 2025-06-04 오후 1.59.41.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.59.41.png)
    
    사용한 html 파일로 깃허브에 올라온 파일을 사용하였습니다. 아이디와 비밀번호로 로그인하는 방법을 구현하고 싶어 Eamil을 아이디로 수정했습니다.
    
    ![뷰컨트롤러1.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%87%E1%85%B2%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%E1%84%85%E1%85%A9%E1%86%AF%E1%84%85%E1%85%A51.png)
    
    ![뷰컨트롤러 2.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%87%E1%85%B2%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%E1%84%85%E1%85%A9%E1%86%AF%E1%84%85%E1%85%A5_2.png)
    
    사용한 viewcontroller 파일입니다. 실습과 비슷하게 만들었습니다.
    
    ![security config 화면.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/security_config_%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB.png)
    
    config 파일입니다.
    
    ![회원테이블 비밀번호 저장.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF_%E1%84%87%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AF%E1%84%87%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A9_%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC.png)
    
    ![비밀번호 encoder 서비스.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%87%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AF%E1%84%87%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A9_encoder_%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3.png)
    
    서비스 파일입니다 비밀번호를 encoding 하여 주었습니다.
    
    ![enum 역할 데이터.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/enum_%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AF_%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5.png)
    
    역할 enum 데이터입니다. 밑으로는 구현화면입니다.
    
    ![세션실습 회원가입 화면.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%89%E1%85%A6%E1%84%89%E1%85%A7%E1%86%AB%E1%84%89%E1%85%B5%E1%86%AF%E1%84%89%E1%85%B3%E1%86%B8_%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8_%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB.png)
    
    회원가입화면입니다.
    
    ![회원가입 성공 로그.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8_%E1%84%89%E1%85%A5%E1%86%BC%E1%84%80%E1%85%A9%E1%86%BC_%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3.png)
    
    다음과 같이 회원가입이 되면 로그가 인텔리제이에서 로그가 뜨고 DTO항목을 추가한것은 오류발생해 디버깅중 null 값이 들어오는지 확인하기위해 작성한 출력문입니다.
    
    ![회원가입 성공 db 저장 화면.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8_%E1%84%89%E1%85%A5%E1%86%BC%E1%84%80%E1%85%A9%E1%86%BC_db_%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC_%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB.png)
    
    다음과 같이 db에도 저장된것을 알수 있습니다.
    
    ![세션실습 로그인화면.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%89%E1%85%A6%E1%84%89%E1%85%A7%E1%86%AB%E1%84%89%E1%85%B5%E1%86%AF%E1%84%89%E1%85%B3%E1%86%B8_%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB.png)
    
    ![세션실습 로그인 성공화면.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%89%E1%85%A6%E1%84%89%E1%85%A7%E1%86%AB%E1%84%89%E1%85%B5%E1%86%AF%E1%84%89%E1%85%B3%E1%86%B8_%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%8B%E1%85%B5%E1%86%AB_%E1%84%89%E1%85%A5%E1%86%BC%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB.png)
    
    로그인 화면이고 로그인 성공시 홈화면으로 이어집니다.
    
    ![일반회원 관리자 페이지 실패.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%87%E1%85%A1%E1%86%AB%E1%84%92%E1%85%AC%E1%84%8B%E1%85%AF%E1%86%AB_%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A1_%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5_%E1%84%89%E1%85%B5%E1%86%AF%E1%84%91%E1%85%A2.png)
    
    일반회원(역할 USER) 가 관리자 페이지에 접속하면 뜨는 화면입니다.
    
    ![관리자 로그인 후 화면.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A1_%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%8B%E1%85%B5%E1%86%AB_%E1%84%92%E1%85%AE_%E1%84%92%E1%85%AA%E1%84%86%E1%85%A7%E1%86%AB.png)
    
    관리자가 로그인하면 뜨는 화면입니다
    
    ![관리자 페이지.png](10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%87%E1%85%AE%E1%86%A8%20208bd0dd45e58036934acd05c6d5bc6a/%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A1_%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5.png)
    
    관리자 화면입니다
    

> **GitHub 저장소 주소**
> 
> 
> https://github.com/…
> 

## ⚡ 트러블 슈팅

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널**에 질문해보세요!

</aside>

- ⚡이슈 작성 예시 (이슈가 생기면 아래를 복사해서 No. 1, No. 2, No. 3, … 으로 작성해서 트러블 슈팅을 꼭 해보세요!)
    
    **`이슈`**
    
    👉 앱 실행 중에 노래 다음 버튼을 누르니까 앱이 종료되었다.
    
    **`문제`**
    
    👉 노래클래스의 데이터리스트의 Size를 넘어서 NullPointException이 발생하여 앱이 종료된 것이었다. 
    
    **`해결`**
    
    👉  노래 다음 버튼을 눌렀을 때 데이터리스트의 Size를 검사해 Size보다 넘어가려고 하면 다음으로 넘어가는 메서드를 실행시키지 않고, 첫 노래로 돌아가게끔 해결
    
    **`참고 레퍼런스`**
    
    - 링크
- ⚡이슈 No. 1
    
    **`이슈`**
    
    👉 [트러블이 생긴 상태 작성]
    
    **`문제`**
    
    👉 [어떤 이유로 해당 이슈가 일어났는지 작성]
    
    **`해결`**
    
    👉  [해결 방법 작성]
    
    **`참고 레퍼런스`**
    
    - [문제 해결 시 참고한 링크]

Copyright © 2025 신수정(베뉴) All rights reserved.

Copyright © 2024 김준석(벡스) All rights reserved.