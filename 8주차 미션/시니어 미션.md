# 시니어 미션

**미션 목표:**

- **@DynamicInsert, @DynamicUpdate** 어떻게 작동되는 지 파악하고 장단점을 파악 후에 언제 **적용**하면 좋을 지 파악해보기
- **Rest Docs**가 무엇인지 알아보고 **Swagger**와 장단점 파악하기

**미션 상세 내용:**

### 1️⃣ @DynamicInsert와 @DynamicUpdate가 어떻게 작동되는 지 파악하기

- 기존 JPA 쿼리 문이 어떻게 만들어지는 지 알아보기
- @DynamicInsert, @DynamicUpdate 적용 시 어떻게 바뀌는 지 알아보기

### 2️⃣ 기존과 @DynamicInsert, @DynamicUpdate 적용 시 장단점 파악하기

- 찾아본 원리를 토대로 서로의 장단점 적어보기

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- 장단점을 토대로 언제 @DynamicInsert, @DynamicUpdate를 적용하면 좋을 지 적기
    - 시간이 되신다면 테스트 용 엔티티를 만들어서 시간까지 측정해보면 좋을 것 같습니다. 그 후 정말 쓸모가 있는 지도 파악해보면 좋을 것 같습니다. (이것은 시니어 분들 포함 필수가 아닙니다.)

### 1️⃣ Rest Docs가 무엇인지 알아보기

- Rest Docs가  무엇인지 검색해보기

### 2️⃣ Swagger와 Rest Docs의 장단점 비교하기

- Swagger와 Rest Docs의 장단점 적어보기

### 3️⃣ 언제 적용하면 좋을 지 파악하기

- 장단점을 토대로 언제 Swagger와 Rest Docs를 적용하면 좋을 지 적기
    - 시간이 되신다면 Rest Docs를 실제로 적용해보고 테스트 코드를 적어본 후 문서를 생성해보며 직접 경험해본 후에 적어봐도 좋을 것 같습니다. (이것은 Rest Docs를 적용하는 데도 시간이 많이 걸릴 수 있기에 시니어 분들 포함 필수가 아닙니다.)
- 미션 내용
    
    ## @DynamicInsert와 @DynamicUpdate의 작동 원리
    
    ## JPA의 기본 쿼리 생성 방식
    
    JPA는 기본적으로 엔티티를 생성하거나 수정할 때 **모든 컬럼을 포함한 동일한 쿼리**를 수행합니다. 예를 들어 다음과 같은 엔티티가 있다면
    
    ```java
    @Entity
    public class MyEntity {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        
        private String name;
        private String description;
        private LocalDate createdAt;
    }
    ```
    
    아래와 같이 일부 데이터만 설정해도:
    
    ```java
    MyEntity entity = new MyEntity();
    entity.setName("name");
    ```
    
    실제 생성되는 쿼리는 다음과 같이 모든 컬럼을 포함합니다:
    
    ```sql
    insert into my_entity (name, description, createdAt) values (?, ?, ?)
    ```
    
    이는 **PreparedStatement 캐싱을 통한 성능 최적화** 전략입니다. 동일한 쿼리를 재사용하는 것이 매번 다른 쿼리를 생성하는 것보다 효율적이기 때문입니다.
    
    ## @DynamicInsert, @DynamicUpdate 적용 시 변화
    
    **@DynamicInsert**를 적용하면:
    
    - null이 아닌 필드만 포함하여 INSERT SQL을 동적으로 생성합니다
    - DB에 정의된 기본값이 자동으로 적용됩니다
    
    **@DynamicUpdate**를 적용하면:
    
    - 변경된 필드만 포함하여 UPDATE SQL을 동적으로 생성합니다
    - 불필요한 컬럼 업데이트를 방지합니다
    
    예를 들어 @DynamicInsert 적용 후 생성되는 쿼리:
    
    ```sql
    insert into my_entity (name) values (?)
    ```
    
    @DynamicUpdate 적용 후 name만 변경했을 때 생성되는 쿼리:
    
    ```sql
    update my_entity set name=? where id=?
    ```
    
    ## @DynamicInsert, @DynamicUpdate의 장단점
    
    ## 장점
    
    1. **데이터 전송량 감소**: 실제 필요한 컬럼만 쿼리에 포함되어 네트워크 트래픽이 줄어듭니다
    2. **DB 기본값 활용**: DEFAULT 설정이나 @ColumnDefault와 같은 기본값을 효과적으로 활용할 수 있습니다
    3. **인덱스 재정렬 최소화**: 불필요한 컬럼 업데이트를 방지하여 인덱스 재정렬 비용을 줄입니다
    4. **동시성 이슈 해결**: 여러 트랜잭션에서 서로 다른 필드를 수정할 때 발생할 수 있는 문제를 해결합니다
    
    ## 단점
    
    1. **SQL 캐시 효율 저하**: 동적 쿼리 생성으로 PreparedStatement 캐시 활용도가 떨어집니다
    2. **추가 연산 필요**: 어떤 필드가 변경되었는지 추적하기 위한 추가 연산이 필요합니다
    3. **성능 저하 가능성**: 쿼리 실행마다 변경된 필드를 동적으로 결정하므로 성능이 저하될 수 있습니다
    4. **복잡성 증가**: 엔티티 구조가 복잡할수록 예상치 못한 문제가 발생할 수 있습니다
    
    ## @DynamicInsert, @DynamicUpdate 적용 시점
    
    다음과 같은 상황에서 사용하는 것이 좋습니다:
    
    1. **컬럼이 많은 테이블에서**: 필드가 15-20개 이상인 큰 테이블에서 효과적입니다
    2. **특정 필드만 자주 수정할 때**: 일부 필드만 자주 변경되는 경우 유용합니다
    3. **테이블에 인덱스가 많을 때**: 인덱스가 많은 테이블에서 업데이트 성능을 향상시킵니다
    4. **기본값 설정이 필요할 때**: @ColumnDefault와 같은 기본값 설정을 활용하고자 할 때 필수적입니다
    5. **동시성 이슈 발생 시**: 여러 트랜잭션이 동일한 엔티티의 다른 필드를 변경할 때 유용합니다
    
    ## REST Docs란 무엇인가?
    
    Spring REST Docs는 RESTful 서비스의 문서화를 도와주는 도구입니다. 테스트 코드를 기반으로 API 문서를 자동 생성하며, 기본적으로 Asciidoctor를 사용하여 HTML 문서를 생성합니다.
    
    주요 특징:
    
    - 테스트 코드 기반으로 문서 생성
    - 테스트가 성공해야만 문서 생성 (정확성 보장)
    - 프로덕션 코드와 완전히 분리
    - Asciidoctor를 통한 HTML 문서 생성
    
    ## Swagger와 REST Docs 비교
    
    ## Swagger 장단점
    
    **장점:**
    
    - 간편한 적용이 가능합니다
    - API를 문서상에서 직접 테스트할 수 있습니다
    - 테스트 코드 없이 문서 생성이 가능합니다
    - 자동화된 문서 생성으로 작업량이 줄어듭니다
    - 인터랙티브한 API 탐색 환경을 제공합니다
    
    **단점:**
    
    - 프로덕션 코드에 어노테이션이 추가되어 코드가 지저분해질 수 있습니다
    - 코드와 문서 사이에 불일치가 발생할 가능성이 있습니다
    - 테스트 없이 문서가 생성되므로 정확성이 상대적으로 낮을 수 있습니다
    - 프로젝트가 커지면 성능에 영향을 미칠 수 있습니다
    
    ## REST Docs 장단점
    
    **장점:**
    
    - 프로덕션 코드에 영향을 주지 않습니다
    - 테스트 기반으로 문서가 생성되어 높은 신뢰성을 보장합니다
    - 테스트가 성공해야만 문서가 생성되므로 문서의 정확성이 높습니다
    - 서비스 구현 세부사항으로부터 문서를 보호합니다
    - 버전 변화에 유연하게 대응할 수 있습니다
    
    **단점:**
    
    - 적용이 상대적으로 어렵습니다
    - 테스트 코드 작성이 필수적으로 요구됩니다
    - 문서가 추가되면 템플릿 문서를 일일이 편집해야 합니다
    - 직접적인 API 테스트 기능이 없습니다
    
    ## Swagger와 REST Docs 적용 시점
    
    ## Swagger 적용이 좋은 경우
    
    - 빠른 문서화가 필요한 프로젝트
    - 테스트 코드 작성 없이 문서화하고 싶을 때
    - API를 웹 UI에서 직접 테스트하는 기능이 필요할 때
    - 외부 개발자나 팀과의 협업이 많은 경우
    - 프로토타입 단계나 빠른 개발 사이클에서
    
    ## REST Docs 적용이 좋은 경우
    
    - 높은 수준의 문서 정확성이 요구될 때
    - TDD(테스트 주도 개발) 기반의 프로젝트에서
    - 프로덕션 코드의 깔끔함을 유지하고 싶을 때
    - 엄격한 테스트와 함께 문서화를 진행하고 싶을 때
    - 장기적인 유지보수가 중요한 프로젝트에서