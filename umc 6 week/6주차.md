    # 🎯핵심 키워드

---

<aside>
💡 주요 내용들에 대해 조사해보고, 자신만의 생각을 통해 정리해보세요!
레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 됩니다.
조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**

</aside>

- **지연로딩과 즉시로딩의 차이**
    
    
    | 종류 | 지연로딩 | 즉시로딩 |
    | --- | --- | --- |
    | 특징 | 연관된 엔티티를 실제 사용할 때 로딩 | 연관된 엔티티를 즉시 로딩 |
    | 장점 | 성능 최적화(불필요한 로딩을 방지하여 쓸대없는 자원사용X) | 객체 그래프 탐색 관리 |
    | 단점 | N+1문제 가능성 있음 | 불필요한 쿼리 발생 가능 |
    | 설정 | `@OneToMany(fetch = FetchType.LAZY)` | `@ManyToOne(fetch = FetchType.EAGER)` |
- **Fetch Join**
    
    SQL문의 `Join` 과 비슷하지만 엔티티 객체를 즉시 초기화 하기 위해 사용한다. N+1 해결에 매우 유용하다.
    
    예시
    
    `@Query("SELECT s FROM Store s JOIN FETCH s.reviewList")
    List<Store> findAllWithReviews();`
    
- **@EntityGraph**
    
    Fetch Join과 유사한 역할을 JPQL없이 사용할 수 있게 해줌
    
    선언형으로 필요한 연관관계를 fetch 하도록 지정 가능
    
    예시
    
    `@EntityGraph(attributePaths = {"reviewList"})
    List<Store> findAll();`
    
- **JPQL**
    
    SQL과 비슷하지만, 엔티티 객체를 기준으로 작성할 수 있음
    
    예시
    
    `@Query("SELECT s FROM Store s WHERE [s.name](http://s.name/) = :name")
    Store findByName(@Param("name") String name);`
    
- **QueryDSL**
    
    타입이 안전하고 동적 쿼리에 강함. 또한 BooleanBuilder와 Q타입을 활용함.
    
    `BooleanBuilder builder = new BooleanBuilder();
    if (score != null) builder.and(store.score.goe(score));`
    
    `queryFactory.selectFrom(store)
    .where(builder)
    .fetch();`
    
- **N+1 문제 해결방법**
    
    
    | 해결 방법 | 설명 | 특징 |
    | --- | --- | --- |
    | **Fetch Join** | `@Query` 또는 JPQL에서 `join fetch` 사용 | 가장 직관적이며 성능 향상에 효과적 |
    | **@EntityGraph** | JPA 엔티티에서 연관관계를 즉시 로딩하도록 설정 | 쿼리 분리 없이 간결하게 표현 |
    | **Hibernate batch_size** | 연관된 엔티티들을 **IN 쿼리로 묶어 로딩** | **컬렉션 조회**에 적합 |
    | **JOIN + DTO 직접 조회** | 원하는 필드만 뽑아오는 쿼리를 작성 | 성능 최고, but 코드 복잡 |
    | **QueryDSL의 fetchJoin()** | 타입 안정성과 조건부 조합 가능 | 실무에서 자주 사용됨 |
    | **Spring Data JPA + @Query + fetch join** | 커스텀 Repository에 명시적으로 fetch join 작성 | 복잡한 조건에 유리 |

## 📢 학습 후기

---

- 이번 주차 워크북을 해결해보면서 어땠는지 회고해봅시다.
- 핵심 키워드에 대해 완벽하게 이해했는지? 혹시 이해가 안 되는 부분은 뭐였는지?

## ⚠️ 스터디 진행 방법

---

1. 스터디를 진행하기 전, 워크북 내용들을 모두 채우고 스터디에서는 서로 모르는 내용들을 공유해주세요.
2. 미션은 워크북 내용들을 모두 완료하고 나서 스터디 전/후로 진행해보세요.
3. 다음주 스터디를 진행하기 전, 지난주 미션을 서로 공유해서 상호 피드백을 진행하시면 됩니다.

## ✅ 실습 체크리스트

---

## ☑️ 실습 인증

---

`feature/week6` 브랜치를 판 후 실습 코드를 전부 첨부하여 진행해주세요. 

## 🔥 미션

---

1. N+1 문제를 해결할 수 있는 여러 가지 다른 방법들에 대해 조사한 후, [ 핵심 키워드 ] 에 정리
2. 2주차 미션 때 했던 해당 화면들에 대해 작성했던 쿼리를 QueryDSL로 작성하여 리팩토링하기

![내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)](Untitled.png)

내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)

![리뷰 작성하는 쿼리,
* 사진의 경우는 일단 배제](Untitled%201.png)

리뷰 작성하는 쿼리,
* 사진의 경우는 일단 배제

![홈 화면 쿼리
(현재 선택 된 지역에서 도전이 가능한 미션 목록, 페이징 포함)](Untitled%202.png)

홈 화면 쿼리
(현재 선택 된 지역에서 도전이 가능한 미션 목록, 페이징 포함)

![마이 페이지 화면 쿼리](Untitled%203.png)

마이 페이지 화면 쿼리

# 💪 미션 기록

---

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

- **미션 기록**
    
    ### 1. 내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)
    
    기존에 내가 사용했던 sql문 쿼리
    
    ```sql
    select
        member_mission.id,
        member_mission.reward,
        mission.mission_spec,
        mission.price,
        store.name,
        member_mission.status,
        member_mission.updated_at,
        member.name,
        member.point
    from member_mission
    join mission on member_mission.mission_id = mission.id
    join store on store.id = mission.store_id
    join member on member_mission.member_id = member.id
    where member_mission.member_id = :memberId
    order by member_mission.updated_at desc
    limit 10 offset 0;
    ```
    
    **SqueryDSL 변한**
    
    ```java
    public List<MemberMissionResponse> findMyMissions(Long memberId, int offset, int limit) {
        QMemberMission memberMission = QMemberMission.memberMission;
        QMission mission = QMission.mission;
        QStore store = QStore.store;
        QMember member = QMember.member;
    
        return queryFactory
            .select(Projections.constructor(MemberMissionResponse.class,
                memberMission.id,
                memberMission.reward,
                mission.missionSpec,
                mission.price,
                store.name,
                memberMission.status,
                memberMission.updatedAt,
                member.name,
                member.point
            ))
            .from(memberMission)
            .join(memberMission.mission, mission)
            .join(mission.store, store)
            .join(memberMission.member, member)
            .where(memberMission.member.id.eq(memberId))
            .orderBy(memberMission.updatedAt.desc())
            .offset(offset)
            .limit(limit)
            .fetch();
    }
    
    ```
    
    하지만 이렇게 그대로 하게된다면 예를들어 `MemberMission` 엔티티를 그대로 반환하게되어
    
    ```json
    {
      "id": 2,
      "status": "진행중",
      "updatedAt": "2025-03-29T18:52:39",
      "mission": {
        "id": 1,
        "missionSpec": "사진 업로드 미션",
        "price": 4000,
        "store": {
          "id": 1,
          "name": "가게이름a",
          "address": "서울시 어딘가",
          "createdAt": "2025-03-01T12:00:00",
          "updatedAt": "2025-03-01T12:10:00",
          ...
        },
        ...
      },
      "member": {
        "id": 2,
        "name": "홍길동",
        "email": "홍길동@naver.com",
        "password": "password",
        "point": 3200,
        ...
      }
    }
    
    ```
    
    이렇게 굉장히 더럽고 복잡하게 반환하게 됨. 그래서 DTO 파일 설정 필수. 또한
    
    - 불필요하게 깊은 연관관계 노출
    - `password, email` 같은 민감한 정보들도 노출
    - 보안의 위헙이 있음
    
    필요한 데이터만 전송하기 위해 DTO파일부터 설정해야함.
    
    - 계층 간 역할 분리
    - QueryDSL의 최적화된 쿼리작성
    - 보안
    
    등의 이유도 포함. 아래는 1번문제를 위한 DTO 코드작ㄱ성문
    
    ```java
    package umc.study.dto;
    
    import lombok.AllArgsConstructor;
    import lombok.Data;
    
    import java.time.LocalDateTime;
    
    @Getter
    @AllArgsConstructor
    public class MemberMissionResponse {
        private Long id;               
        private Integer reward;       
        private String missionSpec;   
        private Integer price;        
        private String storeName;      
        private String status;         
        private LocalDateTime updatedAt; 
        private String memberName;     
        private Integer point;         
    }
    
    ```
    
    그로인한 깔끔한 결과물 출력 가능.
    
    ```json
    {
      "missionId": 1,
      "missionSpec": "사진 업로드 미션",
      "storeName": "가게이름a",
      "reward": 500,
      "status": "진행중",
      "updatedAt": "2025-03-29T18:52:39"
    }
    
    ```
    
    ### 2. 리뷰 작성하는 쿼리, * 사진의 경우는 일단 배제
    
    1번에서 DTO를 사용하는 이유를 적었으니
    
    - 기존 SQL 쿼리
    - QueryDSL 변환문
    - DTO 클래스
    - DTO 미사용 시 결과
    - DTO 사용 시 결과
    
    로 나눠 적도록 하겠습니다
    
    ### 리뷰 작성용 DTO
    
    ```java
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public class CreateReviewRequest {
        private Long memberId;
        private Long storeId;
        private String body;
        private Float score;
    }
    
    ```
    
    ### 리뷰작성 Entity 예
    
    ```java
    @Entity
    public class Review {
    
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        @ManyToOne(fetch = FetchType.LAZY)
        private Member member;
    
        @ManyToOne(fetch = FetchType.LAZY)
        private Store store;
    
        private String body;
    
        private Float score;
    
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
    
        @PrePersist
        public void prePersist() {
            createdAt = LocalDateTime.now();
            updatedAt = LocalDateTime.now();
        }
    
        @PreUpdate
        public void preUpdate() {
            updatedAt = LocalDateTime.now();
        }
    }
    
    ```
    
    ### ReviewService 메서드
    커스텀 클래스 제작

    ```java
        // com.example.exception 패키지에 저장
    public class MemberNotFoundException extends RuntimeException {
        public MemberNotFoundException(Long memberId) {
            super("존재하지 않는 사용자입니다. ID=" + memberId);
        }
    }

    public class StoreNotFoundException extends RuntimeException {
        public StoreNotFoundException(Long storeId) {
            super("존재하지 않는 가게입니다. ID=" + storeId);
        }
    }
    ```
    
    
    ```java
    @RequiredArgsConstructor
    @Service
    @Transactional
    public class ReviewService {

        private final MemberRepository memberRepository;
        private final StoreRepository storeRepository;
        private final ReviewRepository reviewRepository;

        public void createReview(CreateReviewRequest dto) {
            Member member = memberRepository.findById(dto.getMemberId())
                .orElseThrow(() -> new MemberNotFoundException(dto.getMemberId()));

            Store store = storeRepository.findById(dto.getStoreId())
                .orElseThrow(() -> new StoreNotFoundException(dto.getStoreId()));

            Review review = Review.builder()
                .member(member)
                .store(store)
                .body(dto.getBody())
                .score(dto.getScore())
                .build();

            reviewRepository.save(review);
        }
    }


    ```
    
    ### ReviewController 예시
    
    ```java
    @RestController
    @RequiredArgsConstructor
    @RequestMapping("/reviews")
    public class ReviewController {
    
        private final ReviewService reviewService;
    
        @PostMapping
        public ResponseEntity<Void> create(@RequestBody CreateReviewRequest request) {
            reviewService.createReview(request);
            return ResponseEntity.ok().build();
        }
    }
    
    ```
    
    `DTO`를 사용하는 이유는 **필요한 필드만 받고** **엔티티를 캡슐화**해서 유지보수성을 높이기 위해서입니다.
    
    ### 3. 홈 화면 쿼리 (현재 선택 된 지역에서 도전이 가능한 미션 목록, 페이징 포함)
    
    1번에서 DTO를 사용하는 이유를 적었으니
    
    - 기존 SQL 쿼리
    - QueryDSL 변환문
    - DTO 클래스
    - DTO 미사용 시 결과
    - DTO 사용 시 결과
    
    로 나눠 적도록 하겠습니다
    
    ### 기존 SQL 쿼리
    
    ```sql
    SELECT 
        mission.id,
        mission.reward,
        mission.mission_spec,
        mission.price,
        store.name,
        DATEDIFF(mission.deadline, NOW()) AS d_day
    FROM mission
    JOIN store ON mission.store_id = store.id
    JOIN region ON store.region_id = region.id
    WHERE region.name = '서울'
    ORDER BY mission.deadline DESC
    LIMIT 10 OFFSET 0;
    
    ```
    
    ### QueryDSL 변환
    
    ```java
    public List<MissionSimpleDto> findMissionByRegion(String regionName, Pageable pageable) {
        QMission mission = QMission.mission;
        QStore store = QStore.store;
        QRegion region = QRegion.region;
    
        return queryFactory
                .select(Projections.constructor(MissionSimpleDto.class,
                        mission.id,
                        mission.reward,
                        mission.missionSpec,
                        mission.price,
                        store.name,
                        Expressions.numberTemplate(Integer.class, "DATEDIFF({0}, {1})", mission.deadline, LocalDateTime.now())
                ))
                .from(mission)
                .join(mission.store, store)
                .join(store.region, region)
                .where(region.name.eq(regionName))
                .orderBy(mission.deadline.desc())
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();
    }
    
    ```
    
    ### DTO 클래스
    
    ```java
    @Getter
    @AllArgsConstructor
    public class MissionSimpleDto {
        private Long id;
        private int reward;
        private String missionSpec;
        private int price;
        private String storeName;
        private int dDay;
    }
    
    ```
    
    ### DTO 사용 시 문제
    
    ```java
    List<Mission> missions = queryFactory
        .selectFrom(QMission.mission)
        .fetch();
    
    for (Mission m : missions) {
        System.out.println(m.getStore().getRegion().getName());
    }
    이렇게 사용하게 되면
    ```
    
    - N+1 문제 발생: `store` 또는 `region`을 LAZY로 설정해놨다면 추가 쿼리 연속 발행됨.
    - 불필요한 필드 포함: 프론트에 필요 없는 `BaseEntity`, `createdAt`, `updatedAt`, 등 다 가져옴.
    
    ### DTO 사용 시 해결되는 것
    
    - 필요한 필드만 추출해서 가볍고 간단한 응답 구조 유지
    - join fetch 안 써도 무관: DTO에는 지연 로딩 걸릴 게 없음
    - 성능 최적화 + 유지보수 용이
    
    ### 4. 마이 페이지 화면 쿼리
    
    ### 기존 SQL 쿼리
    
    ```sql
    SELECT
        member.name,
        member.email,
        CASE
            WHEN member.phone_number IS NULL THEN '미인증'
            ELSE member.phone_number
        END AS phone_number,
        member.point
    FROM member
    WHERE member.id = :id;
    
    ```
    
    ### QueryDSL 변환
    
    ```java
    public MyPageInfoDto getMyPageInfo(Long memberId) {
        QMember member = QMember.member;
    
        return queryFactory
            .select(Projections.constructor(MyPageInfoDto.class,
                member.name,
                member.email,
                Expressions.stringTemplate(
                    "CASE WHEN {0} IS NULL THEN '미인증' ELSE {0} END",
                    member.phoneNumber
                ),
                member.point
            ))
            .from(member)
            .where(member.id.eq(memberId))
            .fetchOne();
    }
    
    ```
    
    ### DTO클래스 예시
    
    ```java
    public record MyPageInfoDto(
        String name,
        String email,
        String phoneNumber,
        int point
    ) {}
    
    ```
    
    ### DTO없이 직접 엔티티 반환 시 생기는 문제
    
    ```java
    public Member getMyPageInfo(Long memberId) {
        return queryFactory
            .selectFrom(QMember.member)
            .where(QMember.member.id.eq(memberId))
            .fetchOne();
    }
    ```
    
    - 불필요한 전체 로딩
    - 연관관계가 많으면 `N+1` 이슈 유발
    - 비밀번호, 상태 같은 필드가 노출되어 보안문제가 발생할 수 있으a
    
    ### DTO 사용 시 좋은점
    
    - 필요한 필드만 추출해서 가볍고 명확한 응답 가능
    - 응답 객체의 구조가 명확함
    - API 명세서와 일치하는 형태로 설계가 용이함.

[시니어 미션](%E1%84%89%E1%85%B5%E1%84%82%E1%85%B5%E1%84%8B%E1%85%A5%20%E1%84%86%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%201e7b57f4596b816380afeb39f208539a.md)

## ⚡ 트러블 슈팅

---

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

</aside>

<aside>
💡 스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널에 질문**해보세요!

</aside>

- ⚡이슈 No.1~9
    
    **`이슈`**
    
    👉 [트러블이 생긴 상태 작성]
    
    **`문제`**
    
    👉 [어떤 이유로 해당 이슈가 일어났는지 작성]
    
    **`해결`**
    
    👉  [해결 방법 작성]
    
    **`참고레퍼런스`**
    
    - [문제 해결 시 참고한 링크]

<aside>
💡

이번주차 워크북을 하면서 Java를 제대로 배우지 못해 코드를 읽고 수정하는데 많은 어려움이 있었습니다. 특히 제가 만든 ERD 구조와 워크북의 구조가 달라 제공해주신 코드가 모두 오류가 떠 일일이 ERD를 수정하는 시간이 많이 걸린 거 같습니다. 실습을 진행하며 생긴 오류들을 모두 정리해보겠습니다.

### 1. Q파일이 중복 생성되는 오류

- 증상: `Attempt to recreate a file for type QXXX` 컴파일 에러 발생.
- 원인: QueryDSL Q파일이 `src/main/java`에도 생기고, `build/generated`에도 중복 생성되어 충돌.
- 해결:
    - Q파일 생성 디렉토리를 하나로 통일.
    - `querydslDir`을 `build/generated/querydsl`로 명시 후, `sourceSets`에 추가:
    
    `def querydslDir = "build/generated/querydsl"
    sourceSets {
    main {
    java {
    srcDirs += [querydslDir]
    }
    }
    }`
    
- 결과물:

![image.png](image%206.png)

이렇게 build폴더에 Q파일들이 들어가도록 수정하는 부분에서 많은 어려움이 있었습니다.

### 2. Q파일이 안 만들어지는 현상

- 증상: `QXXX` 클래스가 생성되지 않음.
- 원인: `annotationProcessorPath` 설정이 누락되어 컴파일러가 생성 못함.
- 해결: 아래 설정 추가:
    
    `tasks.named('compileJava') {
    options.annotationProcessorPath = configurations.querydsl
    }`
    

### 3. Q파일이 build/generated 외 다른 위치에 생기던 문제

- 원인: QueryDSL을 따로 컴파일하는 `compileQuerydsl` task가 누락되어서 기본 빌드 루틴 안에서 임의 위치에 생성.
- 해결: 명시적으로 생성 경로를 지정한 Task 작성 및 등록:
    - `tasks.register("compileQuerydsl", JavaCompile) {
    group = 'build'
    description = 'Compile QueryDSL Q-types'
    source = fileTree('src/main/java')
    classpath = configurations.querydsl
    destinationDirectory.set(file(querydslDir))
    options.annotationProcessorPath = configurations.querydsl
    }`
        
        `tasks.named('compileJava') {
        dependsOn tasks.named('compileQuerydsl')
        }`
        
    

### 4. `clean` 이후에도 Q파일이 계속 남는 문제

- 원인: `clean` 해도 generated 디렉토리를 직접 삭제하지 않으면 Q파일이 남음.
- 해결:`clean.doFirst`에 명시적으로 삭제 작업 추가:
    - `clean.doFirst {
    delete file(querydslDir)
    }`

### 5.QueryDSL 설정 충돌 - annotationProcessor와 implementation

- 증상: Q파일이 생성되지만 일부 모듈에ㅔ서 인식 못함
- 해결:`annotationProcessor`와 `implementation` 둘 다 jakarta 버전으로 정확히 지정:
    - `implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
    annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
    annotationProcessor 'jakarta.persistence:jakarta.persistence-api'`

### 6. MySql DB에서 제공해주신 더미데이터 충돌 문제

### 💣 **MySQL Workbench에서 데이터 INSERT 실패**

- **문제 1**: `Field 'reward' doesn't have a default value`
    - **원인**: 테이블에 `NOT NULL` + `DEFAULT` 없이 컬럼 생성됨.
        
        ![image.png](image%207.png)
        
    - **해결**: `ALTER TABLE mission MODIFY reward int DEFAULT 0;`
        
        ![image.png](image%208.png)
        
- **문제 2**: `safe update mode`로 DELETE 안됨 (Error 1175)
    
    ![image.png](image%209.png)
    
    - **해결**: `SET SQL_SAFE_UPDATES = 0;` 실행 후 삭제 가능.
- **문제 3**: `foreign key constraint fails` (Error 1451)
    - **설명**: 외래키가 걸려 있는데 부모 테이블(region) 삭제 시도.
        
        ![image.png](image%2010.png)
        
    - **해결**: 참조 관계 고려해서 자식 테이블부터 DELETE.

### 7. **Q타입이 없어 발생한 컴파일 오류**

- **현상**: `QBaseEntity` 등 `Q클래스` 관련 클래스들을 인식 못함.
- **원인**: Q파일 생성 디렉토리 문제 혹은 build 전 미생성.
- **대응**:
    - `gradlew clean build`로 수동 생성.
    - `build/generated/querydsl` 디렉토리를 IntelliJ에서 *sources root*로 지정.

### **8. EntityManager 주입 실패 (QueryDSLConfig)**

- **현상**: `Cannot resolve bean of type 'EntityManager'` 오류.
- **원인**: JPA 설정 미완료, 혹은 config 클래스가 스캔되지 않음.
- **해결**:
    - `@Configuration`, `@RequiredArgsConstructor` 설정 확인.
    - `@EnableJpaRepositories` 누락 여부 확인.
    - JPA 설정 제대로 되면 사라짐.

### **9. 디렉토리 구조/패키지 문제**

- `storeRepositoryImpl`, `storeRepositoryCustom` 등을 생성할 때,
    - **interface인지 class인지** 헷갈림.
    - **패키지 위치**를 잘못 지정해서 `@ComponentScan` 대상에서 누락되기도 함.
        
        ![image.png](image%2011.png)
        
- **해결**: 패키지 구조는 다음과 같이 나눔
</aside>

## 🤔 참고 자료

---

Copyright © 2025 신수정(베뉴) All rights reserved.