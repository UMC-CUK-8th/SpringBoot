# 🎯 핵심 키워드

---

<aside>
💡 주요 내용들에 대해 조사해보고, 자신만의 생각을 통해 정리해보세요!
레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 됩니다.
조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**

</aside>

<aside>
🤗 여러분들이 **직접** 중요하다고 생각하는 키워드를 조사해보세요!

</aside>

- RestContollerAdvice
    
    스프링 부트의 기본 에러 화면
    
    ![image.png](image.png)
    
    이렇게 에러 화면이 뜨면  이용자들이 앱을 사용하는게 불편함을 겪는다.
    
    하지만 스프링에서`@ExceptionHandler` 사용함으로서 장점은 사용하면 HttpServletRequest나 WebRequest 등을 얻을 수 있으며 반환 타입으로는 ResponseEntity, String, void 등 자유롭게 활용할 수 있음.
    
    예시코드
    
    ```java
    @GetMapping("/posts")
    public String posts(){
    	int exception = 4/0;
    	return "posts";
    }
    
    @ExceptionHandler(ArithmeticException.class)
    public ResponseEntity<String> handleNoSuchElementFoundException(ArithmeticException exception) {
    	return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(exception.getMessage());
    }
    ```
    
    ![image.png](image%201.png)
    
    참고자료 [여기](https://velog.io/@woosim34/RestControllerAdvice%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC)
    
- lombok
    
    정의 : 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리.
    
    Getter, Setter, Equlas, ToString 같은 코드를 자동완성 시켜줌으로써
    
    코드를 매우 단순화 시킬 수 있음.
    
    - 장점
        - 어노테이션 기반의 코드 자동 생성을 통한 생산성 향상
        - 반복되는 코드 다이어트를 통한 가독성 및 유지보수성 향상
        - Getter, Setter 외에 빌더 패턴이냐 로그 생성 등 다양한 방면으로 활용 가능
        
        많이 사용하는 어노테이션에 대해 조사해보겠습니다
        
    - `@Getter, @Setter`  : 모든 변수들에 대해 적용시키는것, 또한 변수 이름 위에 적용시키면 해당 변수만 적용 가능.
    - `@AllArgsConstructor` : 모든 변수를 사용하는 생성자를 자동완성 시켜주는 어노에티션
    - `@NoArgsConstructor` : 어떠한 변수도 사용하지 않는 기본 생성자를 자동완성 시켜주는 어노테이션
    - `@RequiredArgsConstructor`  : 특정 변수만을 활용하는 생성자를 자동완성 시켜주는 어노테이션
    - `@EqualsAndHashCode`  : 클래스에 대한 equals 함수와 hashCode 함수를 자동으로 생성해준다.
    - `@ToString` : 클래스의 변수들을 기반으로 ToString 메소드를 자동완성시켜준다
    - `@Data`  : 잘 안쓰니 패스
    - `@Builder` : 해당 클래스의 객체의 생성에 Builder 패턴을 적용시켜준다
    - `@Delegate` : 한 객체의 메소드를 다른 객체로 위임시켜준다.

# 📢 학습 후기

---

- 이번 주차 워크북을 해결해보면서 어땠는지 회고해봅시다.
- 핵심 키워드에 대해 완벽하게 이해했는지? 혹시 이해가 안 되는 부분은 뭐였는지?

<aside>
💡

</aside>

# ⚠️ 스터디 진행 방법

---

1. 스터디를 진행하기 전, 워크북 내용들을 모두 채우고 스터디에서는 서로 모르는 내용들을 공유해주세요.
2. 미션은 워크북 내용들을 모두 완료하고 나서 스터디 전/후로 진행해보세요.
3. 다음주 스터디를 진행하기 전, 지난주 미션을 서로 공유해서 상호 피드백을 진행하시면 됩니다.

# 🔥 미션

---

### [UMC 서버 워크북 참고 자료](https://github.com/CYY1007/UMC_SERVER_WORKBOOK.git)

[GitHub - chock-cho/UMC-7th-spring-workbook at feature-week7-workbook](https://github.com/chock-cho/UMC-7th-spring-workbook/tree/feature-week7-workbook)

---

1. 위의 링크, 그리고 워크북을 보며 API 응답 통일과 에러 핸들러를 숙지하기.
2. **반드시** 본인 손으로 처음부터 끝까지 다 해보고 새 리포지토리 혹은 7주차 리포지토리에 새 브랜치에 push 후 해당 링크를 미션 기록지에 제출할 것.
3. 미션 진행 시 반드시 중간 중간 **과정 인증샷**을 남길 것.
4. ❗**필수**❗ ****RestControllerAdvice의 장점, 그리고 없을 경우 어떤 점이 불편한지도 조사하여 **미션 기록란**에 수록할 것.
5. ❗**필수**❗ **미션 목록 조회(진행중, 진행 완료) API 명세서** 작성하기 (이미 작성되어 있으면 상관 없음!)

# 💪 미션 기록

---

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

- **미션 기록**
    
    ### 1. API 응답 통일과 에러 핸들러 숙지하기
    
    - 응답 통일구조
        - 핵심 클래스 `ApiResponse.java`
            
            ```java
            public class ApiResponse<T> {
                private final Boolean isSuccess;
                private final String code;
                private final String message;
                private T result;
            
                public static <T> ApiResponse<T> onSuccess(T result) { ... }
                public static <T> ApiResponse<T> onFailure(String code, String message, T data) { ... }
            }
            
            ```
            
        - 컨트롤러에서 어떤 API를 호출하든 **무조건 `ApiResponse` 형식으로 리턴됨**
        - 성공이면: `onSuccess(data)`
        - 실패면: `onFailure(code, message, null or 에러 상세)`
    
    - 에러 핸들러
        - 전역 예외 처리 클래스
            
            ```java
            @RestControllerAdvice
            public class ExceptionAdvice extends ResponseEntityExceptionHandler {
                ...
            }
            
            ```
            
        - 동작 방식 요약
        
        | 예외 종류 | 처리 방식 | 반환 구조 |
        | --- | --- | --- |
        | `ConstraintViolationException` | Validation 실패 | `ApiResponse.onFailure(...)` |
        | `MethodArgumentNotValidException` | DTO 유효성 검증 실패 | `ApiResponse.onFailure(...)` |
        | `GeneralException` | 커스텀 예외 (직접 정의한 에러) | `ApiResponse.onFailure(...)` |
        | `Exception` | 그 외 모든 예외 | `ApiResponse.onFailure(...)` |
        
        실제 사용 예시
        
        `TempRestController.java` 
        
        ```java
        @GetMapping("/exception")
        public ApiResponse<TempExceptionDTO> exceptionAPI(@RequestParam Integer flag) {
            tempQueryService.CheckFlag(flag); // 여기서 GeneralException 터지면
            return ApiResponse.onSuccess(...); // 이건 호출되지 않음
        }
        ```
        
        → `CheckFlag(flag)` 안에서 조건에 따라 `throw new GeneralException()` 발생
        
        → `ExceptionAdvice`에서 가로채서 `ApiResponse.onFailure(...)` 로 변환
        → 클라이언트는 예외가 나도 항상 JSON 형식 응답을 받음
        
        1번 문제 요약 숙지 포인트
        
        - **모든 API는 `ApiResponse<T>` 형식으로 응답한다.**
        - **에러 상황은 `GeneralException`을 통해 발생시키고,**
        - **`ExceptionAdvice`가 모든 예외를 통일된 JSON으로 바꿔준다.**
        - **실제로 컨트롤러는 성공/실패 구분 없이 동일한 형식으로 리턴하므로 API 응답 구조가 일관된다.**

### 2번과 3번

- 깃허브에 프로젝트 올렸습니다.
- 3번 사진
    - `ApiResponse.java`, `ErrorStatus.java` 코드 화면
        
        ![image.png](image%202.png)
        
    - `ExceptionAdvice.java`에서 예외 처리 중인 코드(양이 많아 첫번쨰 사진 밑 코드는 코드블록으로 작성)
        
        ![image.png](image%203.png)
        
        ```java
        package umc.study.exception;
        
        import jakarta.servlet.http.HttpServletRequest;
        import jakarta.validation.ConstraintViolationException;
        import lombok.extern.slf4j.Slf4j;
        import org.springframework.http.HttpHeaders;
        import org.springframework.http.HttpStatus;
        import org.springframework.http.HttpStatusCode;
        import org.springframework.http.ResponseEntity;
        import org.springframework.web.bind.MethodArgumentNotValidException;
        import org.springframework.web.bind.annotation.ExceptionHandler;
        import org.springframework.web.bind.annotation.RestController;
        import org.springframework.web.bind.annotation.RestControllerAdvice;
        import org.springframework.web.context.request.ServletWebRequest;
        import org.springframework.web.context.request.WebRequest;
        import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
        import umc.study.ApiPayload.ApiResponse;
        import umc.study.ApiPayload.code.ErrorReasonDTO;
        import umc.study.ApiPayload.code.status.ErrorStatus;
        
        import java.util.LinkedHashMap;
        import java.util.Map;
        import java.util.Optional;
        
        @Slf4j
        @RestControllerAdvice(annotations = {RestController.class})
        public class ExceptionAdvice extends ResponseEntityExceptionHandler {
        
            @ExceptionHandler
            public ResponseEntity<Object> validation(ConstraintViolationException e, WebRequest request) {
                String errorMessage = e.getConstraintViolations().stream()
                        .map(constraintViolation -> constraintViolation.getMessage())
                        .findFirst()
                        .orElseThrow(() -> new RuntimeException("ConstraintViolationException 추출 도중 에러 발생"));
        
                return handleExceptionInternalConstraint(e, ErrorStatus.valueOf(errorMessage), HttpHeaders.EMPTY,request);
            }
        
            @Override
            public ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException e, HttpHeaders headers, HttpStatusCode status, WebRequest request) {
        
                Map<String, String> errors = new LinkedHashMap<>();
        
                e.getBindingResult().getFieldErrors().stream()
                        .forEach(fieldError -> {
                            String fieldName = fieldError.getField();
                            String errorMessage = Optional.ofNullable(fieldError.getDefaultMessage()).orElse("");
                            errors.merge(fieldName, errorMessage, (existingErrorMessage, newErrorMessage) -> existingErrorMessage + ", " + newErrorMessage);
                        });
        
                return handleExceptionInternalArgs(e,HttpHeaders.EMPTY,ErrorStatus.valueOf("_BAD_REQUEST"),request,errors);
            }
        
            @ExceptionHandler
            public ResponseEntity<Object> exception(Exception e, WebRequest request) {
                e.printStackTrace();
        
                return handleExceptionInternalFalse(e, ErrorStatus._INTERNAL_SERVER_ERROR, HttpHeaders.EMPTY, ErrorStatus._INTERNAL_SERVER_ERROR.getHttpStatus(),request, e.getMessage());
            }
        
            @ExceptionHandler(value = GeneralException.class)
            public ResponseEntity onThrowException(GeneralException generalException, HttpServletRequest request) {
                ErrorReasonDTO errorReasonHttpStatus = generalException.getErrorReasonHttpStatus();
                return handleExceptionInternal(generalException,errorReasonHttpStatus,null,request);
            }
        
            private ResponseEntity<Object> handleExceptionInternal(Exception e, ErrorReasonDTO reason,
                                                                   HttpHeaders headers, HttpServletRequest request) {
        
                ApiResponse<Object> body = ApiResponse.onFailure(reason.getCode(),reason.getMessage(),null);
        //        e.printStackTrace();
        
                WebRequest webRequest = new ServletWebRequest(request);
                return super.handleExceptionInternal(
                        e,
                        body,
                        headers,
                        reason.getHttpStatus(),
                        webRequest
                );
            }
        
            private ResponseEntity<Object> handleExceptionInternalFalse(Exception e, ErrorStatus errorCommonStatus,
                                                                        HttpHeaders headers, HttpStatus status, WebRequest request, String errorPoint) {
                ApiResponse<Object> body = ApiResponse.onFailure(errorCommonStatus.getCode(),errorCommonStatus.getMessage(),errorPoint);
                return super.handleExceptionInternal(
                        e,
                        body,
                        headers,
                        status,
                        request
                );
            }
        
            private ResponseEntity<Object> handleExceptionInternalArgs(Exception e, HttpHeaders headers, ErrorStatus errorCommonStatus,
                                                                       WebRequest request, Map<String, String> errorArgs) {
                ApiResponse<Object> body = ApiResponse.onFailure(errorCommonStatus.getCode(),errorCommonStatus.getMessage(),errorArgs);
                return super.handleExceptionInternal(
                        e,
                        body,
                        headers,
                        errorCommonStatus.getHttpStatus(),
                        request
                );
            }
        
            private ResponseEntity<Object> handleExceptionInternalConstraint(Exception e, ErrorStatus errorCommonStatus,
                                                                             HttpHeaders headers, WebRequest request) {
                ApiResponse<Object> body = ApiResponse.onFailure(errorCommonStatus.getCode(), errorCommonStatus.getMessage(), null);
                return super.handleExceptionInternal(
                        e,
                        body,
                        headers,
                        errorCommonStatus.getHttpStatus(),
                        request
                );
            }
        }
        ```
        
    
    - Postman에서 에러 발생 후 `ApiResponse` 형식의 응답 확인 화면
    
    ![image.png](image%204.png)
    
    ![image.png](image%205.png)
    
    ![image.png](image%206.png)
    
    ### 4. RestControllerAdvice의 장점, 그리고 없을 경우 어떤 점이 불편한지도 조사하여 **미션 기록란**에 수록할 것.
    
    ## `@RestControllerAdvice`의 장점과 미사용 시 불편한 점
    
    ### `@RestControllerAdvice`의 장점
    
    1. 전역 예외 처리 가능
        - 하나의 클래스에서 전체 컨트롤러의 예외를 한 번에 처리할 수 있어 코드 중복을 줄임
    2. 응답 포맷 통일
        - 어떤 에러가 발생하더라도 `ApiResponse` 같은 통일된 JSON 구조로 응답 가능
            
            → 프론트엔드와 협업 시 일관성 있게 처리됨
            
    3. 유지보수 용이
        - 예외 처리 로직이 한 곳에 집중되어 있어 새로운 예외를 추가하거나 수정하기 쉬움
    4. 가독성과 분리
        - 컨트롤러에서는 핵심 로직에만 집중 가능, 예외 처리는 `Advice`에서 전담
    5. 스프링이 자동으로 DI, 트랜잭션 등 AOP 기능도 함께 처리
    
    ### `@RestControllerAdvice` 의 단점
    
    1. 예외 처리 코드가 컨트롤러마다 중복
        - 같은 `try-catch` 로직이 여러 컨트롤러에 반복됨 → 유지보수 지옥
    2. 응답 포맷이 들쭉날쭉
        - 어떤 API는 JSON, 어떤 API는 에러 메시지만 던지거나 HTTP 상태코드만 다름 → 프론트 개발자 멘붕
    3. 기능 추가/변경이 어려움
        - 예외 처리를 변경하려면 모든 컨트롤러를 다 뒤져야 함
    4. 버그 발생 확률 증가
        - 일관되지 않은 처리로 인해 누락된 예외가 처리되지 않거나 잘못된 응답이 갈 수 있음
    
    ### **5. 미션 목록 조회(진행중, 진행 완료) API 명세서** 작성하기
    
    ### 진행 중 미션 목록 조회 API
    
    | 항목 | 내용 |
    | --- | --- |
    | **URL** | `GET /users/{userId}/missions?status=ACTIVE` |
    | **Method** | GET |
    | **Path Variable** | `userId` (Long) - 유저 식별자 |
    | **Query Params** | `status=ACTIVE` (진행중) |
    
    ```java
    "mission": [
    	{
    	  "isSuccess": true,
    	  "code": "COMMON_SUCCESS",
    	  "message": "요청에 성공하였습니다.",
    	  "result": [
    	    {
    	      "missionId": 1,
    	      "userId": 3,
    	      "missionName": "마라탕 먹기",
    	      "description": "일품 마라탕에서 마라탕먹기",
    	      "createdAt": "2025-05-01T12:00:00",
    	      "updatedAt": "2025-05-10T10:30:00"
    	    }
    	  ]
    	}
    ]
    ```
    
    ### 응답 필드 설명
    
    | 필드명 | 타입 | 설명 |
    | --- | --- | --- |
    | missionId | Long | 미션의 ID |
    | userId | Long | 미션을 받은 사용자의 ID |
    | missionName | String | 미션의 이름 |
    | description | String | 미션 설명 |
    | createdAt | LocalDateTime | 미션 생성 시간 |
    | updatedAt | LocalDateTime | 미션 변경 시간 |
    
    ### 완료된 미션 목록 조회 API
    
    | 항목 | 내용 |
    | --- | --- |
    | **URL** | `GET /users/{userId}/missions?status=INACTIVE` |
    | **Method** | GET |
    | **Path Variable** | `userId` (Long) - 유저 식별자 |
    | **Query Params** | `status=INACTIVE` (완료됨) |
    
    ```java
    {
      "isSuccess": true,
      "code": "COMMON_SUCCESS",
      "message": "요청에 성공하였습니다.",
      "result": [
        {
          "missionId": 2,
          "userId": 3,
          "missionName": "완료된 미션 예시",
          "description": "미션 설명 예시",
          "createdAt": "2025-04-20T15:00:00",
          "updatedAt": "2025-05-01T09:00:00"
        }
      ]
    }
    ```
    
    ### 응답 필드 설명
    
    | 필드명 | 타입 | 설명 |
    | --- | --- | --- |
    | missionId | Long | 미션의 ID |
    | userId | Long | 미션을 받은 사용자의 ID |
    | missionName | String | 미션의 이름 |
    | description | String | 미션 설명 |
    | createdAt | LocalDateTime | 미션 생성 시간 |
    | updatedAt | LocalDateTime | 미션 변경 시간 |

### 참고사항

- 응답 형식은 모두 `ApiResponse<T>` 구조를 따름
- 에러 발생 시도 동일하게 아래 형식으로 응답됨
    
    ```java
    {
      "isSuccess": false,
      "code": "MISSION_NOT_FOUND",
      "message": "존재하지 않는 미션입니다.",
      "result": null
    }
    ```
    

### 발생할 수 있는 예외 및 응답

- 존재하지 않는 사용자 ID
    - 
    
    ```java
    {
      "isSuccess": false,
      "code": "USER_NOT_FOUND",
      "message": "존재하지 않는 사용자입니다.",
      "result": null
    }
    ```
    
- 존재하지 않는 미션
    - 
    
    ```java
    {
      "isSuccess": false,
      "code": "MISSION_NOT_FOUND",
      "message": "존재하지 않는 미션입니다.",
      "result": null
    }
    ```
    
- 잘못된 status 파라미터
    - 
    
    ```java
    {
      "isSuccess": false,
      "code": "INVALID_MISSION_STATUS",
      "message": "유효하지 않은 미션 상태입니다. (ACTIVE, INACTIVE 중 하나)",
      "result": null
    }
    ```
    
- 인증실패
    - 
    
    ```java
    {
      "isSuccess": false,
      "code": "UNAUTHORIZED",
      "message": "인증되지 않은 사용자입니다.",
      "result": null
    }
    ```
    

> **github 링크**
> 
> 
> 

[시니어 미션 ](%E1%84%89%E1%85%B5%E1%84%82%E1%85%B5%E1%84%8B%E1%85%A5%20%E1%84%86%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%201e7b57f4596b81df9e38d5a1e30d6e78.md)

# ⚡ 트러블 슈팅

---

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

</aside>

<aside>
💡 스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널에 질문**해보세요!

</aside>

- ⚡이슈 작성 예시 (이슈가 생기면 아래를 복사해서 No.1, No.2, No3 … 으로 작성해서 트러블 슈팅을 꼭 해보세요!)
    
    **`이슈`**
    
    👉 앱 실행 중에 노래 다음 버튼을 누르니까 앱이 종료되었다.
    
    **`문제`**
    
    👉 노래클래스의 데이터리스트의 Size를 넘어서 NullPointException이 발생하여 앱이 종료된 것이었다. 
    
    **`해결`**
    
    👉  노래 다음 버튼을 눌렀을 때 데이터리스트의 Size를 검사해 Size보다 넘어가려고 하면 다음으로 넘어가는 메서드를 실행시키지 않고, 첫 노래로 돌아가게끔 해결
    
    **`참고레퍼런스`**
    
    - 링크
- ⚡이슈 No.1
    
    **`이슈`**
    
    👉 [트러블이 생긴 상태 작성]
    
    **`문제`**
    
    👉 [어떤 이유로 해당 이슈가 일어났는지 작성]
    
    **`해결`**
    
    👉  [해결 방법 작성]
    
    **`참고레퍼런스`**
    
    - [문제 해결 시 참고한 링크]

---

Copyright © 2023 최용욱(똘이) All rights reserved.

Copyright © 2024 제이미(김준환) All rights reserved.