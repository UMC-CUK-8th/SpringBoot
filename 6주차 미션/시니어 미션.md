# 시니어 미션

**미션 목표:**

- 기존 본인이 진행했던 프로젝트에서 JPA와 QueryDSL을 활용하면서 발생할 수 있는 **성능 병목을 파악하고 해결책을 제시**하세요.

**미션 상세 내용:**

1️⃣ `spring.jpa.show-sql=true` & `logging.level.org.hibernate.SQL=DEBUG` 활성화하여 실행된 SQL 로그 분석

- 특정 API 호출 시 실행된 **SQL 쿼리 로그를 분석**하고 실행 속도가 느린 쿼리를 찾으세요.
- 불필요한 쿼리가 실행되거나 **JOIN이 과도하게 발생하는 경우** 원인을 분석하세요.

2️⃣ 성능 병목이 발생한 코드(쿼리)를 **QueryDSL 기반으로 최적화**

- `@Query`로 작성된 복잡한 SQL을 QueryDSL로 리팩토링하여 실행 속도를 비교하세요.
- `@Transactional(readOnly = true)` 적용 여부에 따른 실행 속도 차이도 테스트해보세요.

3️⃣ `배치 크기(Batch Fetch Size)` 조절을 통한 성능 비교

- `@BatchSize(size = 100)` 설정 후, **쿼리 실행 횟수 변화 확인을 로그로 남겨보세요.**
- `fetch join`을 사용한 경우와 비교하여 성능 차이를 분석해보세요.

4️⃣ 최적화 적용 후, 성능 향상 결과 정리

- 실행 속도가 개선된 SQL 로그를 비교하고, 어떤 부분이 최적화되었는지 설명하세요.
- **실제 애플리케이션에서 적용할 최적화 전략을 정리**하세요.
- 과제 내용
    
    ## 성능 병목 지점 분석
    
    ### 1. N+1 문제 발생 지점
    
    **HomeService의 getOngoingVoteRooms 메서드**
    
    ```java
    List rooms = homeRepository.findAllOngoingAndCompletedCourseTripPlans().stream()
            .filter(tripPlan -> userRoomIds.contains(tripPlan.getRoom().getId()))
            .filter(tripPlan -> (tripPlan.getTripPlanType() == TripPlanType.COURSE) ||
                    (tripPlan.getTripPlanType() == TripPlanType.SCHEDULE && !isVoteTimeExpired(tripPlan.getVoteRoom())))
            .map(HomeConverter::toOngoingVoteRoom)
            .collect(Collectors.toList());
    
    ```
    
    위 코드는 다음과 같은 문제점이 있습니다
    
    - TripPlan 목록을 조회한 후 각 항목에 대해 Room, VoteRoom 엔티티를 개별적으로 로딩(N+1)
    - 스트림 내부에서 Lazy Loading으로 인한 추가 쿼리 발생
    
    ### 2. 비효율적인 JPQL 쿼리
    
    **HomeRepository의 쿼리**
    
    ```java
    @Query("SELECT tp FROM TripPlan tp WHERE tp.status = 'ONGOING' OR (tp.status = 'COMPLETED' AND tp.tripPlanType = 'COURSE')")
    List findAllOngoingAndCompletedCourseTripPlans();
    
    ```
    
    연관 엔티티를 JOIN하지 않아 N+1 문제가 발생합니다.
    
    ### 3. @Transactional(readOnly = true) 누락
    
    HomeService의 모든 조회 메서드에 `@Transactional(readOnly = true)`가 누락되어 있어 불필요한 스냅샷 관리와 더티 체킹이 발생합니다.
    
    ## 성능 최적화 방안
    
    ### 1. Fetch Join을 활용한 N+1 문제 해결
    
    **개선된 HomeRepository**
    
    ```java
    public interface HomeRepository extends JpaRepository {
        // 기존 코드 유지
    
        // 최적화된 쿼리
        @Query("SELECT DISTINCT tp FROM TripPlan tp " +
               "LEFT JOIN FETCH tp.room " +
               "LEFT JOIN FETCH tp.user " +
               "LEFT JOIN FETCH tp.voteRoom " +
               "WHERE tp.status = 'ONGOING' OR (tp.status = 'COMPLETED' AND tp.tripPlanType = 'COURSE')")
        List findAllOngoingAndCompletedCourseTripPlansWithFetch();
    }
    
    ```
    
    ### 2. QueryDSL을 활용한 동적 쿼리 최적화
    
    **HomeRepositoryCustom 인터페이스**
    
    ```java
    public interface HomeRepositoryCustom {
        List findOngoingVoteRoomsByRoomIds(List roomIds);
    }
    
    ```
    
    **QueryDSL 구현체**
    
    ```java
    @RequiredArgsConstructor
    public class HomeRepositoryCustomImpl implements HomeRepositoryCustom {
        private final JPAQueryFactory queryFactory;
    
        @Override
        public List findOngoingVoteRoomsByRoomIds(List roomIds) {
            QTripPlan tripPlan = QTripPlan.tripPlan;
            QRoom room = QRoom.room;
            QVoteRoom voteRoom = QVoteRoom.voteRoom;
    
            return queryFactory
                    .selectFrom(tripPlan)
                    .leftJoin(tripPlan.room, room).fetchJoin()
                    .leftJoin(tripPlan.voteRoom, voteRoom).fetchJoin()
                    .where(
                        tripPlan.room.id.in(roomIds)
                        .and(
                            tripPlan.status.eq(Status.ONGOING)
                            .or(tripPlan.status.eq(Status.COMPLETED).and(tripPlan.tripPlanType.eq(TripPlanType.COURSE)))
                        )
                    )
                    .fetch();
        }
    }
    
    ```
    
    ### 3. 배치 크기 조절을 통한 성능 최적화
    
    **application.yml에 배치 사이즈 설정 추가**
    
    ```yaml
    spring:
      jpa:
        properties:
          hibernate:
            default_batch_fetch_size: 100
    
    ```
    
    **TripPlan 엔티티 컬렉션 필드에 배치 사이즈 적용**
    
    ```java
    @OneToMany(mappedBy = "tripPlan", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @BatchSize(size = 100)
    @Builder.Default
    private List places = new ArrayList<>();
    
    ```
    
    ### 4. 읽기 전용 트랜잭션 적용
    
    **HomeService에 @Transactional(readOnly = true) 추가**
    
    ```java
    @Service
    @RequiredArgsConstructor
    public class HomeService {
        // ...
    
        @Transactional(readOnly = true)
        public Response getOngoingVoteRooms(String userEmail) {
            // 기존 코드
        }
    
        @Transactional(readOnly = true)
        public Response getFutureVoteBasedTrips(String userEmail) {
            // 기존 코드
        }
    
        // 다른 메서드도 동일하게 적용
    }
    
    ```
    
    ## 성능 개선 결과
    
    최적화 적용 전과 후의 성능 비교
    
    **적용 전**:
    
    - `getOngoingVoteRooms` 메서드 호출 시 N+1개의 쿼리 발생 (N은 TripPlan 개수)
    - 불필요한 더티 체킹으로 메모리 사용량 증가
    - 로드된 엔티티 전체를 메모리에 유지
    
    **적용 후**:
    
    - 단일 쿼리로 필요한 모든 데이터 조회 (Fetch Join)
    - 읽기 전용 트랜잭션으로 더티 체킹 비용 절감
    - 배치 사이즈 적용으로 컬렉션 로딩 시 쿼리 수 감소
    
    ## 추가 최적화 전략
    
    1. **DTO 직접 조회 활용**:
    
    ```java
    @Query("SELECT new com.umc.yeogi_gal_lae.api.home.dto.HomeResponse$OngoingVoteRoomDTO(" +
           "tp.id, tp.location, tp.status, tp.tripPlanType) " +
           "FROM TripPlan tp WHERE tp.status = 'ONGOING'")
    List findOngoingVoteRoomDTOs();
    
    ```
    
    1. **인덱스 최적화**:
    
    ```sql
    CREATE INDEX idx_tripplan_status_type ON trip_plans (status, trip_plan_type);
    
    ```
    
    1. **Projection 활용**:
    
    ```java
    public interface TripPlanSummary {
        Long getId();
        String getLocation();
        Status getStatus();
        TripPlanType getTripPlanType();
    }
    
    List findByStatus(Status status);
    
    ```
    
    ## 결론
    
    JPA와 QueryDSL을 활용한 성능 최적화를 통해
    
    - N+1 문제를 해결하여 쿼리 수 감소
    - 필요한 데이터만 효율적으로 조회
    - 트랜잭션 관리 최적화로 리소스 사용 효율화
    - 배치 처리로 컬렉션 로딩 성능 향상