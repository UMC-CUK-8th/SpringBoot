# 시니어 미션

### **서블릿 vs. Spring MVC 비교**

**💡 미션:**

- **전통적인 서블릿(Servlet) 기반 개발과 Spring MVC의 차이**를 조사하고,
    - `HttpServlet`, `doGet()`, `doPost()` 방식과
    - `@Controller`, `@RequestMapping`, `DispatcherServlet` 구조를 비교.
- Spring MVC가 왜 서블릿보다 편리한지 **프레임워크의 역할과 함께 정리해보기**
- **DispatcherServlet**이 내부적으로 요청을 처리하는 방식 단계별 분석하고, (키워드: HandlerMapping, HandlerAdpater) 다이어그램을 그려서 단계별로 설명하기

**🔎 참고 레퍼런스:**

- [Spring 공식 문서 - 서블릿과 인터셉터](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html)
- [Spring MVC 공식 문서](https://docs.spring.io/spring-framework/reference/web/webmvc.html)
- 미션 기록
    
    ### **서블릿과 Spring MVC의 차이점**
    
    전통적인 서블릿 기반 개발은 Java EE 표준의 기본적인 웹 개발 방식으로 아래와 같은 특징을 가짐.
    
    - **`HttpServlet`** 클래스를 상속받아 서블릿을 구현.
    - HTTP 요청 메서드에 따라 **`doGet()`**, **`doPost()`** 등의 **메서드를 오버라이딩하여 구현**.
    - 개발자가 **직접 HTTP 요청과 응답을 처리**.
    - **요청 파라미터 처리, 폼 데이터 바인딩, 유효성 검증** 등을 수동으로 구현.
    
    Ex: 
    
    ```java
    public class MyServlet extends HttpServlet {
    
    		@Override
    		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    				// HTTP GET 처리 로직
    		}
    		
    		@Override
    		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    		    // HTTP POST 처리 로직
    		}
    }
    ```
    
    ### **반면에 Spring MVC 개발 방식은**
    
    Spring MVC는 서블릿 기술 위에 구축된 웹 프레임워크로 아래와 같은 특징을 가짐.
    
    - **`@Controller`** 또는 **`@RestController`** 어노테이션을 사용하여 컨트롤러를 정의.
    - **`@RequestMapping`**, **`@GetMapping`**, **`@PostMapping`** 등의 어노테이션으로 URL 매핑을 처리.
    - **`DispatcherServlet`**이 모든 요청을 받아 적절한 컨트롤러로 위임하는 **프론트 컨트롤러 패턴을 구현.**
    - 요청/응답 처리를 위한 **다양한 추상화 계층**을 제공.
    
    Ex: 
    
    ```java
    @Controller
    public class MyController {
        @GetMapping("/hello")
        public String hello(Model model) {
            model.addAttribute("message", "Hello World");
            return "hello";
        }
        
        @PostMapping("/submit")
        public String submit(@ModelAttribute User user) {
    		    '''
            return "result";
        }
    }
    ```
    
    ### 위와 같은 Spring MVC는 서블릿과 비교하여 아래와 같은 이유들로 더 편리.
    
    1. 저수준의 API를 제공하는 서블릿보다 **추상화 수준이 높음**.
    2. **반복적인 코드 최소화**
    3. **다양한 기능 제공**
        - Ex: 폼 바인딩, 유효성 검증, REST API 지원, JSON/XML 변환 등
    4. 어노테이션으로 인한 설정의 **복잡성 최소화**
    5. 일관된 방식의 **예외 처리**
    6. 다양한 요구사항에 대한 **확장성 및 유연성 제공**
    
    ### **DispatcherServlet의 요청 처리 흐름**
    
    `DispatcherServlet`은 Spring MVC의 핵심 컴포넌트로써 모든 HTTP 요청을 중앙에서 처리하는 프론트 컨트롤러 역할을 수행함.
    
    **DispatcherServlet 흐름 다이어그램**
    
    ```
    클라이언트 → HTTP 요청 → DispatcherServlet
                               ↓
                         HandlerMapping (요청 URL에 매핑된 핸들러 검색)
                               ↓
                         HandlerAdapter (적합한 어댑터 선택)
                               ↓
                         Controller (요청 처리 및 결과 반환)
                               ↓
                 ModelAndView 또는 ResponseEntity/JSON 등 반환
                               ↓
                        ViewResolver (뷰 이름 → 실제 뷰 객체 변환)
                               ↓
                           View (응답 렌더링)
                               ↓
                         클라이언트 응답
    
    ```
    

### **AOP(Aspect-Oriented Programming) 원리 탐구**

**💡 미션:**

- AOP가 무엇인지, 그리고 왜 필요한지 개념적으로 정리한 내용을 블로그 내용에 정의하기
    - **OOP와 AOP의 차이점** 분석.
    - **AOP의 핵심 개념(Advice, JoinPoint, Pointcut, Aspect, Weaving)** 정리.
    - AOP가 적용되는 **런타임 위빙 vs 컴파일 타임 위빙**의 차이점 조사.
- Spring에서 AOP가 프록시 패턴(Proxy Pattern)을 활용하여 동작하는 원리 분석.

**🔎 참고 레퍼런스:**

- [Spring AOP 공식 문서](https://docs.spring.io/spring-framework/reference/core/aop.html)
- 미션 기록
    
    ## **AOP(Aspect-Oriented Programming)**
    
    ---
    
    **AOP란 무엇인가?**
    
    AOP는 **Aspect Oriented Programming**의 약자로 관점 지향 프로그래밍이라고 불린다. 관점 지향은 쉽게 말해어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 **모듈화**하겠다는 것이다. 여기서 모듈화란 **어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다.**
    
    예로 들어 핵심적인 관점은 결국 우리가 적용하고자 하는 핵심 비즈니스 로직이 된다. 또한 부가적인 관점은 핵심 로직을 실행하기 위해서 행해지는 **데이터베이스 연결, 로깅, 파일 입출력** 등을 예로 들 수 있다.
    
    AOP에서 각 관점을 기준으로 로직을 모듈화한다는 것은 **코드들을 부분적으로 나누어서 모듈화**하겠다는 의미다. 이때, **소스 코드상에서 다른 부분에 계속 반복해서 쓰는 코드들**을 발견할 수 있는 데 이것을 **흩어진 관심사 (Crosscutting Concerns)**라 부른다.
    
    [](https://t1.daumcdn.net/cfile/tistory/994AA3335C1B8C9D28)
    
    위와 같이 흩어진 관심사를 Aspect로 모듈화하고 **핵심적인 비즈니스 로직에서 분리하여 재사용**하겠다는 것이 AOP의 취지다.
    
    출처: [https://engkimbs.tistory.com/entry/스프링AOP](https://engkimbs.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81AOP)
    
    [새로비:티스토리]
    
    ### **OOP와 AOP의 차이점**
    
    ---
    
    **OOP(객체 지향 프로그래밍)**
    
    - 코드를 객체 단위로 캡슐화
    - 상속, 다형성, 캡슐화를 통한 코드 재사용 및 구조화
    - 수직적 관점에서 코드 구조화
    
    ---
    
    **AOP(관점 지향 프로그래밍)**
    
    - 코드를 관심사(Aspect) 단위로 모듈화
    - 핵심 비즈니스 로직과 횡단 관심사를 분리
    - 수평적 관점에서 코드 구조화
    - 코드 중복을 줄이고 유지보수성 향상
    
    ## **AOP의 핵심 개념**
    
    ---
    
    1. **Aspect(관점)**: 횡단 관심사를 모듈화한 단위로, **Advice**와 **Pointcut**의 조합.
    2. **Advice(어드바이스)**: 특정 조인 포인트에서 실행되는 코드
        - Before: 메서드 실행 전
        - After: 메서드 실행 후
        - Around: 메서드 실행 전후
        - AfterReturning: 메서드가 정상적으로 반환된 후
        - AfterThrowing: 메서드에서 예외가 발생한 후
    3. **JoinPoint(조인 포인트)**: 프로그램 실행 중 **Advice**가 적용될 수 있는 지점(메서드 실행, 예외 처리 등).
    4. **Pointcut(포인트컷)**: 어떤 **JoinPoint**에 **Advice**를 적용할지 결정하는 표현식.
    5. **Weaving(위빙)**: **Aspect**를 대상 객체에 적용하여 새로운 프록시 객체를 생성하는 과정.
    
    <aside>
    
    **💡 프록시(Proxy)**란 소프트웨어 **디자인 패턴**의 하나로, **다른 객체를 대신**하여 그 객체에 대한 접근을 제어하거나 **기능을 확장**하는 객체를 의미합니다.
    
    프록시는 **실제 객체를 대신**하여 그 객체의 **메서드 호출**을 **가로채고**, 필요한 경우 실제 객체에 대한 작업을 수행합니다. 프록시는 일반적으로 **원래 객체와 같은 인터페이스를 구현**하여, 클라이언트가 **원래 객체를 사용하는 것처럼 보이게 합니다.**
    
    한마디로 표현하자면 **"가짜 객체"**라고 할 수 있습니다.
    
    </aside>
    
    ## **런타임 위빙 vs 컴파일 타임 위빙**
    
    ---
    
    **컴파일 타임 위빙**
    
    - 컴파일 시점에 바이트 코드에 Aspect 코드를 삽입
    - AspectJ 컴파일러 사용
    - 더 나은 성능을 제공하지만 설정이 복잡함
    
    **런타임 위빙**
    
    - 애플리케이션 실행 중에 프록시를 통해 Aspect 적용
    - Spring AOP에서 주로 사용하는 방식
    - 설정이 간단하지만 약간의 성능 오버헤드 발생
    
    ## **Spring에서 AOP와 프록시 패턴**
    
    ---
    
    Spring AOP는 프록시 패턴을 사용하여 구현됨.
    
    1. Spring은 대상 객체에 대한 프록시 객체를 생성.
    2. 클라이언트의 요청은 프록시 객체를 통해 대상 객체로 전달.
    3. 프록시는 요청 전/후에 Advice 로직을 실행.
    4. Spring은 JDK Dynamic Proxy(인터페이스 구현체) 또는 CGLIB(클래스 상속)를 사용하여 프록시를 생성.
- **🍀 도전 과제**
    - 기존 UMC에서 진행했던 프로젝트를 AOP 기반 Logging 전략을 채택하여 리팩토링할 수 있는 방안에 대해 논의해보세요.
- 미션 기록
    
    ## **왜 AOP로 로깅을 해야 할까요?**
    
    여러분이 코드에 로그를 남길 때 보통 이렇게 하죠
    
    ```java
    System.out.println("함수 시작");
    기능 수행();
    System.out.println("함수 종료");
    ```
    
    이런 로그 코드가 모든 함수마다 반복된다면? 비즈니스 로직보다 로그 코드가 더 많아질 수 있어요! **AOP는 이런 반복되는 로그 코드를 한 곳에 모아서 관리할 수 있게 해줍니다**.
    
    ## **쉬운 로깅 전략 3단계**
    
    1. **어디에 로그를 남길지 정하기**
        - API 요청이 들어오고 나갈 때 (컨트롤러)
        - 중요한 비즈니스 로직 실행 시 (서비스)
        - 데이터베이스 작업 시 (리포지토리)
    2. **어떤 정보를 로그로 남길지 정하기**
        - 누가? (사용자 아이디)
        - 언제? (시간)
        - 어디서? (어떤 API, 어떤 함수)
        - 무엇을? (요청 내용, 응답 결과)
        - 얼마나 걸렸나? (실행 시간)
    3. **로그 수준 정하기**
        - 일반 정보는 INFO 레벨
        - 경고는 WARN 레벨
        - 오류는 ERROR 레벨
    
    ## **실제로 적용하는 방법**
    
    1. **Spring AOP 의존성 추가하기**
        - **`build.gradle`**에 Spring AOP 라이브러리 추가
    2. **로깅 Aspect 클래스 만들기**
        - **`@Aspect`**와 **`@Component`** 어노테이션 사용
        - 포인트컷: 로그를 남길 메소드 패턴 (예: 모든 컨트롤러 메소드)
        - 어드바이스: 로그를 남기는 시점 (요청 전, 후, 또는 전후)
    3. **로그 출력 형식 통일하기**
        - "누가 언제 어디서 무엇을 했고 결과는 어떻게 됐는지" 형식으로 통일
    
    위와 같이 AOP를 사용하면 실제 기능 코드(회원가입, 로그인 등)와 로깅 코드를 완전히 분리할 수 있어요. 그래서 코드가 깔끔해지고, 나중에 로깅 방식을 바꾸고 싶을 때도 한 곳만 수정하면 됩니다! 마치 레고 블록처럼 필요한 부분만 교체할 수 있습니다.