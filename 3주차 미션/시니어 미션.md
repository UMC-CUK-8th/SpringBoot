# 시니어 미션

- [x]  Soft Delete가 무엇인지 찾아보시고 soft delete에는 어떠한 HTTP Method가 들어가면 좋을지 적어주세요
    - 내용들을 간단하게 정리하여 주세요
        
        예를 들어 회원탈퇴 api에서 soft delete를 구현한다면 클라이언트가 회원 탈퇴를 한다고 하더라도 회원 정보를 완전히 삭제하는게 아니라 DB에 남겨두고 회원의 상태를 탈퇴 상태로 만들어서 구현하는 것이 좋을 거 같습니다. 이때 HTTP Method로는 DELETE 메서드를 사용하는게 좋을 거 같은데 DELETE 메서드 사용의 이유로는 첫번째 **RESTful 표준 준수로** DELETE 메서드는 리소스를 삭제하는 동작을 나타내므로 클라이언트는 해당 리소스가 더 이상 접근할 수 없는 상태로 간주합니다. 두번째 **클라이언트의 직관적 이해로** 클라이언트는 DELETE 요청을 통해 리소스가 삭제되었다고 인식하며, 내부적으로 데이터를 보존하더라도 클라이언트와 서버 간의 인터페이스는 간단하고 직관적입니다. 마지막으로 **다른 HTTP 메서드와의 혼동 방지로** PUT이나 PATCH를 사용하면 수정 작업으로 오해될 수 있으므로 DELETE 메서드를 사용하는 것이 더 명확합니다. 이와 같은 이유들로 인해서 DELETE Method를 사용하는 것이 좋을 거 같습니다.
        

- [x]  컨트롤 URI에 대해 조사해주시고 어떠할 때 사용이 가능한 지 예시를 들어 설명해주세요.
    - 내용들을 간단하게 정리하여 주세요
        
        ## **컨트롤 URI의 특징**
        
        1. **동사를 포함한 명명**
            - 일반적인 리소스 URI와 달리, 컨트롤 URI는 동작을 나타내는 동사를 포함합니다.
            - 예: **`/orders/{orderId}/start-delivery`**, **`/jobs/{jobId}/cancel`**.
        2. **특정 작업 수행**
            - 단순 CRUD(Create, Read, Update, Delete) 작업 외에 추가적인 프로세스나 상태 변경을 트리거하는 데 사용됩니다.
            - 예: "시작", "중지", "일시 중지", "재시작" 같은 작업 수행.
        3. **HTTP 메서드와의 조합**
            - HTTP 메서드와 함께 사용되어 작업을 명확히 구분합니다.
            - 예: **`POST /jobs/{jobId}/start`**는 작업 시작을 의미하고, **`DELETE /jobs/{jobId}/cancel`**은 작업 취소를 의미할 수 있습니다.
        4. **RESTful 원칙에서의 예외**
            - RESTful 설계 원칙에서는 자원을 URI로 표현하고 행위는 HTTP 메서드로 구분하는 것이 권장되지만, 컨트롤 URI는 이 원칙에서 벗어나 동사를 포함하여 행위를 나타냅니다.
            - 이는 복잡한 비즈니스 로직을 간결하게 표현하기 위한 실용적인 선택입니다.
        
        ## **예시**
        
        | **URI** | **설명** |
        | --- | --- |
        | **`POST /orders/{orderId}/start`** | 주문 처리 시작 |
        | **`DELETE /jobs/{jobId}/cancel`** | 특정 작업 취소 |
        | **`POST /reports/generate`** | 보고서 생성 요청 |
        | **`POST /users/{userId}/cart/checkout`** | 장바구니 결제 처리 |

- [x]  https://learn.microsoft.com/ko-kr/azure/architecture/best-practices/api-design - 문서를 읽고 주요 내용을 간단히 정리해주세요.
    - 내용들을 간단하게 정리하여 주세요
        
        ## **RESTful API 설계의 주요 원칙**
        
        1. **플랫폼 독립성**
            - API는 표준 프로토콜(예: HTTP)과 데이터 형식(JSON, XML 등)을 사용하여 모든 클라이언트가 호출 가능해야 합니다.
            - 내부 구현 세부 사항은 클라이언트에 노출되지 않아야 합니다.
        2. **리소스 중심 설계**
            - API는 비즈니스 엔터티(예: 고객, 주문)를 리소스로 모델링하며, 각 리소스는 고유한 URI로 식별됩니다.
            - URI는 명사 기반으로 설계하며 동사는 피합니다(예: **`/orders`** vs **`/create-order`**).
        3. **HTTP 메서드 활용**
            - CRUD 작업에 적합한 HTTP 메서드를 사용합니다:
                - **`GET`**: 데이터 조회
                - **`POST`**: 새 리소스 생성
                - **`PUT`**: 전체 업데이트
                - **`PATCH`**: 부분 업데이트
                - **`DELETE`**: 리소스 삭제
        4. **무상태성(stateless)**
            - 각 요청은 독립적으로 처리되며, 서버는 클라이언트 상태를 유지하지 않습니다.
            - 확장성과 단순성을 높이는 데 기여합니다.
        5. **표현 및 하이퍼미디어(HATEOAS)**:
            - 리소스 표현에 관련 링크를 포함하여 클라이언트가 다른 리소스를 탐색할 수 있도록 지원합니다.
        
        ## **API 설계 모범 사례**
        
        1. **일관된 URI 구조**
            - 컬렉션은 복수형 명사를 사용하고 계층적 구조를 따릅니다(예: **`/customers/5/orders`**).
        2. **데이터 필터링 및 페이지 매기기**
            - 쿼리 매개변수를 통해 필터링(**`?minCost=100`**) 및 페이지 매기기(**`?limit=10&offset=20`**)를 지원합니다.
        3. **상태 코드 활용**
            - 적절한 HTTP 상태 코드를 반환하여 요청 결과를 명확히 전달합니다(예: **`200 OK`**, **`201 Created`**, **`404 Not Found`**).
        4. **버전 관리**
            - API 변경 시 클라이언트 호환성을 유지하기 위해 버전 관리 전략을 사용합니다.
                - URI 버전(**`/v1/orders`**)
                - 쿼리 문자열 버전(**`?version=1`**)
                - 헤더 기반 버전(**`Custom-Header: api-version=1`**)
        5. **비동기 작업 지원**
            - 장시간 실행되는 작업은 비동기적으로 처리하고, 상태 확인 엔드포인트를 제공합니다(예: 202 Accepted + 상태 URI).
        
        ## **성숙도 모델**
        
        - RESTful API는 Leonard Richardson의 성숙도 모델을 따릅니다
            1. 수준 0: 단일 엔드포인트와 POST 요청만 사용.
            2. 수준 1: 개별 리소스에 대해 URI 정의.
            3. 수준 2: HTTP 메서드를 활용하여 작업 구분.
            4. 수준 3: HATEOAS로 하이퍼미디어 링크 제공.

정리된 글을 바탕으로 블로그를 작성하여 주세요