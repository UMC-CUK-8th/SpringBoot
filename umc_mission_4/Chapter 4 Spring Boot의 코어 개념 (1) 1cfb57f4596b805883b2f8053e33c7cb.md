


## 🎯핵심 키워드

---

<aside>
💡 주요 내용들에 대해 조사해보고, 자신만의 생각을 통해 정리해보세요!
레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 됩니다.
조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**

</aside>

- **DI**
    
    Dependency injection으로 의존성 주입이다. 
     의존성이란 하나의 코드가 다른 코드에 의존하는 형식으로 A라는 코드가 B라는 코드를 사용한다면 A는 B에 의존하고 있다 또는 의존하고 있다라고 말할 수 있다. 
    주입은 넣어주다는 것으로 두 단어를 합치면
    의존성 주입은 의존성이 있는 코드 객체를 넣어준다는 것이다
    A라는 클래스가 B라는 클래스를 사용하고 있을때(=의존하고 있을때) A클래스에서 B 클래스를 직접 생성해서 사용하는 것이 아니라 외부에서 B클래스 인스턴스를 생성해서 주입해준다는 것이다.
    ioc 컨테이너라는 매개체를 두고 여기 필요한 모든 모듈들을 등록해둔다. 그리고 사용처에서 직접 생성하는 것이 아니라 ioc가 필요할때 의존성이 있는 모듈들을 주입해주는 방식이다
    이 과정에서 의존하는 모듈의 생성과 해제 주입 등의 일련의 제어과정을 ioc 컨테이너 기능을 포함하는 프레임 워크들에게 줌으로 제어의 역전이 일어난다.
    
- **IoC**
    
    객체의 생성, 라이프사이클, 제어 및 흐름을 개발자가 아니라 외부 주체인 프레이워크이나 컨테이너가 담당하도록 설계된 원칙이다.
    ioc를 사용하지 않으면 일반적인 객체지향프로그래밍에서는 객체가 필요한 시점에 개발자가 직접 new 키워드를 사용하여 객체를 생성하고, 객체의 메서드를 호출하여 필요한 기능을 수행해야하며 객체간의 의존성도 직접 코드를 통해 설정해야한다.
    
     
    
- **프레임워크와 API의 차이**
    
    프레임워크-어떠한 목적을 쉽게 달성할 수 있도록 해당 목적과 관련되 코드의 뼈대를 미리 만들어 둔 것
    자주 사용되는 기능의 골조 -> 그대로 개발자가 사용
    미리 만들어진 설계도면이 이미 여러개가 존재하고 현재 목적에 맞는 설계도를 사용하여 기본적인 뼈대를 갖추는 것이다
    
    api - 프레임워크는 설계도면이라 했지만 구체적인 내용이 들어있는 것이 아니라 비행기를 만드는 것이라고 하면 기본적인 엔진, 날개, 동체, 조향장치, 안전장치, 프레임이라는 큰 틀을 공유하지만 라이트 형제 비행기나 현대 여객기, 전투기 같이 엔진의 내용이나 항전등의 차이들이 api를 사용하는 것과 같다고 할 수 있다. 기능적이나 성능의 차이를 야기한다.
    
- **AOP**
    
    AOP(Aspect-Oriented Prograwmming) 관련 anotation
    관점 지향프로그래밍
    AOP용어
    Aspect=어떤 주제에 따른 필요한 기능과 그에 해당하는 클래스들을  모은 것에서 주제에 해당하는 것 ,     Advice를 가진 클래스
    Target=추가작업을 진행할 대상,     간섭 적용 대상 클래스
    advice=타겟에 적용하고 싶은 추가작업,     간섭에 사용할 코드를 가진 메소드
    join point = 추가작업을 적용할 구체적인 위치,     Target 내부의 실제 적용 대상 메소드
    Weaving = 실제로 추가작업을 적용하는 행위,     실제 간섭 행위
    pointCut = 추가작업 진행 대상을 특정하는 작업,     Target과 jointPoint를 특정하기 위한 식
    
    추가작업은 언제든지 해제할수있고 해제시 원래대로 돌아간다.
    
    시점에 따른 Advice 구분
    대상이 실행전에 코드를 추가하고 싶은 경우 BeforeAdvice 사용ex) 인증 작업
    대상이 실행우에 코드를 추가하고 싶은 경우 AfterAdvice 사용 ex) 오류 로깅
    실행후 시점은 정상종료/예외발생으로 나뉘고 다른 advice를 사용하여 적용가능하다(@After Throwing, @AfterReturning) 
    대상의 실행전후 모든 상황에 걸처 코드를 추가하고 싶은 경우Around Advice를 사용한다 ex)소요시간 측정 코드
    
    AOP도구로는 filter와 interceptor가 있다.
    
    핵심기능과 부가기능을 분리하는 것이 목적에 있다.
    애플리케이션 로직은 핵심기능과 부가기능으로 나눌수있다. 핵심기능은 해당 객체가 제공하는 고유한 기능이다.  
    부가기능은 핵심기능을 보조하기 위한 기능이다. 로그 추적,보안 , 트랜잭션등  
    특정 로직을 애플리케이션 전부에 적용하는 문제는 일반적인 객체지향으로는 어려움이 있기에 이를 해결하기 위해 aop가 나온 것이다.
     즉 부가기능이 공통적인 것을 모아서  모듈화하여 제공하는 것이다. 핵심적인 원래 핵심기능+부가기능 이런 형식으로 묶여있는 것을 핵심기능/부가기능으로 분리하여 비즈니스 로직에만 집중하게 만들어 주는 기능이다.
    
- **서블릿**
    
    클라이언트(요청자) 프로그램 / 서버(제공자) 프로그램
    두개가 동기화를 위한 설치와 재배포 과정이 복잡해짐 이를 해결하기 위해 웹이라는 것을 이용하게 됨 웹은 빈 페이지를 컴퓨터 스스로 해당 데이터를 넣고 만들어 클라이언트에게 보여준다.
    웹 어플리케이션 서버-> was(was는 동적인 문서를 보여주는 것), Server App = 동적인 문서를 만드는 코드
    WAS(Wep Application Server)+실행환경 Web Server = Server App을 실행 할 수 있게 해주는 환경
    Servlet => **Serv**er Application **Let** (Let은 조각이라는 의미)=> 즉 서버 + 렛(조각) =서버 어플리케이션 조각
    



## 🔥 미션 💪 미션 기록


- **미션 및 미션 기록**
    
    스프링부트의 핵심 원리와 흐름
    스프링은 프레임워크이다
    프레임워크란 워크북에서는 요리법을 가지고 설명을 했고 핵심 키워드에서는 설계도라고 표현했다. 여기에 애매할 수도있는 설계도라는 표현이니라 건축이라고 표현하고싶다. 건물을 지을때 먼저 뼈대를 먼저 잡는다 여기서 뼈대를 개인이 마음데로 설계하는 것이 아니라 휼륭한 설계자가 만든 뼈대 공식을 가지고 사용하는 것이다 코딩에서는 휼륭한 개발자들이 어떠한 형식으로 만드는 것이 좋겠다고 생각하여 스프링을 만들었다고 한다 그렇기에 올바른 설계도를 가지고 만든 건물이 견고하고, 구조 파악하기도 쉬우며, 모듈화가 되어있어 기능에 따라 분리되어있고, 건물의 효율이 증가하고 유지보수가 쉬워지는 것 처럼 스프링을 활용한 코딩도 같은 효과를 볼수있음을 알 수 있다. 기본 뼈대가 잡히고 거기에 살을 붙이는 것은 api로 비즈니스 로직에 따라 무긍무진하게 바뀔 수 있다 건물에 api를 비유를 들자면 인테리어라고 할 수 있다 api에 따라서 건물이 카페가 될수도 사무실 될수도 거주공간이 될 수 있듯이 말이다. 마지막으로 정리하자면 비즈니스 로직을 원할하게 하기위한것이 프레임워크이다. 여기서 어떻게 위와 같은 효과를 볼 수 있냐면 ioc컨테이너, di, 어노테이션, aop를 통해 이뤄진다.
    
    ioc는 inversion of control의 약자로 한국어로 번역하면 제어의 역전이다 ioc의 대표적인 예시는 사용자가 의존성 주입을 하는 것이 아니라 외부에서 의존성을 주입해주는 것인 di이다. ioc컨테이너는 비즈니스 로직을 구현하면서 예를들어 A클래스에 B클래스를 사용한다고 하면 A클래스에서 B클래스를 생성하여 사용하는 것이 아니라 B클래스로 부터 주입을 받는 형식으로 사용하게 된다 여기서 주입을 받는 것이 개발자가 아니라 외부주체인 ioc컨테이너가 해주는 것이다. 그러므로 클래스간 느슨한 연결을 할 수 있고 테스트도 쉬워지며 유지보수 측면에서도 강점을 갖는다. 또한 의존성을 개발자가 신경 쓰지않아도 되기에 비즈니스 로직에 더욱 집중할 수 있는 효과도 얻을 수 있다.
    
    다음으로 di는 dependency injection으로 방금 얘기한 ioc의 장점인 의존성 주입이다. 의존성 주입을 자세히 얘기하면 A클레스에서  B클레스를 사용할때 우선 B클래스는 Bean펙토리에 들어있어야한다. 그렇기에 @component 어노테이션을 사용해서 B클래스를 bean으로 설정해준다 
    첫번째 방법으로 그 다음 A클래스에서 B클래스랑 이어질 생성자를 만들어서 @autowired 어노테이션을 활용해서 해당 생성자가 B클래스랑 연결됨으로 this.인스턴스명을 하여 A클레스에서 B클래스를 사용할 수 있게된다. 이것이 new을 활용하여 직접적으로 A클래스에서 B클래스를 새로 만들어주는 것이 아니라 ioc에서 B클래스를 쏴주는 형식으로 A클래스에서 B클래스를 사용하기에 느슨한 연결이 가능한 것이다. 위 예시는 생성자 주입으로 예시를 든것이다, 다음으로는 DI 방법이다
    
    DI를 하는 방법으로는 생성자 주입, setter 주입, 필드 주입이 있다. 이중에서 제일 많이 사용되는 것이 생성자 주입이다.
    
    생성자 주입은 해당 클래스에 생성자를 하나 만들어서 그곳에서 인자로 가져오려는 클래스의 인스턴스를 받아서 사용하는 것이다. 생성자 주입이 권장되는 이유는 호출시점에서 1번만 호출이 되고 주입데이터가 누락됐을때 런타임 에러가 아닌 컴파일오류가 나서 디버깅하기 수월하기때문이다. 
    
    다음으로는 setter 주입이다.
    
    setter 주입은 해당 클래스에서 set사용하려는 클래스 형식으로 생성자 주입과 비슷하지만 set을 사용한다는 점과 public으로 열어둬야한 다는 점이 큰 차이이다. setter를 사용함으로 선택적인 의존성 처리에 유리하다. 접근 제어자의 차이로 누군가에 의해 변할수 있다는 단점과 런타임에서 의존성이 바뀔 수도 있는 단점을  가지고 있다.
    
    마지막으로 필드 주입이다.
    
    필드주입은 해당 클래스에 B클래스의 데이터타입을 설정하고 어노테이션으로 @autowired를 붙여주기만 하면된다. 설명이 제일 짧은 만큼 코드가 간략해서 보기는 좋지만 의존성이 명시적으로 드러나 있지 않아 순환 참조 문제가 발생할 가능성이 높고 코드를 이해하기 어렵다. 스프링프레임워크에 도움을 받기때문에  di프레임워크가 없으면 아무것도 할 수 없다, 추가로 테스트하기 어렵다 그렇기에 선호되지 않는 방식이다.
    
    대표적인 어노테이션의 예시이다.
    -Bean 등록 관련 anotation
    **Component** : 사용자가 개발한 클래스가 Bean으로 등록될 수 있도록 도와준다. 이를 통해 IoC 컨테이너가 해당 클래스의 객체를 생성, 관리 및 의존성 주입을 한다.
    (@Service: 서비스 계층 클래스에 사용(비즈니스 로직 처리)
    @Repository: 데이터 접근 객체(DAO)에 사용(DB와의 상호작용 처리)
    @Controller: 웹 컨트롤러 클래스에 사용(HTTP 요청과 응답 처리))
    
    Anotation :  클래스나 메서드, 필드 등에 메타데이터를 제공하는 특별한 마커 역할을 한다. Spring 프레임워크를 기준으로 보면, 이러한 anotation은 주로 Bean으로 등록하거나 의존성을 주입하고, 특정 기능을 환성화하거나 설정하기 위해 사용된다.
    
    - 의존성 주입 관련 anotation
    (@**Autowired** : IoC 컨테이너에 등록된 Bean을 자동으로 주입한다
    @Qualifier: 같은 타입의 Bean이 여러 개 있을 때 특정 Bean을 자동으로 주입합니다.
    @Value: 외부 설정 값(예: properties파일)등을 필드에 주입합니다.)
    
    -설정 관련 anotation
    @Configuration: Java 기반의 설정 클래스를 정의하며, 내부에서 @Bean을 사용해 bean을 등록합니다
    @PropertySource: 외부 설정 파일을 로드할 때 사용된다.
    
    AOP(Aspect-Oriented Prograwmming) 관련 anotation
    @Aspect: 해당 클래스를 AOP의 Aspect로 정의한다
    @Before,@Afteer,@Around: 메서드 실행 전후로 특정 로직을 삽입할 때 사용된다
    
    SpringBoot 추가 애노테이션
    @SpringBootApplication: @Configuration, @EnableAutoConfiguration, @ComponentScan의 기능을 포함한 복합 애노테이션이다.
    @RestController: RESTful웹 서비스의 컨트롤러를 정의할 때 사용된다.(자동으로 JSON 응답을 처리)
    많은 필터를 가지고 있다.
    
    aop는 aspect-oriented programming 으로 핵심 목표는 핵심 비즈니스 로직과 부가적인 기능들을 분리하는 것이 목적에 있다. 
    
     서블릿 컨테이너 
    
    간단히 얘기하면 클라이언트가 요청을 하면 서블릿 컨테이너가 받아서 
    
    클라이언트가 자바와 관련된 무언가를 요청하게되면 서블릿이 만들어진다 서블릿컨테이너(ex 톰캣) 서블릿은 자바코드로 웹을 할 수 있는 것이다. 서블릿 컨테이너라는 것은 자바로 웹을 할수있는 것을 모아서 컨테이너로 만들었다는 것이다
    
    서블릿이란  처음 웹 서버는 클라이언트 요청에대해서 정적인 페이지로만 응답할 수 있었다 그래서 웹 서버에 프로그램을 붙여서 동적인 페이지를 생성하기 시작했다. 서블릿도 동적인 페이지를 만들기 위해 웹서버에 붙이는 프로그램 중 하나이다. 서블릿이 요구하는 구현 규칙을 지켜주면서 서블릿을 정의해주면 http요청 정보를 쉽게 사용할 수 있고 처리 결과를 쉽게 응답으로 변환할 수 있다 
    서블릿은 클라이언트의 요청에 해당하는 내용을 다시 보내주는 형식이다 앞서 API명세서를 다룰때 get,post, put, delete, head 등에 해당하는 내용들을 doget, dopost, dodelete 등의 형식으로 다시 내보내주는 것이다. 그렇기에 우리는 서비스 매서드만 재정의하여 처리방법을 지정하면 되는 것이다. 서비스의 호출과 관리 서블릿 컨테이너는 서블릿을 담고 관리하는 것이다. 사용자의 요청이 들어오면 해당 요청과 매핑된 즉 요청으로 들어온 url에 대응하는 서블릿을 찾게된다. 매핑은 개발자가 설정 파일을 설정하여 요청을 처리 할 수 있다. 이 설정파일을 서블릿 컨테이너가 읽어서 서블릿 인스턴스가 컨테이너 안에 존재하는지 파악하고 없으면 init()으로 생성해서 사용하고 존재하면 그대로 사용하게된다. 서블릿 컨테이너에 스레드를 생성하고 미리 만든 httpServletResponse 랑 HttpServletRequest 객체를 인자로 서비스를 호출하는 것이다. 이 서비스를 호출했을때 이부분에서 요청처리 로직이 수행되는 것이다. 이후에는아까 사용한 httpServletResponse 랑 HttpServletRequest 객체를 소멸시킴으로 끝난다. 서블릿은 생성만하고 왜 소멸을 시키지않는 이유는 서블릿이 싱글톤으로 관리되기 때문이다.
     서블릿 객체는 소멸이 안되고 다음번에 같은 요청이 들어오면 서블릿 컨테이너에 의해서 다시 호출되어 사용된다.
     서블릿 컨테이너는 서블릿의 생성주기를 관리한다.
     서블릿의 생성주기를 클라이언트의 요청을 예시로 들어 말하면 클라이언트에게 최초의 요청을 받으면 서블릿 컨테이너는 스레드1를 만든다 해당 스래드1가 서블릿 객체를 하나 만든다. 이 서블릿객체가 많은 일들을 한다. 데이터베이스 커넥션이나 html로 바꿔서 응답해주기 등등
     여러 스레드가 만들어지는 이유는 클라이언트의 리퀘스트는 한번에 한번 하는 것이 아니라 동시에 여러면 수천 혹은 수만명이 할 수 있다는 것이다.
     동시처리를 위해 요청이 올때마다 스레드를 만든다. 스레드2를 만들어 다른 클라이언트의 요청에 응답하기위해 서블릿 객체를 만든다. 각 스레드마다 서블릿 객체를 만드는 이유는 하나의 스레드로 운영이 되는 상황을 가정하면 1번 요청을 작업하는데 3초가 걸린다면 그 3초 만큼 다른 사용자도 기다려야하기에 각 스레드 마다 각각의 서블릿 객체들을 만들어 동시에 처리가 가능하게끔 만들어주는 것이다.
     스레드를 무한정 만드는 것이 아니라 개발자가 효율적인 개수를 설정하여 최적의 성능을 뽑아내야한다. 설정한 개수를 초과한 요청 개수가 들어오면 기존 스레드는 이미 하고있던 일을 마친다음에 해당 요청에 대한 서블릿 객체를 만든다. 이 할일을 끝내면은 스레드는 다음요청이 있는 경우 살아서 그 요청에 해당하는 작업을 하게고 아니라면 해당 스레드는 서블릿 컨테이너가 소멸 시킨다. 이 과정을 통해 마지막으로 만들어지는 것이 http리퀘스트 객체와 http리스폰스 객체이다. 
    
    클라이언트의 공통적인 요청(핸들러 같은 것)을 앞단에서 처리하는 것이 프론트 컨트롤러이다. 모든 요청을 받는 전면 컨트롤러 서블릿은 Dispatcher Servlet이라고 불린다. 이를 통해서 서블릿은 하나만 두고 모든 앞단의 요청을 다 받을 수 있도록 하는 것이다. 이전에 서블릿을 개별적으로 다뤘던 애들은 요청마다 서블릿을 정의하고 요청을 수행할때마다 매번 스레드를 실행했다면 Dispatcher Servlet은 하나의 서블릿만 정의하고 그 서블릿이 모든 요청을 처리하는 것이다. 물론 Dispatcher Servlet이라는 하나의 서블릿이 아니라 이 또한 기능적으로 분리를 하여 처리를 한다
    
    Dispatcher Servlet이 web 요청을 처리하는 과정은 Dispatcher Servlet이 모든 요청을 받고 
    핸들러매핑이 요청을 처리할때 컨트롤러를 찾아서 반환해주는 역할을 한다
    핸들러 어댑터는 그 컨트롤러의 메소드를 호출하여서 처리로직을 수행하고 처리결과를 model and view 객체로 변환하여 Dispatcher Servlet에 넘기는 역할을 한다
    다시 model and view 객체를 받은 Dispatcher Servlet은view 리졸버를 이용하여 뷰를 찾거나 생성하게 된다. 그렇게 얻은 뷰에 model and view 객체를 넣어서 응답결과 생성을 요청하여 우리가 볼 수 있는 JSP나 Thymeleaf 같은 데이터로 응답한다. 이것이 디스패쳐서블릿이 하는 역할이다. 이는 스프링컨테이너로부터 주입받아 다뤄 주기에 개발자는 컨트롤러 또는 핸들러만 신경써주면 된다. 
    즉 서블릿 설정 파일만 잘 작성해주면 설정대로 생성된 객체가 스프링 컨테이너에서 관리되고 필요한 부분에서 주입받아 디스패쳐서블릿이 알아서 사용할 수 있게된다는 것이다.
    앞서 말한 모든 것은 개발자들이 비즈니스 로직 구현에 신경을 쏟을 수 있게끔 만들어주는 도구인 것이다.
     
    